% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bc_ifelse.R
\name{bc_ifelse}
\alias{bc_ifelse}
\title{Broadcasted Ifelse}
\usage{
bc_ifelse(cond, yes, no)
}
\arguments{
\item{cond}{\code{logical} vector or array with the length equal to \code{prod(bc_dim(yes, no))}.}

\item{yes, no}{conformable arrays of the same type. \cr
All atomic types (see \link[base]{atomic}) are supported. \cr
Recursive arrays of type \code{list} are also supported. \cr
since \code{bc_ifelse()} is an S4 generic, it can be extended to support special array classes. \cr}
}
\value{
The ouput, here referred to as \code{out},
will be an array of the same type as \code{yes} and \code{no}. \cr
After broadcasting \code{yes} against \code{no},
given any element index \code{i},
the following will hold for the output:
\itemize{
\item when \code{cond[i] == TRUE}, \code{out[i]} is \code{yes[i]};
\item when \code{cond[i] == FALSE}, \code{out[i]} is \code{no[i]};
\item when \code{cond[i]} is \code{NA},
\code{out[i]} is \code{NA} when \code{yes} and \code{no} are atomic,
and \code{out[i]} is \code{list(NULL)} when \code{yes} and \code{no} are recursive. \cr \cr
}
}
\description{
The \code{bc_ifelse()} S4 generic method
performs a broadcasted form of \link[base]{ifelse}. \cr
}
\examples{
x.dim <- c(c(10, 2,2))
x.len <- prod(x.dim)

gen <- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)

x <- array(gen(10), x.dim)
y <- array(gen(10), c(10,1,1))

cond <- bc.list(
  x, y,
  \(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))
) |> as_bool()

bc_ifelse(cond, yes = x, no = y)
}
