) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
.rcpp_longint_test(1,0)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# set-up ====
library(broadcast)
library(tinycodet)
import_as(~rt, "reticulate")
np <- rt$import("numpy", convert = FALSE)
n <- 25L
npa <- np$random$rand(n, 1L, n, 1L, n)
npb <- np$random$rand(n, n, 1L, n, 1L)
a.dim <- c(n, rep(c(1L, n), 2))
b.dim <- c(n, rep(c(n, 1L), 2))
a <- array(rnorm(100), a.dim)
b <- array(rnorm(100), b.dim)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"), # bc is massively better
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"), # bc is massively better
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"), # bc is massively better
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/vignettes/articles")
save(bm_numpy_large, file = "bm_numpy_large.RData")
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
save(bm_numpy_large, file = "bm_numpy_large.RData")
n <- 200L
npa <- np$random$rand(n, 1L, n)
npb <- np$random$rand(n, n, 1L)
a <- array(rnorm(100), c(n, 1, n))
b <- array(rnorm(100), c(n, n, 1))
bm_numpy_irr <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100,
)
summary(bm_numpy_irr)
ggplot2::autoplot(bm_numpy_irr)
n <- 200L
npa <- np$random$rand(n, 1L, n)
npb <- np$random$rand(n, n, 1L)
a <- array(rnorm(100), c(n, 1, n))
b <- array(rnorm(100), c(n, n, 1))
bm_numpy_irr <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100,
)
summary(bm_numpy_irr)
ggplot2::autoplot(bm_numpy_irr)
n <- 200L
npa <- np$random$rand(n, 1L, n)
npb <- np$random$rand(n, n, 1L)
a <- array(rnorm(100), c(n, 1, n))
b <- array(rnorm(100), c(n, n, 1))
bm_numpy_irr <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100,
)
summary(bm_numpy_irr)
ggplot2::autoplot(bm_numpy_irr)
n <- 30L
npa <- np$random$rand(n, 1L, n, 1L, n)
npb <- np$random$rand(n, n, 1L, n, 1L)
a.dim <- c(n, rep(c(1L, n), 2))
b.dim <- c(n, rep(c(n, 1L), 2))
a <- array(rnorm(100), a.dim)
b <- array(rnorm(100), b.dim)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
n <- 26L
npa <- np$random$rand(n, 1L, n, 1L, n)
npb <- np$random$rand(n, n, 1L, n, 1L)
a.dim <- c(n, rep(c(1L, n), 2))
b.dim <- c(n, rep(c(n, 1L), 2))
a <- array(rnorm(100), a.dim)
b <- array(rnorm(100), b.dim)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
bm_numpy_large <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200,
)
summary(bm_numpy_large)
ggplot2::autoplot(bm_numpy_large)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/vignettes/articles")
save(bm_numpy_large, file = "bm_numpy_large.RData")
?bench::mark
