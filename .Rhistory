double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
.rcpp_longint_test(1,0)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# Preview documentation ====
library(broadcast)
?bc.d
?install.packages("pkgdown")
library(altdoc)
sessionInfo()
library(quarto)
sessionInfo()
library(broadcast)
library(broadcast)
?bc.i
?help
?
help()
help("bc.i", help_type = "text")
help("bc.i", help_type = "pdf")
help("bc.i", help_type = "html")
utils:::index.search("bc.i", find.package())
utils:::index.search("bind_array", find.package())
# map functions to Rds ====
utils:::index.search("bind_array", "broadcast")
# map functions to Rds ====
utils:::index.search("bind_array", find.package())
library(stringi)
# ADAPTED from the altdoc package:
.readlines <- function(x) {
readLines(x, warn = FALSE)
}
rd_index <- function(funs) {
sapply(funs, \(x) utils:::index.search(x, find.package()))
}
rd_index("bc.i")
utils:::index.search("bc.i", find.package())
?bc.i
library(broadcast)
?bc.i
utils:::index.search("bc.i", find.package())
rd_index <- function(funs) {
rd_index <- function(funs) {
rd_index <- function(funs) {
sapply(funs, tempfun)
rd_index <- function(funs) {
tempfun <- function(x) {utils:::index.search(x, find.package()) |> basename()}
sapply(funs, tempfun)
}
rd_index("bc.i")
lapply(funs, tempfun) |> unlist()
rd_index <- function(funs) {
tempfun <- function(x) {utils:::index.search(x, find.package()) |> basename()}
lapply(funs, tempfun) |> unlist()
}
source_file <- "man/aaa00_broadcast_help.Rd"
rd <- readLines(source_file)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
rd <- readLines(source_file)
cat(rd)
funlinks <- paste0("\\link{", funs, "}")
rp <- paste0("\\code{", rd_index(funs), "}")
funs <- getNamespaceExports("broadcast")
rd <- readLines(source_file)
funlinks <- paste0("\\link{", funs, "}")
rp <- paste0("\\code{", rd_index(funs), "}")
temp <- stri_replace_all(
rd, rp, fixed = funlinks
)
temp <- stri_replace_all(
rd, rp, fixed = funlinks, vectorize_all = FALSE
)
cat(temp)
rd_index("bind")
?find.package
rd_index <- function(funs, pkg = "broadcast") {
tempfun <- function(x) {utils:::index.search(x, find.package(pkg))) |> basename()}
rd_index <- function(funs, pkg = "broadcast") {
tempfun <- function(x) {utils:::index.search(x, find.package(pkg)) |> basename()}
lapply(funs, tempfun) |> unlist()
}
rd_index("bind")
source_file <- "man/aaa00_broadcast_help.Rd"
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# Rd -> html
rd <- tools::parse_Rd(source_file)
?tools::Rd2txt_options()
rd <- readLines(source_file)
# codify simple function/topic links:
funlinks <- paste0("\\link{", funs, "}")
funs <- getNamespaceExports("broadcast")
# codify simple function/topic links:
funlinks <- paste0("\\link{", funs, "}")
rp <- paste0("\\code{", funs, "}")
temp <- stri_replace_all(
rd, rp, fixed = funlinks, vectorize_all = FALSE
)
library(stringi)
temp <- stri_replace_all(
rd, rp, fixed = funlinks, vectorize_all = FALSE
)
# near-direct-link aliased function/topic links:
funlinks <- paste0("\\link[=", funs, "]{...}")
rp <- paste0("\\code{", rd_index(funs), "}")
rd_index <- function(funs, pkg = "broadcast") {
tempfun <- function(x) {utils:::index.search(x, find.package(pkg)) |> basename()}
lapply(funs, tempfun) |> unlist()
}
stri_subset(temp, regex = "\\link[=...]{...}")
stri_subset(temp, regex = "\link[=...]{...}")
stri_subset(temp, regex = "\\\link[=...]{...}")
stri_subset(temp, regex = "\\\\link[=...]{...}")
stri_subset(temp, regex = "\\link[=*]{*}")
stri_subset(temp, regex = "\\link\[=...\]\{...\}")
stri_subset(temp, regex = "\\link\[=.\]\{.\}")
stri_subset(temp, regex = "\\link[=.]\{.\}")
stri_subset(temp, regex = "\\link[=.]{.}")
stri_subset(temp, regex = "\\link[=.]\\{.\\}")
stri_subset(temp, regex = "\\link[=..]\\{..\\}")
stri_subset(temp, regex = "\\link[=..]\\{..}")
stri_subset(temp, regex = "\\link[=..]\\{..\\}")
cat(temp)
stri_subset(temp, regex = "\\link[=..]\\{.*?\\}")
stri_subset(temp, regex = "\\link[=.*?]\\{.*?\\}")
stri_subset(temp, regex = "\\link\\[=.*?\\]\\{.*?\\}")
# find exact phrases of alias function/topic links:
exact_all <- stri_extract_all(temp, regex = "\\link\\[=.*?\\]\\{.*?\\}")
# find exact phrases of alias function/topic links:
exact_all <- stri_extract_all(temp, regex = "\\link\\[=.*?\\]\\{.*?\\}") |>
unlist |> na.omit()
# find exact phrases of alias function/topic links:
exact_all <- stri_extract_all(temp, regex = "\\link\\[=.*?\\]\\{.*?\\}") |>
unlist() |> na.omit()
# find exact phrases of alias function/topic links:
extract_all <- stri_extract_all(temp, regex = "\\link\\[=.*?\\]\\{.*?\\}") |>
unlist() |> na.omit()
?stri_extract_all
