templatecode_docall <- "
#define MACRO_DIM_BIGSMALL_DOCALL(DOCODE) do {     \\
int ndims = Rf_length(out_dim);         \\
\\
if(bigx) {                           \\
switch(ndims) {                       \\
<cases_bigx>                     \\
}                                     \\
}                                       \\
else {                                  \\
switch(ndims) {                       \\
<cases_bigy>                     \\
}                                     \\
}                                       \\
} while(0)"
templatecode_docall2 <- stringi::stri_replace_all(
templatecode_docall,
fixed = c("<cases_bigx>", "<cases_bigy>"),
replacement = c(cases_bigx, cases_bigy),
vectorize_all = FALSE
)
cat(templatecode_docall2)
macro_dim_bigsmall_docall <- templatecode_docall2
################################################################################
# General ====
#
DTYPES <- c(2:16)
all_for <- c(
sprintf("\t for(int iter%d = 0; iter%d < pout_dim[%d]; ++iter%d) {\t\\", 1:16, 1:16, 0:15, 1:16)
)
forx <- c(
"\t\\",
sprintf("i_x%d = pby_x[%d] * iter%d * pdcp_x[%d];\t\\", 2:16, 1:15, 2:16, 1:15)
)
fory <- c(
"\t\\",
sprintf("i_y%d = pby_y[%d] * iter%d * pdcp_y[%d];\t\\", 2:16, 1:15, 2:16, 1:15)
)
all_for <- stri_c(all_for, forx, fory, sep = "\n")
cat(all_for[16])
all_parts_x <- c(
"pby_x[0] * iter1",
sprintf("i_x%d", 2:16)
)
all_parts_y <- c(
"pby_y[0] * iter1",
sprintf("i_y%d", 2:16)
)
all_x_decl <- sprintf("i_x%d", 2:16)
all_y_decl <- sprintf("i_y%d", 2:16)
temp <- "
#define MACRO_DIM_<dtype>(DOCODE) do {      \\
R_xlen_t counter = 0;         \\
const int *pby_x = INTEGER_RO(by_x);        \\
const int *pby_y = INTEGER_RO(by_y);        \\
const int *pout_dim = INTEGER_RO(out_dim);      \\
R_xlen_t flatind_x;       \\
R_xlen_t flatind_y;       \\
R_xlen_t <all_x_decl>; \\
R_xlen_t <all_y_decl>; \\
<startfor>
flatind_x = <main_x>;       \\
flatind_y = <main_y>;     \\
\\
DOCODE;                                                          \\
\\
pout[counter] = tempout;        \\
counter++;                      \\
<endfor>
} while(0)
"
dMacro_skeletons <- character(length(DTYPES))
names(dMacro_skeletons) <- DTYPES
counter <- 1
for(i in DTYPES) {
current_x_decl <- stri_c(all_x_decl[1:(i-1)], collapse = ", ")
current_y_decl <- stri_c(all_y_decl[1:(i-1)], collapse = ", ")
current_for <- stri_c(all_for[i:1], collapse = "\n")
current_main_x <- stri_c(all_parts_x[1:i], collapse = " + ")
current_main_y <- stri_c(all_parts_y[1:i], collapse = " + ")
current_end <- stri_c(rep("\t }\t\\", i), collapse = "\n")
current_fixed <- c(
"<dtype>",
"<all_x_decl>",
"<all_y_decl>",
"<startfor>",
"<main_x>",
"<main_y>",
"<endfor>"
)
current_replacement <- c(
i,
current_x_decl,
current_y_decl,
current_for,
current_main_x,
current_main_y,
current_end
)
out <- stri_replace_all(
temp,
fixed = current_fixed,
replacement = current_replacement,
case_insensitive = FALSE,
vectorize_all = FALSE
)
dMacro_skeletons[counter] <- out
counter <- counter + 1
}
cat(dMacro_skeletons[[2]])
macro_dim_d <- stri_c(dMacro_skeletons, collapse = "\n")
################################################################################
# do call ====
#
# cases:
case <-
"case %d:                                       \\
MACRO_DIM_%d(DOCODE);    \\
break;                                        \\
"
cases <- sprintf(case, 2:16, 2:16) |> stringi::stri_c(collapse = "")
cat(cases)
templatecode_docall <- "
#define MACRO_DIM_DOCALL(DOCODE) do {     \\
int ndims = Rf_length(out_dim);         \\
\\
switch(ndims) {       \\
<cases>       \\
}       \\
} while(0)"
templatecode_docall2 <- stringi::stri_replace_all(
templatecode_docall,
fixed = c("<cases>"),
replacement = c(cases),
vectorize_all = FALSE
)
cat(templatecode_docall2)
macro_dim_docall <- templatecode_docall2
################################################################################
# Macro Bind ====
#
DTYPES <- c(2:16)
all_for <- sprintf(
"\t for(int iter%d = pstart[%d] - 1; iter%d < pend[%d]; ++iter%d) {\t\\",
1:16, 0:15,  1:16, 0:15, 1:16
)
forout <- c(
"\t\\",
sprintf("i_out%d = iter%d * pdcp_out[%d];\t\\", 2:16, 2:16, 1:15)
)
forx <- c(
"\t\\",
sprintf("i_x%d = pby_x[%d] * iter%d * pdcp_x[%d];\t\\", 2:16, 1:15, 2:16, 1:15)
)
all_for <- stri_c(all_for, forout, forx, sep = "\n")
cat(all_for[16])
all_parts_out <- c(
"iter1",
sprintf("i_out%d", 2:16)
)
all_parts_x <- c(
"pby_x[0] * iter1",
sprintf("i_x%d", 2:16)
)
all_out_decl <- sprintf("i_out%d", 2:16)
all_x_decl <- sprintf("i_x%d", 2:16)
temp <- "
#define MACRO_DIM_BIND_<dtype>(DOCODE) do {  \\
double *pdcp_out = REAL(dimcumprod_out);  \\
double *pdcp_x = REAL(dimcumprod_x);  \\
\\
R_xlen_t counter = 0;                 \\
const int *pby_x = INTEGER_RO(by_x);  \\
const int *pstart = INTEGER_RO(starts); \\
const int *pend = INTEGER_RO(ends);    \\
R_xlen_t flatind_out;                 \\
R_xlen_t flatind_x;                   \\
R_xlen_t <all_out_decl>;              \\
R_xlen_t <all_x_decl>;                \\
<startfor>
flatind_out = <main_out>;       \\
flatind_x = <main_x>;           \\
DOCODE;                         \\
<endfor>
} while(0)
"
dMacro_skeletons <- character(length(DTYPES))
names(dMacro_skeletons) <- DTYPES
counter <- 1
for(i in DTYPES) {
current_out_decl <- stri_c(all_out_decl[1:(i-1)], collapse = ", ")
current_x_decl <- stri_c(all_x_decl[1:(i-1)], collapse = ", ")
current_for <- stri_c(all_for[i:1], collapse = "\n")
current_main_out <- stri_c(all_parts_out[1:i], collapse = " + ")
current_main_x <- stri_c(all_parts_x[1:i], collapse = " + ")
current_end <- stri_c(rep("\t }\t\\", i), collapse = "\n")
current_fixed <- c(
"<dtype>",
"<all_out_decl>",
"<all_x_decl>",
"<startfor>",
"<main_out>",
"<main_x>",
"<endfor>"
)
current_replacement <- c(
i,
current_out_decl,
current_x_decl,
current_for,
current_main_out,
current_main_x,
current_end
)
out <- stri_replace_all(
temp,
fixed = current_fixed,
replacement = current_replacement,
case_insensitive = FALSE,
vectorize_all = FALSE
)
dMacro_skeletons[counter] <- out
counter <- counter + 1
}
cat(dMacro_skeletons[[1]])
macro_dim_bind <- stri_c(dMacro_skeletons, collapse = "\n")
################################################################################
# do call Bind ====
#
# cases:
case <-
"case %d:                                       \\
MACRO_DIM_BIND_%d(DOCODE);    \\
break;                                        \\
"
cases <- sprintf(case, 2:16, 2:16) |> stringi::stri_c(collapse = "")
cat(cases)
templatecode_docall <- "
#define MACRO_DIM_BIND_DOCALL(DOCODE) do {     \\
int ndims = Rf_length(out_dim);         \\
\\
switch(ndims) {       \\
<cases>       \\
}       \\
} while(0)"
templatecode_docall2 <- stringi::stri_replace_all(
templatecode_docall,
fixed = c("<cases>"),
replacement = c(cases),
vectorize_all = FALSE
)
cat(templatecode_docall2)
macro_dim_bind_docall <- templatecode_docall2
################################################################################
# Save macros ====
#
macro_dim <- stri_c(
"\n",
macro_dim_vector,
"\n",
macro_dim_orthovector,
"\n",
macro_dim_bigx,
"\n",
macro_dim_bigy,
"\n",
macro_dim_bigsmall_docall,
"\n",
macro_dim_d,
"\n",
macro_dim_docall,
"\n",
macro_dim_bind,
"\n",
macro_dim_bind_docall,
"\n"
)
readr::write_file(macro_dim, "macro_dim.txt")
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp.h>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op
)
header_for_package <- "
#include <Rcpp.h>
#include \"Broadcast.h\"
using namespace Rcpp;
"
Rcpp::sourceCpp(code = header_for_sourcing)
txt <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(rcpp_bc_bind)]]
void rcpp_bc_bind(
SEXP out, SEXP x,
SEXP starts, SEXP ends, SEXP by_x,
SEXP dimcumprod_out, SEXP dimcumprod_x, SEXP out_dim
) {
double *pout = REAL(out);
double *px = REAL(x);
MACRO_DIM_BIND_DOCALL(pout[flatind_out] = px[flatind_x]);
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
################################################################################
# perform tests ====
#
library(tinytest)
# rbind:
## make args and allocate output:
margin <- 1L
x <- matrix(as.double(1:4), ncol = 2)
y <- matrix(5:6, ncol = 1)
args <- list(x, y)
out.dim <- do.call(pmax, lapply(args, dim))
out.dim[margin] <- out.dim[margin] * length(args)
out <- array(NA_real_, dim = out.dim)
## make params:
dcp_x <- c(1, cumprod(dim(x)))
dcp_y <- c(1, cumprod(dim(y)))
dcp_out <- c(1, cumprod(dim(out)))
by_x <- ifelse(dim(x) > 1L, 1L, 0L)
by_y <- ifelse(dim(y) > 1L, 1L, 0L)
## do part 1:
print(out)
starts <- c(1L, 1L)
ends <- c(nrow(x), ncol(out))
rcpp_bc_bind(out, x, starts, ends, by_x, dcp_out, dcp_x, out.dim)
print(out)
paste
pryr::show_c_source(.Internal(paste(list(...), sep, collapse, recycle0)))
Rcpp::cppFunction(
"
StringVector rcpp_paste(
CharacterVector x, CharacterVector y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = x[i];
out[i] += y[i];
}
return out;
}
"
)
rcpp_paste(x, y)
x <- letters
y <- LETTERS
rcpp_paste(x, y)
print(x)
print(y)
Rcpp::cppFunction(
"
StringVector rcpp_paste(
CharacterVector x, SEXP y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
const int *py = INTEGER_RO(y)
for(R_xlen_t i = 0; i < n; ++i) {
if(y > 0) {
out[i] = x[i];
if(y > 1) {
for(int j = 1; j < y; ++j) {
out[i] += x[i];
}
}
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
StringVector rcpp_paste(
CharacterVector x, SEXP y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
const int *py = INTEGER_RO(y);
int count = 0
for(R_xlen_t i = 0; i < n; ++i) {
count = py[i]
if(count > 0) {
out[i] = x[i];
if(count > 1) {
for(int j = 1; j < count; ++j) {
out[i] += x[i];
}
}
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
StringVector rcpp_paste(
CharacterVector x, SEXP y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
const int *py = INTEGER_RO(y);
int count = 0
for(R_xlen_t i = 0; i < n; ++i) {
count = py[i];
if(count > 0) {
out[i] = x[i];
if(count > 1) {
for(int j = 1; j < count; ++j) {
out[i] += x[i];
}
}
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
StringVector rcpp_paste(
CharacterVector x, SEXP y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
const int *py = INTEGER_RO(y);
int count = 0;
for(R_xlen_t i = 0; i < n; ++i) {
count = py[i];
if(count > 0) {
out[i] = x[i];
if(count > 1) {
for(int j = 1; j < count; ++j) {
out[i] += x[i];
}
}
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
StringVector rcpp_string_plus(
CharacterVector x, CharacterVector y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = x[i];
out[i] += y[i];
}
return out;
}
"
)
x <- letters
y <- LETTERS
rcpp_string_plus(x, y)
print(x)
print(y)
Rcpp::cppFunction(
"
StringVector rcpp_string_mult(
CharacterVector x, SEXP y
) {
R_xlen_t n = Rf_length(x);
CharacterVector out(n);
const int *py = INTEGER_RO(y);
int count = 0;
for(R_xlen_t i = 0; i < n; ++i) {
count = py[i];
if(count > 0) {
out[i] = x[i];
if(count > 1) {
for(int j = 1; j < count; ++j) {
out[i] += x[i];
}
}
}
}
return out;
}
"
)
rcpp_string_mult(x, y)
x <- letters
y <- 1:26
rcpp_string_mult(x, y)
