{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Ifelse ====
macro_op_ifelse <- "
#define MACRO_OP_IFELSE(DIMCODE) do {       \\
switch(TYPEOF(x)) {	\\
case LGLSXP:	\\
{	\\
const int *px = LOGICAL_RO(x);	\\
const int *py = LOGICAL_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(LGLSXP, nout));	\\
int *pout;	\\
pout = LOGICAL(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_LOGICAL,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case INTSXP:	\\
{	\\
const int *px = INTEGER_RO(x);	\\
const int *py = INTEGER_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));	\\
int *pout;	\\
pout = INTEGER(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_INTEGER,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case REALSXP:	\\
{	\\
const double *px = REAL_RO(x);	\\
const double *py = REAL_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));	\\
double *pout;	\\
pout = REAL(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_REAL,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case CPLXSXP:	\\
{	\\
const Rcomplex *px = COMPLEX_RO(x);	\\
const Rcomplex *py = COMPLEX_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));	\\
Rcomplex *pout;	\\
pout = COMPLEX(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = rcpp_cplx_returnNA(),	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case STRSXP:	\\
{	\\
const SEXP *px = STRING_PTR_RO(x);	\\
const SEXP *py = STRING_PTR_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(STRSXP, nout));	\\
SEXP *pout;	\\
pout = STRING_PTR(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_STRING,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case RAWSXP:	\\
{	\\
const Rbyte *px = RAW_RO(x);	\\
const Rbyte *py = RAW_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(RAWSXP, nout));	\\
Rbyte *pout;	\\
pout = RAW(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case VECSXP:	\\
{	\\
SEXP out = PROTECT(Rf_allocVector(VECSXP, nout));	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
SET_VECTOR_ELT(out, flatind_out, R_NilValue),	\\
SET_VECTOR_ELT(out, flatind_out, pcond[flatind_out] ? VECTOR_ELT(x, flatind_x) : VECTOR_ELT(y, flatind_y))	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
default:	\\
{	\\
stop(\"unsupported type\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# bcapply ====
macro_op_bcapply <- "
#define MACRO_OP_BCAPPLY(DIMCODE) do {       \\
switch(TYPEOF(out)) {	\\
case LGLSXP:	\\
{	\\
int *pout;	\\
pout = LOGICAL(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = LOGICAL(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case INTSXP:	\\
{	\\
int *pout;	\\
pout = INTEGER(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = INTEGER(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case REALSXP:	\\
{	\\
double *pout;	\\
pout = REAL(out);	\\
DIMCODE(	\\
pout[flatind_out] = REAL(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case CPLXSXP:	\\
{	\\
Rcomplex *pout;	\\
pout = COMPLEX(out);	\\
DIMCODE(	\\
pout[flatind_out] = COMPLEX(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case STRSXP:	\\
{	\\
SEXP out = PROTECT(Rf_allocVector(STRSXP, nout));	\\
SEXP *pout;	\\
pout = STRING_PTR(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = STRING_PTR(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case RAWSXP:	\\
{	\\
Rbyte *pout;	\\
pout = RAW(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = RAW(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case VECSXP:	\\
{	\\
DIMCODE(	\\
SET_VECTOR_ELT(out, flatind_out, f(x, y, flatind_x + 1, flatind_y + 1))	\\
);	\\
break; \\
}	\\
default:	\\
{	\\
stop(\"unsupported type\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Save Macros ====
#
macro_op <- stri_c(
macro_assign_C,
"\n",
macro_op_dec_math,
"\n",
macro_op_dec_rel,
"\n",
macro_op_int_math,
"\n",
macro_op_int_rel,
"\n",
macro_op_bool_math,
"\n",
macro_op_cplx_math,
"\n",
macro_op_cplx_rel,
"\n",
macro_op_str_conc,
"\n",
macro_op_str_rel,
"\n",
macro_op_str_dist,
"\n",
macro_op_ifelse,
"\n",
macro_op_bcapply,
"\n"
)
readr::write_file(macro_op, "macro_op.txt")
# set-up ====
library(stringi)
# dMacro_skeletons <- qs::qread("dMacro_skeletons")
# macros <- stri_c(dMacro_skeletons, collapse = "\n")
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header <- stri_c("
#ifndef BROADCAST_H
#define BROADCAST_H
",
macro_action,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op,
"\n",
macro_dim,
"
#endif
"
)
cat(header)
Rcpp::sourceCpp(code = header)
readr::write_file(header, "inst/include/broadcast.h")
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp/Lightest>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op
)
header_for_package <- "
#include <Rcpp/Lightest>
#include \"Broadcast.h\"
using namespace Rcpp;
"
readr::write_file(header_for_sourcing, "header.txt")
Rcpp::sourceCpp(code = header_for_sourcing)
txt0 <- "
inline double rcpp_int53_guard(
double out, double intmin, double intmax
) {
if(out > intmax) {
return R_PosInf;
}
if(out < intmin) {
return R_NegInf;
}
return out;
}
inline double rcpp_int53_mod(double x, double y, double intmin, double intmax) {
if(x < intmin || x > intmax || y < intmin || y > intmax) {
return NA_REAL;
}
return (long long) x % (long long) y;
}
"
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_v)]]
SEXP rcpp_bc_int_v(
SEXP x, SEXP y,
R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_VECTOR);
UNPROTECT(1);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_ov)]]
SEXP rcpp_bc_int_ov(
SEXP x, SEXP y, bool RxC, SEXP out_dim,
R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_ORTHOVECTOR);
UNPROTECT(1);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_bs)]]
SEXP rcpp_bc_int_bs(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, bool bigx,
int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_BIGSMALL_DOCALL);
UNPROTECT(1);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_d)]]
SEXP rcpp_bc_int_d(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_DOCALL);
UNPROTECT(1);
return out;
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
txt <- stringi::stri_c(
header_for_package,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
readr::write_file(txt, "src/rcpp_bc_int.cpp")
library(tinytest)
library(broadcast)
.internal_bind_array <- broadcast:::.internal_bind_array
along <- 2L
n <- 100
nms <- function(n) sample(letters, n, TRUE)
x <- array(as.double(1:25), c(n, n, n))
y <- array(as.double(-1:-25), c(n, n, n))
dimnames(x) <- lapply(dim(x), nms)
dimnames(y) <- lapply(dim(y), nms)
input <- list(x, y)
out1 <- abind::abind(input, along = along)
out2 <- .internal_bind_array(input, along, 1L, TRUE, sys.call())
expect_equivalent(
out1, out2
)
foo <- bench::mark(
abind = abind::abind(input, along = along),
bc = .internal_bind_array(input, along, 1L, TRUE, sys.call()),
cbind = do.call(cbind, input),
min_iterations = 100,
check = FALSE # because abind adds empty dimnames
)
summary(foo)
ggplot2::autoplot(foo)
foo <- bench::mark(
abind = abind::abind(input, along = along),
bc = .internal_bind_array(input, along, 1L, TRUE, sys.call()),
# cbind = do.call(cbind, input),
min_iterations = 100,
check = FALSE # because abind adds empty dimnames
)
summary(foo)
ggplot2::autoplot(foo)
along <- 2L
n <- 200
nms <- function(n) sample(letters, n, TRUE)
x <- array(as.double(1:25), c(n, n, n))
y <- array(as.double(-1:-25), c(n, n, n))
dimnames(x) <- lapply(dim(x), nms)
dimnames(y) <- lapply(dim(y), nms)
input <- list(x, y)
out1 <- abind::abind(input, along = along)
out2 <- .internal_bind_array(input, along, 1L, TRUE, sys.call())
expect_equivalent(
out1, out2
)
foo <- bench::mark(
abind = abind::abind(input, along = along),
bc = .internal_bind_array(input, along, 1L, TRUE, sys.call()),
# cbind = do.call(cbind, input),
min_iterations = 100,
check = FALSE # because abind adds empty dimnames
)
along <- 2L
n <- 150L
nms <- function(n) sample(letters, n, TRUE)
x <- array(as.double(1:25), c(n, n, n))
y <- array(as.double(-1:-25), c(n, n, n))
dimnames(x) <- lapply(dim(x), nms)
dimnames(y) <- lapply(dim(y), nms)
input <- list(x, y)
out1 <- abind::abind(input, along = along)
out2 <- .internal_bind_array(input, along, 1L, TRUE, sys.call())
expect_equivalent(
out1, out2
)
foo <- bench::mark(
abind = abind::abind(input, along = along),
bc = .internal_bind_array(input, along, 1L, TRUE, sys.call()),
# cbind = do.call(cbind, input),
min_iterations = 100,
check = FALSE # because abind adds empty dimnames
)
summary(foo)
ggplot2::autoplot(foo)
foo <- bench::mark(
abind = abind::abind(input, along = along),
bc = .internal_bind_array(input, along, 1L, TRUE, sys.call()),
cbind = do.call(cbind, input),
min_iterations = 100,
check = FALSE # because abind adds empty dimnames
)
summary(foo)
ggplot2::autoplot(foo)
