);	\\
break;	\\
}	\\
case 11:	\\
{	\\
MACRO_TYPESWITCH_NUMERIC_REL(	\\
DIMCODE,	\\
tempcalc = NA_REAL,	\\
tempcalc = ((double)px[flatind_x] - (double)py[flatind_y]),  \\
MACRO_ASSIGN_C(NA_LOGICAL), \\
MACRO_ASSIGN_C(tempcalc < prec)  \\
);	\\
break;	\\
}	\\
case 12:	\\
{	\\
MACRO_TYPESWITCH_NUMERIC_REL(	\\
DIMCODE,	\\
tempcalc = NA_REAL,	\\
tempcalc = ((double)px[flatind_x] - (double)py[flatind_y]),	\\
MACRO_ASSIGN_C(NA_LOGICAL), \\
MACRO_ASSIGN_C(tempcalc > -prec)  \\
);	\\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Boolean ====
#
macro_op_bool_math <- "
#define MACRO_OP_B_ANDOR(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                      \\
MACRO_ACTION_BOOLEAN(       \\
px[flatind_x], py[flatind_y],       \\
xFALSE || yFALSE,         \\
MACRO_ASSIGN_C(0),        \\
MACRO_ASSIGN_C(NA_LOGICAL),                                 \\
MACRO_ASSIGN_C((bool)px[flatind_x] && (bool)py[flatind_y])  \\
)                                                       \\
);                                                       \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION_BOOLEAN(                                           \\
px[flatind_x], py[flatind_y],       \\
xTRUE || yTRUE,                   \\
MACRO_ASSIGN_C(1),                                            \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((bool)px[flatind_x] || (bool)py[flatind_y])  \\
)                                                       \\
);                                                        \\
break;	\\
}	\\
case 3:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_INTEGER || py[flatind_y] == NA_INTEGER,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((bool)px[flatind_x] != (bool)py[flatind_y])  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
case 4:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION_BOOLEAN(                                           \\
px[flatind_x], py[flatind_y],       \\
xTRUE || yTRUE,                   \\
MACRO_ASSIGN_C(0),                                            \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C(!(bool)px[flatind_x] && !(bool)py[flatind_y])  \\
)                                                       \\
);                                                        \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Complex ====
#
macro_op_cplx_rel <- "
#define MACRO_OP_CPLX_REL(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_equal(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_unequal(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_cplx_math <- "
#define MACRO_OP_CPLX_MATH(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_plus(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_min(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 3:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_mult(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 4:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_div(px[flatind_x], py[flatind_y])   \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# String ====
#
macro_op_str_rel <- "
#define MACRO_OP_STR_REL(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)!R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);         \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_str_dist <- "
#define MACRO_OP_STR_DIST(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_str_dist_led(x[flatind_x], y[flatind_y])   \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_str_conc <- "
#define MACRO_OP_STR_CONC(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
out[flatind_out] = rcpp_string_plus(px[flatind_x], py[flatind_y]) \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
#
#
# ################################################################################
# # Ifelse ====
# #
#
# txt <- "
# #define MACRO_OP_IFELSE(DIMCODE) do {   \	\\
#   switch(TYPEOF(x)) {	\\
#     case LGLSXP:	\\
#     {	\\
#       const int *px = LOGICAL_RO(x);	\\
#       const int *py = LOGICAL_RO(y);	\\
#       	\\
#       SEXP out = PROTECT(Rf_allocVector(LGLSXP, nout));	\\
#       int *pout;	\\
#       pout = LOGICAL(out);	\\
#       	\\
#       MACRO_DIM_VECTOR(	\\
#         MACRO_ACTION2(	\\
#           pcond[flatind_out] == NA_LOGICAL,	\\
#           pout[flatind_out] = NA_LOGICAL,	\\
#           pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
#         )	\\
#       );	\\
#       	\\
#       UNPROTECT(1);	\\
#       return out;	\\
#       	\\
#     }	\\
#     case INTSXP:	\\
#     {	\\
#       const int *px = INTEGER_RO(x);	\\
#       const int *py = INTEGER_RO(y);	\\
#       	\\
#       SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));	\\
#       int *pout;	\\
#       pout = INTEGER(out);	\\
#       	\\
#       MACRO_DIM_VECTOR(	\\
#         MACRO_ACTION2(	\\
#           pcond[flatind_out] == NA_LOGICAL,	\\
#           pout[flatind_out] = NA_INTEGER,	\\
#           pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
#         )	\\
#       );	\\
#       	\\
#       UNPROTECT(1);	\\
#       return out;	\\
#       	\\
#     }	\\
#     case REALSXP:	\\
#     {	\\
#       const double *px = REAL_RO(x);	\\
#       const double *py = REAL_RO(y);	\\
#       	\\
#       SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));	\\
#       double *pout;	\\
#       pout = REAL(out);	\\
#       	\\
#       MACRO_DIM_VECTOR(	\\
#         MACRO_ACTION2(	\\
#           pcond[flatind_out] == NA_LOGICAL,	\\
#           pout[flatind_out] = NA_REAL,	\\
#           pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
#         )	\\
#       );	\\
#       	\\
#       UNPROTECT(1);	\\
#       return out;	\\
#       	\\
#     }	\\
#     case CPLXSXP:	\\
#     {	\\
#       const Rcomplex *px = COMPLEX_RO(x);	\\
#       const Rcomplex *py = COMPLEX_RO(y);	\\
#       	\\
#       SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));	\\
#       Rcomplex *pout;	\\
#       pout = COMPLEX(out);	\\
#       	\\
#       MACRO_DIM_VECTOR(	\\
#         MACRO_ACTION2(	\\
#           pcond[flatind_out] == NA_LOGICAL,	\\
#           pout[flatind_out] = rcpp_cplx_returnNA(),	\\
#           pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
#         )	\\
#       );	\\
#       	\\
#       UNPROTECT(1);	\\
#       return out;	\\
#       	\\
#     }	\\
#     ...string...
#     ...raw...
#     default:	\\
#     {	\\
#       stop(\"unsupported type\");	\\
#     }	\\
#   }	\\
# } while(0)
# "
################################################################################
# Save Macros ====
#
macro_op <- stri_c(
macro_assign_C,
"\n",
macro_op_num_math,
"\n",
macro_op_num_rel,
"\n",
macro_op_bool_math,
"\n",
macro_op_cplx_math,
"\n",
macro_op_cplx_rel,
"\n",
macro_op_str_conc,
"\n",
macro_op_str_rel,
"\n",
macro_op_str_dist,
"\n"
)
readr::write_file(macro_op, "macro_op.txt")
# set-up ====
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp/Lightest>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op,
"\n"
)
header_for_package <- "
#include <Rcpp/Lightest>
#include \"Broadcast.h\"
using namespace Rcpp;
"
readr::write_file(header_for_sourcing, "header.txt")
Rcpp::sourceCpp(code = header_for_sourcing)
################################################################################
# Functions ====
#
txt0 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(rcpp_str_dist_led)]]
int rcpp_str_dist_led(String x, String y) {
if(x == NA_STRING || y == NA_STRING) {
return NA_INTEGER;
}
std::string s1 = x;
std::string s2 = y;
// Number of elements
int n = s1.size();
int m = s2.size();
int nrow = n + 1;
int ncol = m + 1;
std::vector<int> d(nrow * ncol, 0);
if (n == 0){
return m;
}
if (m == 0){
return n;
}
for (int i = 0; i < nrow; i++){
d[i] = i;
}
for (int j = 1; j < ncol; j++){
d[nrow * j] = j;
}
for (int j = 1; j <= m; j++){
for (int i = 1; i <= n; i++){
if (s1[i - 1] == s2[j - 1]){
d[i + nrow * j] = d[(i - 1) + nrow * (j - 1)];  // no operation
} else {
d[i + nrow * j] = std::min(
d[(i - 1) + nrow * j] + 1,    //a deletion
std::min(
d[i + nrow * (j - 1)] + 1,   //an insertion
d[(i - 1) + nrow * (j - 1)] + 1
)
); //a substitution
} // end if
} // end inner for
} // end outer for
return d[n + nrow * m];
}
"
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bcDist_str_v)]]
SEXP rcpp_bcDist_str_v(
CharacterVector x, CharacterVector y,
R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));
int *pout;
pout = INTEGER(out);
MACRO_OP_STR_DIST(MACRO_DIM_VECTOR);
UNPROTECT(1);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bcDist_str_ov)]]
SEXP rcpp_bcDist_str_ov(
CharacterVector x, CharacterVector y,  bool RxC, SEXP out_dim,
R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));
int *pout;
pout = INTEGER(out);
MACRO_OP_STR_DIST(MACRO_DIM_ORTHOVECTOR);
UNPROTECT(1);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bcDist_str_bs)]]
SEXP rcpp_bcDist_str_bs(
CharacterVector x, CharacterVector y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, bool bigx,
int op
) {
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));
int *pout;
pout = INTEGER(out);
MACRO_OP_STR_DIST(MACRO_DIM_BIGSMALL_DOCALL);
UNPROTECT(1);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bcDist_str_d)]]
SEXP rcpp_bcDist_str_d(
CharacterVector x, CharacterVector y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));
int *pout;
pout = INTEGER(out);
MACRO_OP_STR_DIST(MACRO_DIM_DOCALL);
UNPROTECT(1);
return out;
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
txt <- stringi::stri_c(
header_for_package,
txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
readr::write_file(txt, "src/rcpp_bcDist_str.cpp")
