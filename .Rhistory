}	\\
case 3:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_mult(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 4:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_div(px[flatind_x], py[flatind_y])   \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# String ====
#
macro_op_str_rel <- "
#define MACRO_OP_STR_REL(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)!R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);         \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_str_dist <- "
#define MACRO_OP_STR_DIST(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_str_dist_led(x[flatind_x], y[flatind_y])   \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_str_conc <- "
#define MACRO_OP_STR_CONC(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
out[flatind_out] = rcpp_string_plus(x[flatind_x], y[flatind_y]) \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Ifelse ====
macro_op_ifelse <- "
#define MACRO_OP_IFELSE(DIMCODE) do {       \\
switch(TYPEOF(x)) {	\\
case LGLSXP:	\\
{	\\
const int *px = LOGICAL_RO(x);	\\
const int *py = LOGICAL_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(LGLSXP, nout));	\\
int *pout;	\\
pout = LOGICAL(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_LOGICAL,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case INTSXP:	\\
{	\\
const int *px = INTEGER_RO(x);	\\
const int *py = INTEGER_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(INTSXP, nout));	\\
int *pout;	\\
pout = INTEGER(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_INTEGER,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case REALSXP:	\\
{	\\
const double *px = REAL_RO(x);	\\
const double *py = REAL_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));	\\
double *pout;	\\
pout = REAL(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_REAL,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case CPLXSXP:	\\
{	\\
const Rcomplex *px = COMPLEX_RO(x);	\\
const Rcomplex *py = COMPLEX_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));	\\
Rcomplex *pout;	\\
pout = COMPLEX(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = rcpp_cplx_returnNA(),	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case STRSXP:	\\
{	\\
const SEXP *px = STRING_PTR_RO(x);	\\
const SEXP *py = STRING_PTR_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(STRSXP, nout));	\\
SEXP *pout;	\\
pout = STRING_PTR(out);	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
pout[flatind_out] = NA_STRING,	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case RAWSXP:	\\
{	\\
const Rbyte *px = RAW_RO(x);	\\
const Rbyte *py = RAW_RO(y);	\\
\\
SEXP out = PROTECT(Rf_allocVector(RAWSXP, nout));	\\
Rbyte *pout;	\\
pout = RAW(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = pcond[flatind_out] ? px[flatind_x] : py[flatind_y]	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
case VECSXP:	\\
{	\\
SEXP out = PROTECT(Rf_allocVector(VECSXP, nout));	\\
\\
DIMCODE(	\\
MACRO_ACTION2(	\\
pcond[flatind_out] == NA_LOGICAL,	\\
SET_VECTOR_ELT(out, flatind_out, R_NilValue),	\\
SET_VECTOR_ELT(out, flatind_out, pcond[flatind_out] ? VECTOR_ELT(x, flatind_x) : VECTOR_ELT(y, flatind_y))	\\
)	\\
);	\\
\\
UNPROTECT(1);	\\
return out;	\\
\\
}	\\
default:	\\
{	\\
stop(\"unsupported type\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# bcapply ====
macro_op_bcapply <- "
#define MACRO_OP_BCAPPLY(DIMCODE) do {       \\
switch(TYPEOF(out)) {	\\
case LGLSXP:	\\
{	\\
int *pout;	\\
pout = LOGICAL(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = LOGICAL(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case INTSXP:	\\
{	\\
int *pout;	\\
pout = INTEGER(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = INTEGER(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case REALSXP:	\\
{	\\
double *pout;	\\
pout = REAL(out);	\\
DIMCODE(	\\
pout[flatind_out] = REAL(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case CPLXSXP:	\\
{	\\
Rcomplex *pout;	\\
pout = COMPLEX(out);	\\
DIMCODE(	\\
pout[flatind_out] = COMPLEX(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case STRSXP:	\\
{	\\
SEXP out = PROTECT(Rf_allocVector(STRSXP, nout));	\\
SEXP *pout;	\\
pout = STRING_PTR(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = STRING_PTR(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case RAWSXP:	\\
{	\\
Rbyte *pout;	\\
pout = RAW(out);	\\
\\
DIMCODE(	\\
pout[flatind_out] = RAW(f(x, y, flatind_x + 1, flatind_y + 1))[0] \\
);	\\
break; \\
}	\\
case VECSXP:	\\
{	\\
DIMCODE(	\\
SET_VECTOR_ELT(out, flatind_out, f(x, y, flatind_x + 1, flatind_y + 1))	\\
);	\\
break; \\
}	\\
default:	\\
{	\\
stop(\"unsupported type\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Save Macros ====
#
macro_op <- stri_c(
macro_assign_C,
"\n",
macro_op_dec_math,
"\n",
macro_op_dec_rel,
"\n",
macro_op_int_math,
"\n",
macro_op_int_rel,
"\n",
macro_op_bool_math,
"\n",
macro_op_cplx_math,
"\n",
macro_op_cplx_rel,
"\n",
macro_op_str_conc,
"\n",
macro_op_str_rel,
"\n",
macro_op_str_dist,
"\n",
macro_op_ifelse,
"\n",
macro_op_bcapply,
"\n"
)
readr::write_file(macro_op, "macro_op.txt")
# set-up ====
library(stringi)
# dMacro_skeletons <- qs::qread("dMacro_skeletons")
# macros <- stri_c(dMacro_skeletons, collapse = "\n")
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header <- stri_c("
#ifndef BROADCAST_H
#define BROADCAST_H
",
macro_action,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op,
"\n",
macro_dim,
"
#endif
"
)
cat(header)
Rcpp::sourceCpp(code = header)
readr::write_file(header, "inst/include/broadcast.h")
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp/Lightest>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op
)
header_for_package <- "
#include <Rcpp/Lightest>
#include \"Broadcast.h\"
using namespace Rcpp;
"
readr::write_file(header_for_sourcing, "header.txt")
Rcpp::sourceCpp(code = header_for_sourcing)
txt0 <- "
inline double rcpp_int53_guard(
double out, double intmin, double intmax
) {
if(out > intmax) {
return R_PosInf;
}
if(out < intmin) {
return R_NegInf;
}
return out;
}
inline double rcpp_int53_mod(double x, double y, double intmin, double intmax) {
if(x < intmin || x > intmax || y < intmin || y > intmax) {
return NA_REAL;
}
return (long long) x % (long long) y;
}
"
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_v)]]
SEXP rcpp_bc_int_v(
SEXP x, SEXP y,
R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_VECTOR);
UNPROTECT(1);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_ov)]]
SEXP rcpp_bc_int_ov(
SEXP x, SEXP y, bool RxC, SEXP out_dim,
R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_ORTHOVECTOR);
UNPROTECT(1);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_bs)]]
SEXP rcpp_bc_int_bs(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, bool bigx,
int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_BIGSMALL_DOCALL);
UNPROTECT(1);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_int_d)]]
SEXP rcpp_bc_int_d(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
MACRO_OP_INT_MATH(MACRO_DIM_DOCALL);
UNPROTECT(1);
return out;
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
txt <- stringi::stri_c(
header_for_package,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
readr::write_file(txt, "src/rcpp_bc_int.cpp")
