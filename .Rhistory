as.raw(10)
as.raw(20)
rawToBits(as.raw(1:10)) |> lobstr::obj_size()
lobstr::obj_size(1:10)
as.raw(122)
as.raw(255)
rawToBits
pryr::show_c_source(.Internal(rawToBits(x)))
readBin(as.raw(1:10), what = integer())
intToBits(67305985)
intToBits(67305985)|> readB\
intToBits(67305985)|> readBin(integer())
intToBits(67305985)
intToBits(67305985) |> readBin(what = integer())
intToBits(67305985) |> readBin(what = double())
intToBits(67305985) |> readBin(what = "integer"
)
int\
intToBits(1L)
intToBits(1L) |> readBin(what = "integer")
intToBits(10L) |> readBin(what = "integer")
x <- 2^53 - 1L
xlog <- log10(x)
exp(logx)
xback <- exp(xlog)
log
?log
log(1)
log(2)
log(2) |> exp()
?broadcast::bc.b
2^52 - 1
2^53 - 1
15/3
as.raw(255)
as.raw(256)
Rcpp::cppFunction(
"
double gcd(
long long x, long long y
) {
long long max53 = pow(2, 53) - 1;
if(abs(x) > max53 || abs(y) > max53) {
return NA_REAL;
}
if (x == 0) {
return y;
}
if (y == 0) {
return x;
}
if (x == y) {
return x;
}
if (x > y) {
return gcd(x - y, y);
}
return gcd(x, y - x);
}
"
)
gcd(12, 15)
Rcpp::cppFunction(
"
double gcd(
double x, double y
) {
long long a = abs(x);
long long b = abs(y);
long long max53 = pow(2, 53) - 1;
if(a > max53 || b > max53) {
return NA_REAL;
}
if (a == 0) {
return b;
}
if (b == 0) {
return a;
}
if (a == b) {
return a;
}
if (a > b) {
return gcd(a - b, b);
}
return gcd(a, b - a);
}
"
)
gcd(12, 15)
gcd(-12, 15)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
.rcpp_longint_test(1,0)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# Preview documentation ====
library(broadcast)
?bc.d
?install.packages("pkgdown")
library(altdoc)
sessionInfo()
library(quarto)
sessionInfo()
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# NOTE: make sure the Quarto client is installed!
altdoc::setup_docs(tool = "quarto_website", overwrite = TRUE)
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
altdoc::preview_docs()
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
altdoc::preview_docs()
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
altdoc::preview_docs()
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
altdoc::preview_docs()
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
# NOTE: make sure the Quarto client is installed!
altdoc::setup_docs(tool = "quarto_website", overwrite = TRUE)
future::plan("multicore")
altdoc::render_docs(verbose = TRUE, parallel = TRUE, freeze = TRUE)
altdoc::preview_docs()
altdoc::preview_docs()
