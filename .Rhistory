}	\\
}	\\
} while(0)
"
################################################################################
# Complex ====
#
macro_op_cplx_rel <- "
#define MACRO_OP_CPLX_REL(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION1(                                                  \\
MACRO_ASSIGN_C(rcpp_cplx_equal(px[flatind_x], py[flatind_y]))  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION1(                                                  \\
MACRO_ASSIGN_C(rcpp_cplx_unequal(px[flatind_x], py[flatind_y]))  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_cplx_math <- "
#define MACRO_OP_CPLX_MATH(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_plus(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_min(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 3:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_mult(px[flatind_x], py[flatind_y])  \\
);                                                                \\
break;	\\
}	\\
case 4:	\\
{	\\
DIMCODE(                                                          \\
pout[flatind_out] = rcpp_cplx_div(px[flatind_x], py[flatind_y])   \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# String ====
#
macro_op_str_rel <- "
#define MACRO_OP_STR_REL(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);                                                                \\
break;	\\
}	\\
case 2:	\\
{	\\
DIMCODE(                                                          \\
MACRO_ACTION2(                                                  \\
px[flatind_x] == NA_STRING || py[flatind_y] == NA_STRING,   \\
MACRO_ASSIGN_C(NA_LOGICAL),                                   \\
MACRO_ASSIGN_C((int)!R_compute_identical(px[flatind_x], py[flatind_y], 0))  \\
)                                                       \\
);         \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
macro_op_str_conc <- "
#define MACRO_OP_STR_CONC(DIMCODE) do {	\\
switch(op) {	\\
case 1:	\\
{	\\
DIMCODE(                                                          \\
out[flatind_out] = rcpp_string_plus(px[flatind_x], py[flatind_y]) \\
);                                                                \\
break;	\\
}	\\
default:	\\
{	\\
stop(\"given operator not supported in the given context\");	\\
}	\\
}	\\
} while(0)
"
################################################################################
# Save Macros ====
#
macro_op <- stri_c(
macro_assign_C,
"\n",
macro_op_num_math,
"\n",
macro_op_num_rel,
"\n",
macro_op_bool_math,
"\n",
macro_op_cplx_math,
"\n",
macro_op_str_conc,
"\n",
macro_op_str_rel,
"\n"
)
readr::write_file(macro_op, "macro_op.txt")
# set-up ====
library(stringi)
# dMacro_skeletons <- qs::qread("dMacro_skeletons")
# macros <- stri_c(dMacro_skeletons, collapse = "\n")
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
macro_op <- readr::read_file("macro_op.txt")
header <- stri_c("
#ifndef BROADCAST_H
#define BROADCAST_H
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op,
"
#endif
"
)
cat(header)
Rcpp::sourceCpp(code = header)
readr::write_file(header, "src/broadcast.h")
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp/Lightest>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op
)
header_for_package <- "
#include <Rcpp/Lightest>
#include \"Broadcast.h\"
using namespace Rcpp;
"
readr::write_file(header_for_sourcing, "header.txt")
Rcpp::sourceCpp(code = header_for_sourcing)
txt0 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_cplx_plus)]]
Rcomplex rcpp_cplx_plus( const Rcomplex& x, const Rcomplex& y) {
Rcomplex out;
if(R_isnancpp(x.r) || R_isnancpp(x.i) || R_isnancpp(y.r) || R_isnancpp(y.i)) {
out.r = NA_REAL;
out.i = NA_REAL;
return out;
}
out.r = x.r + y.r;
out.i = x.i + y.i;
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_cplx_min)]]
Rcomplex rcpp_cplx_min( const Rcomplex& x, const Rcomplex& y) {
Rcomplex out;
if(R_isnancpp(x.r) || R_isnancpp(x.i) || R_isnancpp(y.r) || R_isnancpp(y.i)) {
out.r = NA_REAL;
out.i = NA_REAL;
return out;
}
out.r = x.r - y.r ;
out.i = x.i - y.i ;
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_cplx_mult)]]
Rcomplex rcpp_cplx_mult( const Rcomplex& x, const Rcomplex& y) {
Rcomplex out;
if(R_isnancpp(x.r) || R_isnancpp(x.i) || R_isnancpp(y.r) || R_isnancpp(y.i)) {
out.r = NA_REAL;
out.i = NA_REAL;
return out;
}
out.r = x.r * y.r - x.i * y.i;
out.i = x.r * y.i + y.r * x.i;
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_cplx_div)]]
Rcomplex rcpp_cplx_div( const Rcomplex& x, const Rcomplex& y) {
Rcomplex out;
if(R_isnancpp(x.r) || R_isnancpp(x.i) || R_isnancpp(y.r) || R_isnancpp(y.i)) {
out.r = NA_REAL;
out.i = NA_REAL;
return out;
}
double ratio, den;
double abr, abi;
if( (abr = y.r) < 0) abr = - abr;
if( (abi = y.i) < 0) abi = - abi;
if( abr <= abi ) {
ratio = y.r / y.i ;
den = y.i * (1 + ratio*ratio);
out.r = (x.r*ratio + x.i) / den;
out.i = (x.i*ratio - x.r) / den;
}
else {
ratio = y.i / y.r ;
den = y.r * (1 + ratio*ratio);
out.r = (x.r + x.i*ratio) / den;
out.i = (x.i - x.r*ratio) / den;
}
return out ;
}
"
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_cplx_v)]]
SEXP rcpp_bc_cplx_v(
SEXP x, SEXP y,
R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));
Rcomplex *pout;
pout = COMPLEX(out);
const Rcomplex *px = COMPLEX(x);
const Rcomplex *py = COMPLEX(y);
MACRO_OP_CPLX_MATH(
MACRO_DIM_VECTOR
);
UNPROTECT(1);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_cplx_ov)]]
SEXP rcpp_bc_cplx_ov(
SEXP x, SEXP y, bool RxC, SEXP out_dim,
R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));
Rcomplex *pout;
pout = COMPLEX(out);
const Rcomplex *px = COMPLEX(x);
const Rcomplex *py = COMPLEX(y);
MACRO_OP_CPLX_MATH(
MACRO_DIM_ORTHOVECTOR
);
UNPROTECT(1);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_cplx_bs)]]
SEXP rcpp_bc_cplx_bs(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, bool bigx,
int op
) {
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));
Rcomplex *pout;
pout = COMPLEX(out);
const Rcomplex *px = COMPLEX(x);
const Rcomplex *py = COMPLEX(y);
MACRO_OP_CPLX_MATH(
MACRO_DIM_BIGSMALL_DOCALL
);
UNPROTECT(1);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_cplx_d)]]
SEXP rcpp_bc_cplx_d(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, int op
) {
SEXP out = PROTECT(Rf_allocVector(CPLXSXP, nout));
Rcomplex *pout;
pout = COMPLEX(out);
const Rcomplex *px = COMPLEX(x);
const Rcomplex *py = COMPLEX(y);
MACRO_OP_CPLX_MATH(
MACRO_DIM_DOCALL
);
UNPROTECT(1);
return out;
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
txt <- stringi::stri_c(
header_for_package,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
readr::write_file(txt, "src/rcpp_bc_str.cpp")
readr::write_file(txt, "src/rcpp_bc_cplx.cpp")
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action <- readr::read_file("macro_action.txt")
header_for_sourcing <- stri_c(
"
#include <Rcpp/Lightest>
using namespace Rcpp;
",
macro_action,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
macro_op
)
header_for_package <- "
#include <Rcpp/Lightest>
#include \"Broadcast.h\"
using namespace Rcpp;
"
readr::write_file(header_for_sourcing, "header.txt")
Rcpp::sourceCpp(code = header_for_sourcing)
################################################################################
# Functions ====
#
txt0 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_string_plus)]]
String rcpp_string_plus(
String x, String y
) {
if(x == NA_STRING || y == NA_STRING) {
return(NA_STRING);
}
else {
String out = x;
out += y;
return(out);
}
}
"
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_str_v)]]
SEXP rcpp_bc_str_v(
SEXP x, SEXP y,
R_xlen_t nout, int op
) {
CharacterVector px = as<CharacterVector>(x);
CharacterVector py = as<CharacterVector>(y);
CharacterVector out(nout);
MACRO_OP_STR_CONC(
MACRO_DIM_VECTOR
);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_str_ov)]]
SEXP rcpp_bc_str_ov(
SEXP x, SEXP y, bool RxC, SEXP out_dim,
R_xlen_t nout, int op
) {
CharacterVector px = as<CharacterVector>(x);
CharacterVector py = as<CharacterVector>(y);
CharacterVector out(nout);
MACRO_OP_STR_CONC(
MACRO_DIM_ORTHOVECTOR
);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_str_bs)]]
SEXP rcpp_bc_str_bs(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, bool bigx,
int op
) {
CharacterVector px = as<CharacterVector>(x);
CharacterVector py = as<CharacterVector>(y);
CharacterVector out(nout);
MACRO_OP_STR_CONC(
MACRO_DIM_BIGSMALL_DOCALL
);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_str_d)]]
SEXP rcpp_bc_str_d(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dcp_x, SEXP dcp_y, SEXP out_dim, R_xlen_t nout, int op
) {
CharacterVector px = as<CharacterVector>(x);
CharacterVector py = as<CharacterVector>(y);
CharacterVector out(nout);
MACRO_OP_STR_CONC(
MACRO_DIM_DOCALL
);
return out;
}
"
txt <- stringi::stri_c(
header_for_sourcing,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
Rcpp::sourceCpp(code = txt)
txt <- stringi::stri_c(
header_for_package,
txt0, txt1, txt2, txt3, txt4,
collapse = "\n\n"
)
readr::write_file(txt, "src/rcpp_bc_str.cpp")
dimx <- c(10, 1, 9, 6)
dimy <- c(10, 5, 1)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing")
)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
