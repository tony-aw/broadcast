bound2[i] = Rf_length(r2);                                      \\
n2 *= bound2[i];                                                \\
subs2[i] = INTEGER(r2);                                         \\
}                                                                 \\
\\
offset1[0] = 1;                                                   \\
offset2[0] = 1;                                                   \\
for (int i = 1; i < k; i++) {                                     \\
offset1[i] = offset1[i - 1] * pxdims1[i - 1];                   \\
offset2[i] = offset2[i - 1] * pxdims2[i - 1];                   \\
}                                                                 \\
\\
\\
R_xlen_t counter = 0;                                             \\
R_xlen_t flatind_x;                                               \\
R_xlen_t flatind_y;                                               \\
\\
for (R_xlen_t i = 0; i < nout; i++) {                             \\
\\
flatind_x = 0;                                                  \\
flatind_y = 0;                                                  \\
\\
for (int j = 0; j < k; j++) {                                   \\
int jj1 = subs1[j][indx1[j]];                                 \\
flatind_x += (jj1 - 1) * offset1[j];                          \\
int jj2 = subs2[j][indx2[j]];                                 \\
flatind_y += (jj2 - 1) * offset2[j];                          \\
}                                                               \\
\\
\\
DOCODE;                                                         \\
\\
pout[counter] = tempout;                                        \\
counter++;                                                      \\
\\
int j1 = 0;                                                     \\
while (++indx1[j1] >= bound1[j1]) {                             \\
indx1[j1] = 0;                                                \\
j1 = (j1 + 1) % k;                                            \\
}                                                               \\
int j2 = 0;                                                     \\
while (++indx2[j2] >= bound2[j2]) {                             \\
indx2[j2] = 0;                                                \\
j2 = (j2 + 1) % k;                                            \\
}                                                               \\
}                                                                 \\
\\
\\
vmaxset(vmaxsave);                                                \\
\\
} while(0)
"
################################################################################
# Save macros ====
#
macro_dim <- stri_c(
macro_dim_vector,
"\n",
macro_dim_ortho_xstarts,
"\n",
macro_dim_ortho_ystarts,
"\n",
macro_dim_ortho_docall,
"\n",
macro_dim_d,
"\n",
macro_dim_docall,
"\n",
macro_dim_general
)
readr::write_file(macro_dim, "macro_dim.txt")
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
library(stringi)
macro_dim <- readr::read_file("macro_dim.txt")
macro_typeswitch_numeric <- readr::read_file("macro_typeswitch_numeric.txt")
macro_action_common <- readr::read_file("macro_action_common.txt")
macro_action_special <- readr::read_file("macro_action_special.txt")
header <- stri_c("
#include <Rcpp.h>
using namespace Rcpp;
",
"\n",
macro_action_common,
"\n",
macro_action_special,
"\n",
macro_dim,
"\n",
macro_typeswitch_numeric,
"\n",
"
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_test)]]
int rcpp_test(int x, int y) {
return (x + y);
}
"
)
cat(header)
cat(stringi::stri_replace_all(header, "", fixed = "\\") )
readr::write_file(header, "header.txt")
Rcpp::sourceCpp(code = header)
txt1 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_dbl_v)]]
SEXP rcpp_bc_dbl_v(
SEXP x, SEXP y,
R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
switch(op) {
case 1:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = (double)px[flatind_x] + (double)py[flatind_y]
);
break;
}
case 2:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = (double)px[flatind_x] - (double)py[flatind_y]
);
break;
}
case 3:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = (double)px[flatind_x] * (double)py[flatind_y]
);
break;
}
case 4:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = (double)px[flatind_x] / (double)py[flatind_y]
);
break;
}
case 5:
{
MACRO_TYPESWITCH_NUMERIC_SPECIAL(
MACRO_DIM_VECTOR,
(double)px[flatind_x] == 1 || (double)py[flatind_y] == 0,
tempout = 1,
tempout = NA_REAL,
tempout = R_pow((double)px[flatind_x], (double)py[flatind_y])
);
break;
}
case 6:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] < (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
case 7:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_VECTOR,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] > (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
default:
{
stop(\"given operator not supported in the given context\");
}
}
UNPROTECT(1);
return out;
}
"
txt2 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_dbl_o)]]
SEXP rcpp_bc_dbl_0(
SEXP x, SEXP y,
SEXP dimcumprod_x, SEXP dimcumprod_y, SEXP out_dim, R_xlen_t nout, bool xstarts,
int op
) {
double *pdcp_x = REAL(dimcumprod_x);
double *pdcp_y = REAL(dimcumprod_y);
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
switch(op) {
case 1:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] + (double)py[flatind_y]
);
break;
}
case 2:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] - (double)py[flatind_y]
);
break;
}
case 3:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] * (double)py[flatind_y]
);
break;
}
case 4:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] / (double)py[flatind_y]
);
break;
}
case 5:
{
MACRO_TYPESWITCH_NUMERIC_SPECIAL(
MACRO_DIM_ORTHO_DOCALL,
(double)px[flatind_x] == 1 || (double)py[flatind_y] == 0,
tempout = 1,
tempout = NA_REAL,
tempout = R_pow((double)px[flatind_x], (double)py[flatind_y])
);
break;
}
case 6:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] < (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
case 7:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_ORTHO_DOCALL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] > (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
default:
{
stop(\"given operator not supported in the given context\");
}
}
UNPROTECT(1);
return out;
}
"
txt3 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_dbl_d)]]
SEXP rcpp_bc_dbl_d(
SEXP x, SEXP y,
SEXP by_x,
SEXP by_y,
SEXP dimcumprod_x, SEXP dimcumprod_y, SEXP out_dim, R_xlen_t nout, int op
) {
double *pdcp_x = REAL(dimcumprod_x);
double *pdcp_y = REAL(dimcumprod_y);
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
switch(op) {
case 1:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] + (double)py[flatind_y]
);
break;
}
case 2:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] - (double)py[flatind_y]
);
break;
}
case 3:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] * (double)py[flatind_y]
);
break;
}
case 4:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] / (double)py[flatind_y]
);
break;
}
case 5:
{
MACRO_TYPESWITCH_NUMERIC_SPECIAL(
MACRO_DIM_DOCALL,
(double)px[flatind_x] == 1 || (double)py[flatind_y] == 0,
tempout = 1,
tempout = NA_REAL,
tempout = R_pow((double)px[flatind_x], (double)py[flatind_y])
);
break;
}
case 6:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] < (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
case 7:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_DOCALL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] > (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
default:
{
stop(\"given operator not supported in the given context\");
}
}
UNPROTECT(1);
return out;
}
"
txt4 <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_bc_dbl_general)]]
SEXP rcpp_bc_dbl_general(
SEXP x, SEXP y,
const SEXP s1, const SEXP s2,
const SEXP xdims1, const SEXP xdims2, const R_xlen_t nout, int op
) {
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
switch(op) {
case 1:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] + (double)py[flatind_y]
);
break;
}
case 2:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] - (double)py[flatind_y]
);
break;
}
case 3:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] * (double)py[flatind_y]
);
break;
}
case 4:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = (double)px[flatind_x] / (double)py[flatind_y]
);
break;
}
case 5:
{
MACRO_TYPESWITCH_NUMERIC_SPECIAL(
MACRO_DIM_GENERAL,
(double)px[flatind_x] == 1 || (double)py[flatind_y] == 0,
tempout = 1,
tempout = NA_REAL,
tempout = R_pow((double)px[flatind_x], (double)py[flatind_y])
);
break;
}
case 6:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] < (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
case 7:
{
MACRO_TYPESWITCH_NUMERIC_COMMON(
MACRO_DIM_GENERAL,
tempout = NA_REAL,
tempout = ((double)px[flatind_x] > (double)py[flatind_y]) ? (double)px[flatind_x] : (double)py[flatind_y]
);
break;
}
default:
{
stop(\"given operator not supported in the given context\");
}
}
UNPROTECT(1);
return out;
}
"
txt <- stringi::stri_c(header, txt1, txt2, txt3, txt4, collapse = "\n\n")
Rcpp::sourceCpp(code = txt)
readr::write_file(txt, "src/bc_dbl.cpp")
# set-up ====
setwd("D:/D Desktop/Publications/R package broadcast")
sessionInfo()
pkgs <- c("devtools", "roxygen2", "usethis", "rcmdcheck", "spelling", "tinytex",
"tinytest",
"Rcpp", "pkgdown", "tinytest")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
library(tinytest)
# install(file.path("D:/D Desktop/Publications/ImageMagick-7.1.0-62-Q16-HDRI-x64-dll"))
# tinytex::install_tinytex()
# tinytex::tlmgr_install("unfonts-extra")
# tinytex::tlmgr_install("makeindex")
# devtools::create("broadcast")
# Rcpp::Rcpp.package.skeleton("broadcast")
# set version ====
package_tarname <- "broadcast_0.0.0.9.tar.gz"
# document ====
Rcpp::compileAttributes("broadcast")
devtools::document("./broadcast")
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/inst/tinytest")
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
make_dims_starts <- function(n) {
lapply(1:n, \(i) rep(c(sample(2:10, 1L), 1L))) |> unlist()
}
make_dims_ends <- function(n) {
lapply(1:n, \(i) rep(c(1L, sample(2:10, 1L)))) |> unlist()
}
ortho <- .rcpp_bc_dbl_o
x.dim <- make_dims_starts(1L)
y.dim <- make_dims_ends(1L)
x <- array(sample(1:100), dim = x.dim)
y <- array(sample(1:100), dim = y.dim)
x.dcp <- c(1, cumprod(x.dim))
y.dcp <- c(1, cumprod(y.dim))
out.dim <- pmax(x.dim, y.dim) |> as.integer()
out.len <- prod(out.dim)
expected <- array_recycle(x, out.dim) + array_recycle(y, out.dim)
expected <- array_recycle(x, out.dim) + array_recycle(y, out.dim)
out <- ortho(x, y, x.dcp, y.dcp, out.dim, out.len, FALSE, 1L)
dim(out) <- out.dim
expect_equal(
out, expected
)
View(out)
View(expected)
