y.dim[along] <- sample(1:10, 1)
z.dim[along] <- sample(1:10, 1)
x.data <- datagens[[iDataX]]()
y.data <- datagens[[iDataY]]()
z.data <- datagens[[iDataZ]]()
x <- array(x.data, c(1, x.dim[2])) |> array_recycle(x.dim)
y <- array(y.data, c(1, y.dim[2:3])) |> array_recycle(y.dim)
z <- array(z.data, z.dim)
emptyarray <- array(numeric(0L), c(3,3,0))
# make expected array:
expected.dim <- x.dim
expected.dim[along] <- x.dim[along] + y.dim[along] + z.dim[along]
expected.type <- c(x.data, y.data, z.data) |> typeof()
expected <- vector(expected.type, prod(expected.dim))
dim(expected) <- expected.dim
start <- 1
end <- x.dim[along]
expected[, start:end, ] <- x
start <- start + x.dim[along]
end <- end + y.dim[along]
expected[, start:end, ] <- y
start <- start + y.dim[along]
end <- end + z.dim[along]
expected[, start:end, ] <- z
# test:
random <- sample(1:3, 1L)
if(random == 1L) {
input <- list(emptyarray, x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], z)
}
else if(random == 2L) {
input <- list(x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], z, emptyarray)
}
else if(random == 3L) {
input <- list(emptyarray, x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], emptyarray, z)
}
expected.lst[[counter]] <- expected
out.lst[[counter]] <- bind_array(input, along, max_bc = 2L)
expect_equal(
expected, bind_array(input, along, max_bc = 2L)
) |> errorfun()
counter <- counter + 1L
}
}
}
}
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dims <- function(n) {
# make dimensions that are randomly of size 1 or 3:
out <- lapply(1:n, \(n)sample(c(1, 3), 1)) |> unlist()
# check if the dimensions produce a too large object.
# If so, replace one >1L dimension with 1L
if(prod(out) > 5000L) {
ind <- which(out > 1L)[1L]
out[ind] <- 1L
}
return(out)
}
datagens <- list(
# \() as.raw(sample(1:10)), # ifelse() cannot handle raw, apparently
\() sample(c(TRUE, FALSE, NA), 10L, TRUE),
\() sample(c(-10L:10L, NA_integer_)),
\() sample(c(rnorm(10), NA, NaN, Inf, -Inf)),
\() sample(c(rnorm(10), NA, NaN, Inf, -Inf)) + sample(c(rnorm(10), NA, NaN, Inf, -Inf)) * -1i,
\() sample(c(letters, NA)),
\() sample(list(letters, month.abb, 1:10))
)
along <- 2L
counter <- 1L
expected.lst <- out.lst <- vector("list", 5 * length(datagens)^3)
nDims <- 3L
for(iSample in 1:5) {
for(iDataX in seq_along(datagens)) {
for(iDataY in seq_along(datagens)) {
for(iDataZ in seq_along(datagens)) {
# make input:
x.dim <- y.dim <- z.dim <- test_make_dims(nDims)
x.dim <- x.dim
y.dim <- y.dim
x.dim[along] <- sample(1:10, 1)
y.dim[along] <- sample(1:10, 1)
z.dim[along] <- sample(1:10, 1)
x.data <- datagens[[iDataX]]()
y.data <- datagens[[iDataY]]()
z.data <- datagens[[iDataZ]]()
# here there's colbinding, so keep object.dim[2] intact
x <- array(x.data, c(1, x.dim[2])) |> array_recycle(x.dim)
y <- array(y.data, c(1, y.dim[2:3])) |> array_recycle(y.dim)
z <- array(z.data, z.dim)
emptyarray <- array(numeric(0L), c(3,3,0))
# make expected array:
expected.dim <- x.dim
expected.dim[along] <- x.dim[along] + y.dim[along] + z.dim[along]
expected.type <- c(x.data, y.data, z.data) |> typeof()
expected <- vector(expected.type, prod(expected.dim))
dim(expected) <- expected.dim
start <- 1
end <- x.dim[along]
expected[, start:end, ] <- x
start <- start + x.dim[along]
end <- end + y.dim[along]
expected[, start:end, ] <- y
start <- start + y.dim[along]
end <- end + z.dim[along]
expected[, start:end, ] <- z
# test:
random <- sample(1:3, 1L)
if(random == 1L) {
input <- list(emptyarray, x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], z)
}
else if(random == 2L) {
input <- list(x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], z, emptyarray)
}
else if(random == 3L) {
input <- list(emptyarray, x[1, , 1, drop=FALSE], y[1,,, drop=FALSE], emptyarray, z)
}
expected.lst[[counter]] <- expected
out.lst[[counter]] <- bind_array(input, along, max_bc = 2L)
counter <- counter + 1L
}
}
}
}
expect_equal(
out.lst, expected.lst
)
enumerate <- enumerate + length(out.lst)
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dimnames <- function(x.dim) {
out <- lapply(x.dim, \(n)sample(letters, n, replace = TRUE))
return(out)
}
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 10)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z)
View(expected)
expected <- cbind(x, y, z) |> unname()
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z)
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z)
I=1
I=1
EXPECTED
expected
expected <- cbind(x, y, z) |> unname()
dimnames(expected)[1L] <- dimnames(input[[i]])[2L]
expected
dimnames(input[[i]])[2L]
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expected
i
i=1
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expected
input[[i]]
i=2
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expected
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
enumerate <- enumerate + 1L
}
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- rbind(x, y, z) |> unname()
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
expect_equal(
bind_array(input, 1L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
enumerate <- enumerate + 1L
}
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
enumerate <- enumerate + 1L
}
bind_array(input, 2L, name_along = FALSE, comnames_from = i)
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
# test name_along, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
names(input) <- letters[1:4]
expected <- cbind(x, y, z) |> unname()
colnames(expected) <- c(colnames(x), paste0("c.", 1:5), colnames(z))
expect_equal(
bind_array(input, 2L, name_along = TRUE, comnames_from = NULL),
expected
)
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dimnames <- function(x.dim) {
out <- lapply(x.dim, \(n)sample(letters, n, replace = TRUE))
return(out)
}
# note: for safety, test one naming argument at a time. Not multiple simultaneously
################################################################################
# test comnames, 1d ====
x <- array(rnorm(5), 5, list(sample(letters, 5)))
y <- array(rnorm(5), 5, list(sample(letters, 5)))
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y, z) |> unname()
for(i in 1:4) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
# test name_along, 1d ====
x <- array(rnorm(10), 10, list(sample(letters, 10)))
y <- array(rnorm(5), 5)
z <- array(rnorm(5), 5, list(sample(letters, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
names(input) <- letters[1:4]
expected <- c(x, y, z)
dim(expected) <- length(expected)
names(expected) <- c(names(x), paste0("c.", 1:5), names(z))
expect_equal(
bind_array(input, 1L, name_along = TRUE, comnames_from = NULL),
expected
)
enumerate <- enumerate + 1L
# test name_along, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(5, 5))
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
names(input) <- letters[1:4]
expected <- cbind(x, y, z) |> unname()
colnames(expected) <- c(colnames(x), paste0("c.", 1:5), colnames(z))
expect_equal(
bind_array(input, 2L, name_along = TRUE, comnames_from = NULL),
expected
)
enumerate <- enumerate + 1L
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(1, 5), test_make_dimnames(c(1, 5))) # will be broadcasted
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y[rep(1L, 5L),], z) |> unname()
for(i in c(1, 2, 4)) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
i = 3
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
enumerate <- enumerate + 1L
# test name_along, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(1, 5), test_make_dimnames(c(1, 5))) # will be broadcasted
z <- array(rnorm(5), c(5, 5)) # no names
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
names(input) <- letters[1:4]
expected <- cbind(x, y[rep(1L, 5L),], z) |> unname()
colnames(expected) <- c(colnames(x), colnames(y), paste0("d.", 1:5))
expect_equal(
bind_array(input, 1L, name_along = TRUE, comnames_from = NULL),
expected
)
expect_equal(
bind_array(input, 2L, name_along = TRUE, comnames_from = NULL),
expected
)
enumerate <- enumerate + 1L
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dimnames <- function(x.dim) {
out <- lapply(x.dim, \(n)sample(letters, n, replace = TRUE))
return(out)
}
# note: for safety, test one nameing argument at a time. Not multiple simultaneously
################################################################################
# test comnames, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(1, 5), test_make_dimnames(c(1, 5))) # will be broadcasted
z <- array(rnorm(5), c(5, 5), test_make_dimnames(c(5, 5)))
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
expected <- cbind(x, y[rep(1L, 5L),], z) |> unname()
for(i in c(1, 2, 4)) {
dimnames(expected)[1L] <- dimnames(input[[i]])[1L]
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
expected <- unname(expected)
enumerate <- enumerate + 1L
}
i = 3
expect_equal(
bind_array(input, 2L, name_along = FALSE, comnames_from = i),
expected
) |> errorfun()
enumerate <- enumerate + 1L
# test name_along, 2d ====
x <- array(rnorm(10), c(5, 10), test_make_dimnames(c(5, 10)))
y <- array(rnorm(5), c(1, 5), test_make_dimnames(c(1, 5))) # will be broadcasted
z <- array(rnorm(5), c(5, 5)) # no names
emptyarray <- array(rnorm(0), c(5, 5, 0))
input <- list(emptyarray, x, y, z)
names(input) <- letters[1:4]
expected <- cbind(x, y[rep(1L, 5L),], z) |> unname()
colnames(expected) <- c(colnames(x), colnames(y), paste0("d.", 1:5))
expect_equal(
bind_array(input, 2L, name_along = TRUE, comnames_from = NULL),
expected
)
enumerate <- enumerate + 1L
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/inst/tinytest/count")
# count number of tests
library(broadcast)
library(tinytest)
# set working directory to source file location
SourceFileLocation <- function() {
# BATCH way:
path <- funr::get_script_path()
if(!is.null(path)) return(path)
# R-Studio way:
if(Sys.getenv("RSTUDIO") == "1") {
if(rstudioapi::isAvailable(version_needed = NULL,child_ok = FALSE)) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
}
if(is.null(knitr::current_input(dir = TRUE)) == FALSE) {
return(knitr::current_input(dir = TRUE))
}
return(getwd())
}
}
enumerate_total <- 0
wd <- SourceFileLocation()
setwd(wd)
setwd("..")
getwd()
files <- list.files(normalizePath(getwd()), pattern = ".R", full.names = TRUE)
max.width <- max(stringi::stri_width(basename(files))) + 8
for(iFile in files) {
capture.output(source(normalizePath(iFile)), file = nullfile()) |> suppressMessages()
cat(stringi::stri_pad_right(basename(iFile), max.width), " -> ", enumerate,  "\n")
enumerate_total <- enumerate_total + enumerate
}
rem <-  setdiff(ls(), c("SourceFileLocation", "enumerate", "enumerate_total"))
rm(list = rem)
subfolders <- c(
"bind_array", "bc_num", "bc_b", "bc_cplx", "bc_str", "bc_list", "bc_generic",
"internal"
)
wd <- SourceFileLocation()
setwd(wd)
setwd("..")
path <- file.path(getwd(), subfolders) |> normalizePath()
files <- list.files(path, pattern = "*.R", full.names = TRUE)
max.width <- max(stringi::stri_width(basename(files))) + 8
for(iSubFolder in subfolders) {
wd <- SourceFileLocation()
setwd(wd)
setwd("..")
setwd(normalizePath(iSubFolder))
getwd()
files <- list.files(normalizePath(getwd()), pattern = ".R", full.names = TRUE)
print(iSubFolder)
for(iFile in files) {
capture.output(source(normalizePath(iFile)), file = nullfile()) |> suppressMessages()
cat(stringi::stri_pad_right(basename(iFile), max.width), " -> ", enumerate,  "\n")
enumerate_total <- enumerate_total + enumerate
}
rem <-  setdiff(ls(), c("SourceFileLocation", "enumerate", "enumerate_total", "max.width"))
rm(list = rem)
cat("\n")
}
print(enumerate_total)
