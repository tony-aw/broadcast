<!DOCTYPE html><html><head><title>R: Details on the Binding Implementations in 'broadcast'</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>aaa01_broadcast_bind</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Details on the Binding Implementations in 'broadcast'</h2>

<h3>Description</h3>

<p>This help page gives additional details on the binding implementations in the 'broadcast' package. <br />
<br />
</p>


<h3>Empty inputs</h3>

<p>If argument <code>input</code> has length <code>0</code>,
or it contains exclusively objects where one or more dimensions are <code>0</code>,
an error is returned. <br />
<br />
If <code>input</code> has length <code>1</code>, these functions simply return <code>input[[1L]]</code>. <br />
<br />
</p>


<h3>Differences with <code>abind()</code>, <code>rbind()</code>/<code>cbind()</code></h3>

<p>The API of <code>bind_array()</code> is inspired by the fantastic
<code>abind::abind</code> function
by Tony Plare &amp; Richard Heiberger (2016). <br />
But <code>bind_array()</code> differs considerably from <code>abind::abind</code>
in the following ways:
</p>

<ul>
<li> <p><code>bind_array()</code> differs from <code>abind::abind</code>
in that it can handle recursive arrays properly <br />
(the <code>abind::abind</code> function would unlist everything to atomic arrays,
ruining the structure).
</p>
</li>
<li> <p><code>bind_array()</code> allows for broadcasting,
while <code>abind::abind</code> does not support broadcasting.
</p>
</li>
<li> <p><code>bind_array()</code> is generally faster than <code>abind::abind</code>,
as <code>bind_array()</code> relies heavily on 'C' and 'C++' code.
</p>
</li>
<li><p> unlike <code>abind::abind</code>,
<code>bind_array()</code> only binds (atomic/recursive) arrays and matrices. <br />
<code>bind_array()</code>does not attempt to convert things to arrays when they are not arrays,
but will give an error instead. <br />
This saves computation time and prevents unexpected results.
</p>
</li>
<li> <p><code>bind_array()</code> has more streamlined naming options,
compared to <code>abind::abind</code>. <br /> <br />
</p>
</li></ul>

<p><code>bind_mat()</code> is a modified version of base R's <code>rbind()</code>/<code>cbind()</code> functions. <br />
<code>bind_mat()</code> differs from <code>rbind()</code>/<code>cbind()</code> in the following ways:
</p>

<ul>
<li><p> it has more streamlined naming options/
</p>
</li>
<li> <p><code>bind_mat()</code> gives an error when fractional recycling is attempted
(like binding  <code>1:3</code> with <code>1:10</code>). <br /> <br />
</p>
</li></ul>


</main>

</div>
</body></html>
