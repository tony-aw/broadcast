{"title":"Broadcasting Explained","markdown":{"yaml":{"title":"Broadcasting Explained","format":{"html":{"number-sections":true}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup, eval=TRUE, echo=FALSE}\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\nlibrary(broadcast)\nlibrary(kableExtra) |> suppressWarnings()\n```\n\n\n&nbsp;\n\n\nIn the context of operations involving 2 (or more) arrays, \"broadcasting\" refers to recycling array dimensions **without** allocating additional memory or making needles copies. This is considerably **faster** and **more memory-efficient** than R's regular dimensions repetition (and similar) mechanisms, such as the mechanism utilized inside the `outer()` function.\n\nThis article explains the concept of \"broadcasting\" in more detail.\nA good understanding of atomic and recursive arrays in base 'R' is somewhat essential to follow this article.\n\n&nbsp;\n\n# What is broadcasting and why is it needed?\n\n## Example case\n\nLet's start with a simple example.  \nConsider the column vector `x` and the row vector `y`:\n\n```{r}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\nprint(x)\nprint(y)\n```\n\nSuppose one wishes to compute the outer sum of these 2 vectors.  \n\nThis won't work in base 'R':\n\n```{r eval=FALSE, echo=TRUE}\nx + y\nError in x + y : non-conformable arrays\n```\n\n\nWhen computing the outer sum of these vectors, both vectors need to be recycled to equal size in order to compute the outer computation.  \nI.e. `x` needs its single column to be recycled (in this case) 5 times, and `y` needs its single row to be recycled 5 times, creating 2 conformable matrices.  \n\n'R' provides linear **vector** recycling, but not recycling of array dimensions. Instead, in base 'R' we need to **replicate** (and thus **copy**) the array dimensions. This can be done manually, or using `outer() |> drop()`:\n\n```{r}\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n\nouter(x, y, \"+\") |> drop()\n```\n\n&nbsp;\n\n## What is the problem?\n\nWhen `x` and `y` are small arrays, like in the above example, there is hardly a problem; but when `x` and `y` become larger, the 3 matrices (`x` is replicated to a matrix, `y` is replicated to a matrix, and the result is also matrix) also become larger.\n\nIf the 3 matrices become too large, you may require more memory than is available in your current system, resulting in a message like the following:\n\n```{r eval=FALSE, echo=TRUE}\n> Error: cannot allocate vector of size\n```\n\n\nThe problem isn't limited to available memory. As the object sizes increase, the speed decreases. And let's not forget that computational inefficiency in general is also bad for the environment.\n\n&nbsp;\n\n## Introducing Broadcasting\n\nIn an operation like `outer(x, y, \"+\")`, `x` and `y` are replicated to become the same size. The thing is, physical replication - and thus copying - of the dimensions of `x` and `y` should not be necessary; they only need to be recycled virtually.  \n\nVirtual recycling does not actually physically replicate `x` and `y`. Instead, nested loops in 'C' and 'C++' are used to simulate a recycled array.  \nThis is similar to how 'R' recycles regular (i.e. dimensionless) vectors.  \nVirtual recycling requires no additional memory (apart from allocating the final end result); it is much faster and much more memory efficient than using the `outer()` function or something similar.\n\nAnd **that** is what broadcasting does: broadcasting provides **fast** virtual recycling of array dimensions in the context of operations involving 2 (or more) arrays **without** allocating additional memory.\n\nIn the earlier example, we used:\n\n```{r}\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n\nouter(x, y, \"+\") |> drop()\n```\n\nTo compute the outer sum using broadcasting through the 'broadcast' package, we can do the following:\n\n```{r}\nlibrary(broadcast)\n\nbc.num(x, y, \"+\")\n\n```\n\nThe result is the same (as it should). But as the size of the resulting array increases, the broadcasted functions become more and more efficient in terms of both speed and memory, in comparison with base 'R' approaches.  \n\nBenchmarks can be found on the website.\n\n&nbsp;\n\n# Illustrating Broadcasting\n\nIn the previous example 2 orthogonal vectors were created:\n\n```{r}\nprint(x)\nprint(y)\n```\n\n\nComputing the broadcasted outer sum of `x` and `y` produced the following:\n\n```{r}\nbc.num(x, y, \"+\")\n```\n\n\nSo what exactly does broadcasting compute here?\n\nThe following table illustrates what broadcasting does, conceptually:\n\n```{r eval=TRUE, echo=FALSE}\n\n\nfoo <- cbind(\n  sprintf(\"x[%d] + y[%d]\", 1:5, 1),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 2),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 3),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 4),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 5)\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)\n\n```\n\n\nThis is an example of a simple outer operation of 2 orthogonal vectors. But broadcasting provided by the 'broadcast' package is not limited to only those kinds of arrays.\n\nAny 2 arrays with each no more than 16 dimensions are supported. And any number of dimensions can be broadcasted simultaneously.\n\n&nbsp;\n\nLet's broadcast a vector with a matrix.\n\nConsider the following column vector:\n\n```{r}\nx <- array(1:5 * 10, dim = c(5,1))\nprint(x)\n```\n\nAnd the following matrix:\n\n```{r}\ny <- matrix(1:20, 5, 4)\nprint(y)\n```\n\nLet's see what happens if we sum them together using broadcasting:\n\n```{r}\nbc.num(x, y, \"+\")\n```\n\nWhat happens here is that `y` remains the same, but column vector `x` is **virtually** recycled 4 times, but without requiring 4 times more memory. This is also be illustrated in the following table:\n\n```{r eval=TRUE, echo=FALSE}\n\n\nfoo <- cbind(\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 1),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 2),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 3),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 4)\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\n\n&nbsp;\n\n# Broadcasting limitations and rules\n\nThe previous section used the examples of a simple outer operation with 1d arrays and matrices, as they are easier to display on a flat screen then 3d-arrays.   \nBut broadcasting provided by the 'broadcast' package is not limited to only those kinds of arrays.\n\nAny 2 arrays with each no more than 16 dimensions are supported. And any number of dimensions can be broadcasted simultaneously.\n\n&nbsp;\n\n## Conformability\n\nBroadcasted operations only work when 2 arrays are conformable for broadcasting.  \n\nConsider again 2 arrays `x` and `y`, and their dimensions given by `dim(x)` and `dim(y)`, respectively.  \n'broadcast' goes through `dim(x)` and `dim(y)`, from left (i.e. first dimension / rows) to right (i.e. the last dimension), and checks for each axis `i` if **at least one** of the following conditions is TRUE:\n\n - `dim(x)[i]` and `dim(y)[i]` are equal;\n - either `dim(x)[i]` or `dim(y)[i]` is `1`;\n - either `dim(x)[i]` or `dim(y)[i]` is non-existing.\n \nif at least one of the above conditions is true for each and every one of the dimensions of `x` and `y`, the 2 arrays are compatible for broadcasted operations. If not, they are not compatible, and attempting to perform a broadcasted operations results in an error.\n\n\nTo illustrate, let's check 2 arrays to see if they are compatible:\n\n```{r echo = TRUE, eval = TRUE}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 1))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  compatible = rep(TRUE, 4),\n  reason = c(\"equal\", \"either is 1\", \"either is 1\", \"either is missing\"),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\nAs shown in the data.frame above, all dimensions of `x` and `y` are compatible.  \nTherefore, broadcasted binary operations involving `x` and `y` can be performed.\n\n&nbsp;\n\nNow let's look at another 2 arrays, and see if they are compatible:\n\n\n```{r echo = TRUE, eval=TRUE}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 2))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  compatible = c(TRUE, TRUE, FALSE, TRUE),\n  reason = c(\"equal\", \"either is 1\", \"not equal & neither is 1/missing\", \"either is missing\"),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\nOne of the dimensions, namely the third dimension, is not compatible. Therefore, these 2 arrays are **not** conformable for broadcasted operations.\n\n&nbsp;\n\n## Which dimensions are broadcasted\n\nIn the context of an operation involving exactly 2 arrays, this sub-section explains which dimensions of which array is broadcasted, and which dimension of which array is left as-is.  \nThere are 3 scenarios relevant for this explanation.\n\n&nbsp;\n\n**Scenario 1:**  \nFor some dimension `i`, `dim(x)[i]` and `dim(y)[i]` are equal.  \nIn this scenario, no broadcasting needs to occur on that dimension for either array.\n\n&nbsp;\n\n\n**Scenario 2:**  \nFor some dimension `i`, suppose `dim(x)[i] == 1` and `dim(y)[i] > 1`.  \nThen dimension `dim(x)[i]` is **broadcasted** to size `dim(y)[i]`.  \nSimilarly, if `dim(x)[i] > 1` and `dim(y)[i] == 1`, dimension `dim(y)[i]` is **broadcasted** to size `dim(x)[i]`.\n\n&nbsp;\n\n\n**Scenario 3:**  \nFinally, suppose for some dimension `i`, `dim(x)[i] > 1`, and `dim(y)[i]` is non-existing.  \nI.e., `x` has more dimensions than `y`.  \nIn this case, the missing dimension in `y` is replaced with a dimensions of size `1`, and scenario 2 is used.  \nSimilarly, if `dim(y)[i] > 1` and `dim(x)[i]` is non-existing, the missing dimension in `x` is replaced with a dimension of size `1` and we get back to scenario 2.  \n\nIt does not matter how much difference there is between the number of dimensions of `x` and the number of dimensions of `y`: any number of missing dimensions will be replaced with `1`, as long as the total number of dimensions for each array does not exceed `16`.\n\n&nbsp;\n\n**Illustration**\n\nTo illustrate, let's check 2 conformable arrays, and see which dimension of which array is broadcasted by how much\n\n```{r echo = TRUE, eval = TRUE}\nx <- array(rnorm(10), c(10, 1, 1, 9, 6))\ny <- array(rnorm(10), c(10, 1, 5, 1))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  i = 1:length(dimx),\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  broadcasted = c(\"neither\", \"neither\", \"x\", \"y\", \"y\"),\n  reason = c(\n    \"dims equal\", \"dims equal\",\n    \"dim(x)[i] == 1\", \"dim(y)[i] == 1\",\n    \"dim(y)[i] is missing\"\n  ),\n  note = c(\n    rep(\"\", 2),\n    \"dim(x)[i] recycled to size 5\",\n    \"dim(y)[i] recycled to size 9\",\n    \"dim(y) extended with a 1; dim(y)[i] recycled to size 6\"\n  ),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:6, border_left = TRUE, border_right = TRUE)\n\n```\n\n\n&nbsp;\n\n# Dimensionless Vectors\n\nThe functions in 'broadcast' treat dimensionless vectors are treated as 1-dimensional column-vectors. This is analogous to standard linear algebraic convention, where an vector of unspecified orientation is taken to be a column-vector.\n\nI.e. `1:10` is the same as `array(1:10, dim = c(10))`.\n\n&nbsp;\n\n# Orthogonal Arrays\n\nIn the documentation of 'broadcast', the reader may come across the term \"orthogonal arrays\" here and there.  \n\"orthogonal\" is a term that can mean a great many things; this section therefore explains what \"orthogonal\" means in the context of broadcasting.\n\nConsider a column-vector `x` and row-vector `y`:\n\n```{r}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\nprint(x)\nprint(y)\n```\n\nThese vectors are (in a very literal sense) perpendicular to each other, and thus in that sense orthogonal to each other.  \nThis type of orthogonality can be extended to arrays as follows.  \nFor the purposes of broadcasting, any pair of arrays, `x` and `y`, can be referred to as being \"orthogonal\" if **all** of the following holds for that pair of arrays:  \n\n - For **every** dimension index `i`, `dim(x)[i] != dim(y)[i]`\n - For **every** dimensions index `i`,`dim(x)[i]` is `1` or missing, **OR** `dim(y)[i]` is `1` or missing.\n\n\nFor example, the following 2 arrays are orthogonal:\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(1, 9, 1, 9, 1, 11))\n\n```\n\nAnd the following 2 arrays are not orthogonal:\n\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(10, 9, 1, 9, 10))\n\n```\n\n\n&nbsp;\n&nbsp;\n","srcMarkdownNoYaml":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup, eval=TRUE, echo=FALSE}\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\nlibrary(broadcast)\nlibrary(kableExtra) |> suppressWarnings()\n```\n\n\n&nbsp;\n\n# Introduction\n\nIn the context of operations involving 2 (or more) arrays, \"broadcasting\" refers to recycling array dimensions **without** allocating additional memory or making needles copies. This is considerably **faster** and **more memory-efficient** than R's regular dimensions repetition (and similar) mechanisms, such as the mechanism utilized inside the `outer()` function.\n\nThis article explains the concept of \"broadcasting\" in more detail.\nA good understanding of atomic and recursive arrays in base 'R' is somewhat essential to follow this article.\n\n&nbsp;\n\n# What is broadcasting and why is it needed?\n\n## Example case\n\nLet's start with a simple example.  \nConsider the column vector `x` and the row vector `y`:\n\n```{r}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\nprint(x)\nprint(y)\n```\n\nSuppose one wishes to compute the outer sum of these 2 vectors.  \n\nThis won't work in base 'R':\n\n```{r eval=FALSE, echo=TRUE}\nx + y\nError in x + y : non-conformable arrays\n```\n\n\nWhen computing the outer sum of these vectors, both vectors need to be recycled to equal size in order to compute the outer computation.  \nI.e. `x` needs its single column to be recycled (in this case) 5 times, and `y` needs its single row to be recycled 5 times, creating 2 conformable matrices.  \n\n'R' provides linear **vector** recycling, but not recycling of array dimensions. Instead, in base 'R' we need to **replicate** (and thus **copy**) the array dimensions. This can be done manually, or using `outer() |> drop()`:\n\n```{r}\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n\nouter(x, y, \"+\") |> drop()\n```\n\n&nbsp;\n\n## What is the problem?\n\nWhen `x` and `y` are small arrays, like in the above example, there is hardly a problem; but when `x` and `y` become larger, the 3 matrices (`x` is replicated to a matrix, `y` is replicated to a matrix, and the result is also matrix) also become larger.\n\nIf the 3 matrices become too large, you may require more memory than is available in your current system, resulting in a message like the following:\n\n```{r eval=FALSE, echo=TRUE}\n> Error: cannot allocate vector of size\n```\n\n\nThe problem isn't limited to available memory. As the object sizes increase, the speed decreases. And let's not forget that computational inefficiency in general is also bad for the environment.\n\n&nbsp;\n\n## Introducing Broadcasting\n\nIn an operation like `outer(x, y, \"+\")`, `x` and `y` are replicated to become the same size. The thing is, physical replication - and thus copying - of the dimensions of `x` and `y` should not be necessary; they only need to be recycled virtually.  \n\nVirtual recycling does not actually physically replicate `x` and `y`. Instead, nested loops in 'C' and 'C++' are used to simulate a recycled array.  \nThis is similar to how 'R' recycles regular (i.e. dimensionless) vectors.  \nVirtual recycling requires no additional memory (apart from allocating the final end result); it is much faster and much more memory efficient than using the `outer()` function or something similar.\n\nAnd **that** is what broadcasting does: broadcasting provides **fast** virtual recycling of array dimensions in the context of operations involving 2 (or more) arrays **without** allocating additional memory.\n\nIn the earlier example, we used:\n\n```{r}\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n\nouter(x, y, \"+\") |> drop()\n```\n\nTo compute the outer sum using broadcasting through the 'broadcast' package, we can do the following:\n\n```{r}\nlibrary(broadcast)\n\nbc.num(x, y, \"+\")\n\n```\n\nThe result is the same (as it should). But as the size of the resulting array increases, the broadcasted functions become more and more efficient in terms of both speed and memory, in comparison with base 'R' approaches.  \n\nBenchmarks can be found on the website.\n\n&nbsp;\n\n# Illustrating Broadcasting\n\nIn the previous example 2 orthogonal vectors were created:\n\n```{r}\nprint(x)\nprint(y)\n```\n\n\nComputing the broadcasted outer sum of `x` and `y` produced the following:\n\n```{r}\nbc.num(x, y, \"+\")\n```\n\n\nSo what exactly does broadcasting compute here?\n\nThe following table illustrates what broadcasting does, conceptually:\n\n```{r eval=TRUE, echo=FALSE}\n\n\nfoo <- cbind(\n  sprintf(\"x[%d] + y[%d]\", 1:5, 1),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 2),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 3),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 4),\n  sprintf(\"x[%d] + y[%d]\", 1:5, 5)\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)\n\n```\n\n\nThis is an example of a simple outer operation of 2 orthogonal vectors. But broadcasting provided by the 'broadcast' package is not limited to only those kinds of arrays.\n\nAny 2 arrays with each no more than 16 dimensions are supported. And any number of dimensions can be broadcasted simultaneously.\n\n&nbsp;\n\nLet's broadcast a vector with a matrix.\n\nConsider the following column vector:\n\n```{r}\nx <- array(1:5 * 10, dim = c(5,1))\nprint(x)\n```\n\nAnd the following matrix:\n\n```{r}\ny <- matrix(1:20, 5, 4)\nprint(y)\n```\n\nLet's see what happens if we sum them together using broadcasting:\n\n```{r}\nbc.num(x, y, \"+\")\n```\n\nWhat happens here is that `y` remains the same, but column vector `x` is **virtually** recycled 4 times, but without requiring 4 times more memory. This is also be illustrated in the following table:\n\n```{r eval=TRUE, echo=FALSE}\n\n\nfoo <- cbind(\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 1),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 2),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 3),\n  sprintf(\"x[%d] + y[%d, %d]\", 1:5, 1:5, 4)\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\n\n&nbsp;\n\n# Broadcasting limitations and rules\n\nThe previous section used the examples of a simple outer operation with 1d arrays and matrices, as they are easier to display on a flat screen then 3d-arrays.   \nBut broadcasting provided by the 'broadcast' package is not limited to only those kinds of arrays.\n\nAny 2 arrays with each no more than 16 dimensions are supported. And any number of dimensions can be broadcasted simultaneously.\n\n&nbsp;\n\n## Conformability\n\nBroadcasted operations only work when 2 arrays are conformable for broadcasting.  \n\nConsider again 2 arrays `x` and `y`, and their dimensions given by `dim(x)` and `dim(y)`, respectively.  \n'broadcast' goes through `dim(x)` and `dim(y)`, from left (i.e. first dimension / rows) to right (i.e. the last dimension), and checks for each axis `i` if **at least one** of the following conditions is TRUE:\n\n - `dim(x)[i]` and `dim(y)[i]` are equal;\n - either `dim(x)[i]` or `dim(y)[i]` is `1`;\n - either `dim(x)[i]` or `dim(y)[i]` is non-existing.\n \nif at least one of the above conditions is true for each and every one of the dimensions of `x` and `y`, the 2 arrays are compatible for broadcasted operations. If not, they are not compatible, and attempting to perform a broadcasted operations results in an error.\n\n\nTo illustrate, let's check 2 arrays to see if they are compatible:\n\n```{r echo = TRUE, eval = TRUE}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 1))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  compatible = rep(TRUE, 4),\n  reason = c(\"equal\", \"either is 1\", \"either is 1\", \"either is missing\"),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\nAs shown in the data.frame above, all dimensions of `x` and `y` are compatible.  \nTherefore, broadcasted binary operations involving `x` and `y` can be performed.\n\n&nbsp;\n\nNow let's look at another 2 arrays, and see if they are compatible:\n\n\n```{r echo = TRUE, eval=TRUE}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 2))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  compatible = c(TRUE, TRUE, FALSE, TRUE),\n  reason = c(\"equal\", \"either is 1\", \"not equal & neither is 1/missing\", \"either is missing\"),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:4, border_left = TRUE, border_right = TRUE)\n\n```\n\nOne of the dimensions, namely the third dimension, is not compatible. Therefore, these 2 arrays are **not** conformable for broadcasted operations.\n\n&nbsp;\n\n## Which dimensions are broadcasted\n\nIn the context of an operation involving exactly 2 arrays, this sub-section explains which dimensions of which array is broadcasted, and which dimension of which array is left as-is.  \nThere are 3 scenarios relevant for this explanation.\n\n&nbsp;\n\n**Scenario 1:**  \nFor some dimension `i`, `dim(x)[i]` and `dim(y)[i]` are equal.  \nIn this scenario, no broadcasting needs to occur on that dimension for either array.\n\n&nbsp;\n\n\n**Scenario 2:**  \nFor some dimension `i`, suppose `dim(x)[i] == 1` and `dim(y)[i] > 1`.  \nThen dimension `dim(x)[i]` is **broadcasted** to size `dim(y)[i]`.  \nSimilarly, if `dim(x)[i] > 1` and `dim(y)[i] == 1`, dimension `dim(y)[i]` is **broadcasted** to size `dim(x)[i]`.\n\n&nbsp;\n\n\n**Scenario 3:**  \nFinally, suppose for some dimension `i`, `dim(x)[i] > 1`, and `dim(y)[i]` is non-existing.  \nI.e., `x` has more dimensions than `y`.  \nIn this case, the missing dimension in `y` is replaced with a dimensions of size `1`, and scenario 2 is used.  \nSimilarly, if `dim(y)[i] > 1` and `dim(x)[i]` is non-existing, the missing dimension in `x` is replaced with a dimension of size `1` and we get back to scenario 2.  \n\nIt does not matter how much difference there is between the number of dimensions of `x` and the number of dimensions of `y`: any number of missing dimensions will be replaced with `1`, as long as the total number of dimensions for each array does not exceed `16`.\n\n&nbsp;\n\n**Illustration**\n\nTo illustrate, let's check 2 conformable arrays, and see which dimension of which array is broadcasted by how much\n\n```{r echo = TRUE, eval = TRUE}\nx <- array(rnorm(10), c(10, 1, 1, 9, 6))\ny <- array(rnorm(10), c(10, 1, 5, 1))\n```\n\n\n```{r echo=FALSE, eval=TRUE}\ndimx <- dim(x)\ndimy <- dim(y)\nfoo <- data.frame(\n  i = 1:length(dimx),\n  `dim(x)` = dimx,\n  `dim(y)` = c(dimy, NA),\n  broadcasted = c(\"neither\", \"neither\", \"x\", \"y\", \"y\"),\n  reason = c(\n    \"dims equal\", \"dims equal\",\n    \"dim(x)[i] == 1\", \"dim(y)[i] == 1\",\n    \"dim(y)[i] is missing\"\n  ),\n  note = c(\n    rep(\"\", 2),\n    \"dim(x)[i] recycled to size 5\",\n    \"dim(y)[i] recycled to size 9\",\n    \"dim(y) extended with a 1; dim(y)[i] recycled to size 6\"\n  ),\n  check.names = FALSE\n)\n\nknitr::kable(foo) |> kableExtra::column_spec(1:6, border_left = TRUE, border_right = TRUE)\n\n```\n\n\n&nbsp;\n\n# Dimensionless Vectors\n\nThe functions in 'broadcast' treat dimensionless vectors are treated as 1-dimensional column-vectors. This is analogous to standard linear algebraic convention, where an vector of unspecified orientation is taken to be a column-vector.\n\nI.e. `1:10` is the same as `array(1:10, dim = c(10))`.\n\n&nbsp;\n\n# Orthogonal Arrays\n\nIn the documentation of 'broadcast', the reader may come across the term \"orthogonal arrays\" here and there.  \n\"orthogonal\" is a term that can mean a great many things; this section therefore explains what \"orthogonal\" means in the context of broadcasting.\n\nConsider a column-vector `x` and row-vector `y`:\n\n```{r}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\nprint(x)\nprint(y)\n```\n\nThese vectors are (in a very literal sense) perpendicular to each other, and thus in that sense orthogonal to each other.  \nThis type of orthogonality can be extended to arrays as follows.  \nFor the purposes of broadcasting, any pair of arrays, `x` and `y`, can be referred to as being \"orthogonal\" if **all** of the following holds for that pair of arrays:  \n\n - For **every** dimension index `i`, `dim(x)[i] != dim(y)[i]`\n - For **every** dimensions index `i`,`dim(x)[i]` is `1` or missing, **OR** `dim(y)[i]` is `1` or missing.\n\n\nFor example, the following 2 arrays are orthogonal:\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(1, 9, 1, 9, 1, 11))\n\n```\n\nAnd the following 2 arrays are not orthogonal:\n\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(10, 9, 1, 9, 10))\n\n```\n\n\n&nbsp;\n&nbsp;\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"c_broadcasting_explained.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","fontsize":"1.2em","fontcolor":"#18161B","mainfont":"Tahoma","theme":["pandoc","../light.css"],"title":"Broadcasting Explained"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}