{"title":"Practical Applications","markdown":{"yaml":{"title":"Practical Applications","format":"html"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup, echo=FALSE, eval=TRUE}\nlibrary(broadcast)\nlibrary(fontawesome) |> suppressWarnings()\n```\n\n\n&nbsp;\n\n\nBroadcasting comes up frequent enough in real world problems. This page gives a few examples of these.\n\n&nbsp;\n\n# Binding arrays along an arbitrary dimension\n\nThe `abind()` function, from the package of the same name, allows one to bind arrays along any arbitrary dimensions (not just along rows or columns).  \nUnfortunately, `abind()` does not support broadcasting, which can lead to frustrations such as the following:\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:27, c(3,3,3))\ny <- array(1L, c(3,3,1))\nabind::abind(x, y, along = 2)\n\n#> Error in abind(x, y, along = 2) : \n#>  arg 'X2' has dims=3, 3, 1; but need dims=3, X, 3\n```\n\nHere, `abind()` is complaining about the dimensions not fitting perfectly.  \nBut intuitively, binding `x` and `y` should be possible, with dimension `3` from array `y` being broadcasted to size 3.\n\nThe [bind_array()](/man/bind_array.qmd) function provided by the 'broadcast' package can bind the arrays without problems:\n\n```{r echo=TRUE, eval=TRUE}\nx <- array(1:27, c(3,3,3))\ny <- array(1L, c(3,3,1))\nbind_array(list(x, y), 2)\n```\n\n[bind_array()](/man/bind_array.qmd) is also considerably faster and more memory efficient than `abind()`.\n\n&nbsp;\n\n# Array casting\n\n## Casting with equal group sizes\n\nSuppose you read the following matrix from a file:\n\n```{r}\nx <- cbind(\n  id = rep(1:3, each = 2),\n  grp = rep(1:2, 3),\n  val = 1:6 * 2\n)\nprint(x)\n```\n\nFor computing purposes, you may need the rows of each group - defined in column \"grp\" - to be cast to a new dimension.\n\n'broadcast' allows users to cast subsets of an array onto a new dimension, based on some grouping factor.\nIn this case, the following will do the job:\n\n```{r}\nmargin <- 1L # we cast from the rows, so margin = 1\ngrp <- as.factor(x[, 2]) # factor to define which rows belongs to which group\nlevels(grp) <- c(\"a\", \"b\") # names for the new dimension\nout <- acast(x, margin, grp) # casting is performed here\nprint(out)\n```\n\nNotice that the dimension-names of the new dimension (dimension 3) are equal to `levels(grp)`.\n\nWith the cast array, one can use broadcasting to easily do things like multiply the values in each group with a different value, like so:\n\n```{r}\n\n# create the multiplication factor array\nmult <- array(\n  1, c(1, 3, 2),\n  list(NULL, c(\"mult_id\", \"mult_grp\", \"mult_val\"), c(\"a\", \"b\"))\n)\nmult[, \"mult_val\", c(\"a\", \"b\")] <- c(2, 10)\nprint(mult)\n\nout2 <- bc.num(out, mult, \"*\")\ndimnames(out2) <- dimnames(out)\nprint(out2)\n\n```\n\n\nPerhaps you'd like to reverse-cast the array back when you're done computing; reverse-casting an array can be done be combining `asplit()` with [bind_array()](/man/bind_array.qmd):\n\n```{r}\nasplit(out2, ndim(out2)) |> bind_array(along = margin)\n```\n\n...though the order of, in this case, the rows (because `margin = 1`) will not necessarily be the same as the original array.\n\n\n&nbsp;\n\n\n## Casting with unequal group sizes\n\nThe casting arrays also works when the groups have unequal sizes, though there are a few things to keep in mind.\n\nLet's start again with the input array:\n\n```{r}\nx <- cbind(\n  id = c(rep(1:3, each = 2), 1),\n  grp = c(rep(1:2, 3), 2),\n  val = rnorm(7)\n)\nprint(x)\n```\n\nOnce again, the [acast()](/man/acast.qmd) function can be used to cast the group subsets from the rows over a new dimension. But this time, we need to specify `fill = TRUE` to allow [acast()](/man/acast.qmd) to fill the gaps, otherwise an error is called.\n\nThus one can cast in this case like so:\n\n```{r}\ngrp <- as.factor(x[, 2])\nlevels(grp) <- c(\"a\", \"b\")\nmargin <- 1L\nout <- acast(x, margin, grp, fill = TRUE)\nprint(out)\n```\n\nNotice that some values are missing ( `NA` ); if some groups have unequal number of elements, [acast()](/man/acast.qmd) needs to fill the gaps with missing values.\n\nOnce again, we can get the original array back when we're done like so:\n\n```{r}\nasplit(out, ndim(out)) |> bind_array(along = margin)\n```\n\n... but we do keep the missing values when the groups have an unequal number of elements.\n\n\n&nbsp;\n\n# Vector quantization\n\nHere is an example taken from Numpy's own online documentation.\n\nThe basic operation in Vector Quantization (VQ) finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown below, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, `codes[1]` is the closest class indicating that the athlete is likely a basketball player.\n\n```{r}\n\nobservation <- array(c(111.0, 188.0), dim = c(1, 2))\ncodes <- array(\n  c(102.0, 203.0,\n    132.0, 193.0,\n    45.0, 155.0,\n    57.0, 173.0),\n  dim = c(4, 2)\n)\n\ndiff <- bc.num(codes, observation, \"-\") # broadcasting happens here\ndist <- matrixStats::colSums2(diff^2) |> sqrt()\nwhich.min(dist) |> print()\ncodes[1] |> print()\n\n```\n\n\n&nbsp;\n\n\n# Perform computation on all possible pairs\n\nSuppose you have 2 vectors of strings, and you want to find concatenate every possible pair strings.\n\nIn base R, this would require a either a loop (which is slow), or repeating the vectors several times (which requires more memory).\n\nThe 'broadcasted way to do this, is to make the vectors orthogonal, and concatenate the strings of the orthogonal vectors, using the following code:\n\n```{r}\nx <- array(letters[1:10], c(10, 1))\ny <- array(letters[1:10], c(1, 10))\n\nout <- bc.str(x, y, \"+\")\ndimnames(out) <- list(x, y)\nprint(out)\n\n```\n\n\n&nbsp;\n\n\n\n\n\n\n\n\n&nbsp;\n&nbsp;\n","srcMarkdownNoYaml":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup, echo=FALSE, eval=TRUE}\nlibrary(broadcast)\nlibrary(fontawesome) |> suppressWarnings()\n```\n\n\n&nbsp;\n\n# Introduction\n\nBroadcasting comes up frequent enough in real world problems. This page gives a few examples of these.\n\n&nbsp;\n\n# Binding arrays along an arbitrary dimension\n\nThe `abind()` function, from the package of the same name, allows one to bind arrays along any arbitrary dimensions (not just along rows or columns).  \nUnfortunately, `abind()` does not support broadcasting, which can lead to frustrations such as the following:\n\n```{r echo=TRUE, eval=FALSE}\nx <- array(1:27, c(3,3,3))\ny <- array(1L, c(3,3,1))\nabind::abind(x, y, along = 2)\n\n#> Error in abind(x, y, along = 2) : \n#>  arg 'X2' has dims=3, 3, 1; but need dims=3, X, 3\n```\n\nHere, `abind()` is complaining about the dimensions not fitting perfectly.  \nBut intuitively, binding `x` and `y` should be possible, with dimension `3` from array `y` being broadcasted to size 3.\n\nThe [bind_array()](/man/bind_array.qmd) function provided by the 'broadcast' package can bind the arrays without problems:\n\n```{r echo=TRUE, eval=TRUE}\nx <- array(1:27, c(3,3,3))\ny <- array(1L, c(3,3,1))\nbind_array(list(x, y), 2)\n```\n\n[bind_array()](/man/bind_array.qmd) is also considerably faster and more memory efficient than `abind()`.\n\n&nbsp;\n\n# Array casting\n\n## Casting with equal group sizes\n\nSuppose you read the following matrix from a file:\n\n```{r}\nx <- cbind(\n  id = rep(1:3, each = 2),\n  grp = rep(1:2, 3),\n  val = 1:6 * 2\n)\nprint(x)\n```\n\nFor computing purposes, you may need the rows of each group - defined in column \"grp\" - to be cast to a new dimension.\n\n'broadcast' allows users to cast subsets of an array onto a new dimension, based on some grouping factor.\nIn this case, the following will do the job:\n\n```{r}\nmargin <- 1L # we cast from the rows, so margin = 1\ngrp <- as.factor(x[, 2]) # factor to define which rows belongs to which group\nlevels(grp) <- c(\"a\", \"b\") # names for the new dimension\nout <- acast(x, margin, grp) # casting is performed here\nprint(out)\n```\n\nNotice that the dimension-names of the new dimension (dimension 3) are equal to `levels(grp)`.\n\nWith the cast array, one can use broadcasting to easily do things like multiply the values in each group with a different value, like so:\n\n```{r}\n\n# create the multiplication factor array\nmult <- array(\n  1, c(1, 3, 2),\n  list(NULL, c(\"mult_id\", \"mult_grp\", \"mult_val\"), c(\"a\", \"b\"))\n)\nmult[, \"mult_val\", c(\"a\", \"b\")] <- c(2, 10)\nprint(mult)\n\nout2 <- bc.num(out, mult, \"*\")\ndimnames(out2) <- dimnames(out)\nprint(out2)\n\n```\n\n\nPerhaps you'd like to reverse-cast the array back when you're done computing; reverse-casting an array can be done be combining `asplit()` with [bind_array()](/man/bind_array.qmd):\n\n```{r}\nasplit(out2, ndim(out2)) |> bind_array(along = margin)\n```\n\n...though the order of, in this case, the rows (because `margin = 1`) will not necessarily be the same as the original array.\n\n\n&nbsp;\n\n\n## Casting with unequal group sizes\n\nThe casting arrays also works when the groups have unequal sizes, though there are a few things to keep in mind.\n\nLet's start again with the input array:\n\n```{r}\nx <- cbind(\n  id = c(rep(1:3, each = 2), 1),\n  grp = c(rep(1:2, 3), 2),\n  val = rnorm(7)\n)\nprint(x)\n```\n\nOnce again, the [acast()](/man/acast.qmd) function can be used to cast the group subsets from the rows over a new dimension. But this time, we need to specify `fill = TRUE` to allow [acast()](/man/acast.qmd) to fill the gaps, otherwise an error is called.\n\nThus one can cast in this case like so:\n\n```{r}\ngrp <- as.factor(x[, 2])\nlevels(grp) <- c(\"a\", \"b\")\nmargin <- 1L\nout <- acast(x, margin, grp, fill = TRUE)\nprint(out)\n```\n\nNotice that some values are missing ( `NA` ); if some groups have unequal number of elements, [acast()](/man/acast.qmd) needs to fill the gaps with missing values.\n\nOnce again, we can get the original array back when we're done like so:\n\n```{r}\nasplit(out, ndim(out)) |> bind_array(along = margin)\n```\n\n... but we do keep the missing values when the groups have an unequal number of elements.\n\n\n&nbsp;\n\n# Vector quantization\n\nHere is an example taken from Numpy's own online documentation.\n\nThe basic operation in Vector Quantization (VQ) finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown below, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, `codes[1]` is the closest class indicating that the athlete is likely a basketball player.\n\n```{r}\n\nobservation <- array(c(111.0, 188.0), dim = c(1, 2))\ncodes <- array(\n  c(102.0, 203.0,\n    132.0, 193.0,\n    45.0, 155.0,\n    57.0, 173.0),\n  dim = c(4, 2)\n)\n\ndiff <- bc.num(codes, observation, \"-\") # broadcasting happens here\ndist <- matrixStats::colSums2(diff^2) |> sqrt()\nwhich.min(dist) |> print()\ncodes[1] |> print()\n\n```\n\n\n&nbsp;\n\n\n# Perform computation on all possible pairs\n\nSuppose you have 2 vectors of strings, and you want to find concatenate every possible pair strings.\n\nIn base R, this would require a either a loop (which is slow), or repeating the vectors several times (which requires more memory).\n\nThe 'broadcasted way to do this, is to make the vectors orthogonal, and concatenate the strings of the orthogonal vectors, using the following code:\n\n```{r}\nx <- array(letters[1:10], c(10, 1))\ny <- array(letters[1:10], c(1, 10))\n\nout <- bc.str(x, y, \"+\")\ndimnames(out) <- list(x, y)\nprint(out)\n\n```\n\n\n&nbsp;\n\n\n\n\n\n\n\n\n&nbsp;\n&nbsp;\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"f_practical_applications.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","fontsize":"1.2em","fontcolor":"#18161B","mainfont":"Tahoma","theme":["pandoc","../light.css"],"title":"Practical Applications"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}