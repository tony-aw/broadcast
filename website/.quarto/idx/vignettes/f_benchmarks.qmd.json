{"title":"Benchmarks with Numpy+reticulate","markdown":{"yaml":{"title":"Benchmarks with Numpy+reticulate","format":"html"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\",\n  warning = FALSE\n)\n```\n\n```{r setup, eval=TRUE, echo=FALSE}\nlibrary(broadcast)\nlibrary(bench)\nlibrary(tinyplot)\n```\n\n\n&nbsp;\n\n\nIn this article, the speed of 'broadcast' is compared to the speed of 'Numpy' via {reticulate}.\n\n\n&nbsp;\n\n# Keeping comparisons fair\n\nTo keep the comparisons between 'broadcast' and 'Numpy'+'reticulate' fair, a number of measures have been taken:\n\n - conversion from Numpy to 'R' is DISABLED; this allows for comparing the speed more fairly. When conversion would be enabled, precious time would be wasted to convert from Numpy structures to comparable 'R' structures.\n - garbage collection is disabled in reticulate's Python. In 'R', only benchmarks with no garbage collection, or level 0 garbage collection, is used. I feel this keeps the comparisons relatively fair (but it's not perfect).\n - 'R' has more support for missing values than 'Numpy', which also leads to a difference in speed. But both 'R' and 'Numpy' handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in 'R' ), through the `NaN` construct. Therefore, only operations on decimal numbers are compared.\n\n\n&nbsp;\n\n# Many Orthogonal Arrays\n\n\n8 pairs of decimal number arrays are created in both 'R' and 'Numpy'. They all have a length of (approximately) 9*10^6 elements. Each pair will have a different number of dimensions, from 2 to 9 (hence 8 pairs of arrays).\nI.e. a pair of 2d arrays, a pair of 3d arrays, etc.\n\nThese pairs of arrays are fully orthogonal, thus the maximum amount of broadcasting will be employed.\n\nFor each pair of array the outer sum is computed using 'broadcast' and 'Numpy'. This computation is repeated 100 times, and the median result is taken.\n\nThus we get the following code:\n\n```{r eval = FALSE, echo=TRUE}\n# set-up ====\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp <- rt$import(\"numpy\", convert = FALSE)\ngc <- rt$import(\"gc\", convert = FALSE)\nget_times <- function(obj, j) {\n  nms <- names(res$expression)\n  j <- which(nms == j)\n  idx <- rowSums(obj$gc[[j]][, 2:3]) == 0\n  times <- obj$time[[j]][idx]\n  return(times)\n}\ngc$disable()\n\n# loop\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", 8)\ncounter <- 1L\ntarget_len <- 9e6\n\nfor(i in 2:9) {\n  print(i)\n  n <- round(target_len^(1/i)) |> as.integer()\n  len <- n^i\n  cat(\"i = \", i, \"\\n\")\n  cat(\"n = \", n, \"\\n\")\n  cat(\"len = \", len, \"\\n\")\n  x.dims <- rep(c(n, 1L), i - 1)[1:i]\n  y.dims <- rep(c(1L, n), i - 1)[1:i]\n  a.dims <- rt$r_to_py(as.list(x.dims))\n  b.dims <- rt$r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 100\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n```\n\n\nUsing {tinyplot}, the median, first quartile, and third quartile of the bench-marked computation times are presented in the following graph:\n\n```{r echo=FALSE, eval=TRUE, fig.width=8, fig.height=4}\nload(\"bm_numpy_loop.RData\")\n\nlibrary(tinyplot) |> suppressWarnings()\n\ndf1 <- data.frame(\n  broadcast = median_bc, numpy = median_np, i = 2:9\n)\ndf1 <- tidyr::pivot_longer(df1, 1:2, values_to = \"median\")\ndf2 <- data.frame(\n  q1_bc, q1_np, i = 2:9\n)\ndf2 <- tidyr::pivot_longer(df2, 1:2, values_to = \"q1\")\ndf3 <- data.frame(\n  q3_bc, q3_np, i = 2:9\n)\ndf3 <- tidyr::pivot_longer(df3, 1:2, values_to = \"q3\")\n\ndf <- cbind(df1, df2[, 3], df3[, 3])\n\nmodule <- df$name\ntinytheme(\"minimal\")\ntinyplot(\n  df$i, df$median*1000, by = module, type = \"l\",\n  main = \"benchmarks\",\n  xlab = \"number of dimensions\",\n  ylab = \"median time (ms)\"\n)\ntinyplot_add(\n  min = df$q1*1000, ymax = df$q3*1000, by = module,\n  type = type_ribbon(alpha = 0.25)\n)\n\n\n```\n\n\n&nbsp;\n\n\n# Large non-orthogonal arrays comparisons\n\nHow about arrays that are not fully orthogonal, but still require a lot of broadcasting in pair-wise computations?\n\nHere is the benchmark:\n\n```{r eval=FALSE, echo=TRUE}\n\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp <- rt$import(\"numpy\", convert = FALSE)\ngc <- rt$import(\"gc\", convert = FALSE)\ngc$disable()\n\nn <- 26L\nnpa <- np$random$rand(n, 1L, n, 1L, n)\nnpb <- np$random$rand(n, n, 1L, n, 1L)\n\na.dim <- c(n, rep(c(1L, n), 2))\nb.dim <- c(n, rep(c(n, 1L), 2))\na <- array(rnorm(100), a.dim)\nb <- array(rnorm(100), b.dim)\n\nbm_numpy_large <- bench::mark(\n  broadcast = bc.num(a, b, \"+\"),\n  `numpy (no conversion to R)` = npa + npb,\n  check = FALSE,\n  min_iterations = 200,\n)\nsummary(bm_numpy_large)\nggplot2::autoplot(bm_numpy_large)\n\n```\n\n```{r echo=FALSE, eval=TRUE, fig.width=8}\nload(\"bm_numpy_large.RData\")\nsummary(bm_numpy_large)\nggplot2::autoplot(bm_numpy_large)\n```\n\n\n&nbsp;\n\n&nbsp;\n","srcMarkdownNoYaml":"\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\",\n  warning = FALSE\n)\n```\n\n```{r setup, eval=TRUE, echo=FALSE}\nlibrary(broadcast)\nlibrary(bench)\nlibrary(tinyplot)\n```\n\n\n&nbsp;\n\n# Introduction\n\nIn this article, the speed of 'broadcast' is compared to the speed of 'Numpy' via {reticulate}.\n\n\n&nbsp;\n\n# Keeping comparisons fair\n\nTo keep the comparisons between 'broadcast' and 'Numpy'+'reticulate' fair, a number of measures have been taken:\n\n - conversion from Numpy to 'R' is DISABLED; this allows for comparing the speed more fairly. When conversion would be enabled, precious time would be wasted to convert from Numpy structures to comparable 'R' structures.\n - garbage collection is disabled in reticulate's Python. In 'R', only benchmarks with no garbage collection, or level 0 garbage collection, is used. I feel this keeps the comparisons relatively fair (but it's not perfect).\n - 'R' has more support for missing values than 'Numpy', which also leads to a difference in speed. But both 'R' and 'Numpy' handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in 'R' ), through the `NaN` construct. Therefore, only operations on decimal numbers are compared.\n\n\n&nbsp;\n\n# Many Orthogonal Arrays\n\n\n8 pairs of decimal number arrays are created in both 'R' and 'Numpy'. They all have a length of (approximately) 9*10^6 elements. Each pair will have a different number of dimensions, from 2 to 9 (hence 8 pairs of arrays).\nI.e. a pair of 2d arrays, a pair of 3d arrays, etc.\n\nThese pairs of arrays are fully orthogonal, thus the maximum amount of broadcasting will be employed.\n\nFor each pair of array the outer sum is computed using 'broadcast' and 'Numpy'. This computation is repeated 100 times, and the median result is taken.\n\nThus we get the following code:\n\n```{r eval = FALSE, echo=TRUE}\n# set-up ====\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp <- rt$import(\"numpy\", convert = FALSE)\ngc <- rt$import(\"gc\", convert = FALSE)\nget_times <- function(obj, j) {\n  nms <- names(res$expression)\n  j <- which(nms == j)\n  idx <- rowSums(obj$gc[[j]][, 2:3]) == 0\n  times <- obj$time[[j]][idx]\n  return(times)\n}\ngc$disable()\n\n# loop\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", 8)\ncounter <- 1L\ntarget_len <- 9e6\n\nfor(i in 2:9) {\n  print(i)\n  n <- round(target_len^(1/i)) |> as.integer()\n  len <- n^i\n  cat(\"i = \", i, \"\\n\")\n  cat(\"n = \", n, \"\\n\")\n  cat(\"len = \", len, \"\\n\")\n  x.dims <- rep(c(n, 1L), i - 1)[1:i]\n  y.dims <- rep(c(1L, n), i - 1)[1:i]\n  a.dims <- rt$r_to_py(as.list(x.dims))\n  b.dims <- rt$r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 100\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n```\n\n\nUsing {tinyplot}, the median, first quartile, and third quartile of the bench-marked computation times are presented in the following graph:\n\n```{r echo=FALSE, eval=TRUE, fig.width=8, fig.height=4}\nload(\"bm_numpy_loop.RData\")\n\nlibrary(tinyplot) |> suppressWarnings()\n\ndf1 <- data.frame(\n  broadcast = median_bc, numpy = median_np, i = 2:9\n)\ndf1 <- tidyr::pivot_longer(df1, 1:2, values_to = \"median\")\ndf2 <- data.frame(\n  q1_bc, q1_np, i = 2:9\n)\ndf2 <- tidyr::pivot_longer(df2, 1:2, values_to = \"q1\")\ndf3 <- data.frame(\n  q3_bc, q3_np, i = 2:9\n)\ndf3 <- tidyr::pivot_longer(df3, 1:2, values_to = \"q3\")\n\ndf <- cbind(df1, df2[, 3], df3[, 3])\n\nmodule <- df$name\ntinytheme(\"minimal\")\ntinyplot(\n  df$i, df$median*1000, by = module, type = \"l\",\n  main = \"benchmarks\",\n  xlab = \"number of dimensions\",\n  ylab = \"median time (ms)\"\n)\ntinyplot_add(\n  min = df$q1*1000, ymax = df$q3*1000, by = module,\n  type = type_ribbon(alpha = 0.25)\n)\n\n\n```\n\n\n&nbsp;\n\n\n# Large non-orthogonal arrays comparisons\n\nHow about arrays that are not fully orthogonal, but still require a lot of broadcasting in pair-wise computations?\n\nHere is the benchmark:\n\n```{r eval=FALSE, echo=TRUE}\n\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp <- rt$import(\"numpy\", convert = FALSE)\ngc <- rt$import(\"gc\", convert = FALSE)\ngc$disable()\n\nn <- 26L\nnpa <- np$random$rand(n, 1L, n, 1L, n)\nnpb <- np$random$rand(n, n, 1L, n, 1L)\n\na.dim <- c(n, rep(c(1L, n), 2))\nb.dim <- c(n, rep(c(n, 1L), 2))\na <- array(rnorm(100), a.dim)\nb <- array(rnorm(100), b.dim)\n\nbm_numpy_large <- bench::mark(\n  broadcast = bc.num(a, b, \"+\"),\n  `numpy (no conversion to R)` = npa + npb,\n  check = FALSE,\n  min_iterations = 200,\n)\nsummary(bm_numpy_large)\nggplot2::autoplot(bm_numpy_large)\n\n```\n\n```{r echo=FALSE, eval=TRUE, fig.width=8}\nload(\"bm_numpy_large.RData\")\nsummary(bm_numpy_large)\nggplot2::autoplot(bm_numpy_large)\n```\n\n\n&nbsp;\n\n&nbsp;\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"f_benchmarks.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","fontsize":"1.2em","mainfont":"Tahoma","theme":["cosmo","../light.css"],"title":"Benchmarks with Numpy+reticulate"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}