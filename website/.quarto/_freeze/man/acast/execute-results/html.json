{
  "hash": "d9701af281fd45d9071538cbb6ba1189",
  "result": {
    "markdown": "---\ntitle: acast\n---\n\n## Simple and Fast Casting/Pivoting of an Array {.unnumbered}\n\n\n### Description\n\nThe <code>acast()</code> function spreads subsets of an array margin over a new dimension. <br />\nWritten in 'C' and 'C++' for high speed and memory efficiency. <br />\n<br />\nRoughly speaking, <code>acast()</code> can be thought of as the &quot;array&quot; analogy to\n<code>data.table::</code>dcast. <br />\nBut note 2 important differences:\n\n\n<ul>\n<li> <code>acast()</code> works on arrays instead of data.tables.\n\n</li>\n<li> <code>acast()</code> casts into a completely new dimension\n(namely <code>ndim(x) + 1</code>),\ninstead of casting into new columns.\n\n</li></ul>\n\n\n\n### Usage\n\n<pre><code class='language-R'>acast(x, margin, grp, fill = FALSE)\n</code></pre>\n\n\n### Arguments\n\n<table>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"x\">x</code></td>\n<td>\nan atomic or recursive array.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"margin\">margin</code></td>\n<td>\na scalar integer, specifying the margin to cast from.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"grp\">grp</code></td>\n<td>\na factor, where <code>length(grp) == dim(x)[margin]</code>, with at least <code>2</code> unique values,\nspecifying which indices of <code>dim(x)[margin]</code> belong to which group. <br />\nEach group will be cast onto a separate index of dimension <code>ndim(x) + 1</code>. <br />\nUnused levels of <code>grp</code> will be dropped. <br />\nAny <code>NA</code> values or levels found in <code>grp</code> will result in an error.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"fill\">fill</code></td>\n<td>\nBoolean, indicating if missing values should be filled. <br />\nThis is used in case the levels of <code>grp</code> do not have equal frequencies,\nand thus additional values must be filled. <br />\nIf <code>x</code> is atomic but not <code>raw</code>, missing values are filled with <code>NA</code>. <br />\nIf <code>x</code> is recursive, missing values are filled with <code>list(NULL)</code>. <br />\nIf <code>x</code> is of type <code>raw</code>, uneven groupings are not supported.\n</td></tr>\n</table>\n\n\n### Details\n\nFor the sake of illustration, consider a matrix <code>x</code> and a grouping factor <code>grp</code>. <br />\nLet the integer scalar <code>k</code> represent a group in <code>grp</code>, such that <code>k</code> $\\in$ <code>1:nlevels(grp)</code>. <br />\nThen the code <br />\n<code>out = acast(x, margin = 1, grp = grp)</code> <br />\nessentially performs the following for every group <code>k</code>:\n\n\n<ul>\n<li> copy-paste the subset <code>x[grp == k, ]</code> to the subset <code>out[, , k]</code>.\n\n</li></ul>\n\nPlease see the examples section\nto get a good idea on how this function casts an array. <br />\nA more detailed explanation of the <code>acast()</code> function\ncan be found on the website. <br /> <br />\n\n\n\n### Value\n\nAn array with the following properties:\n\n\n<ul>\n<li> the number of dimensions of the output array is equal to <code>ndim(x) + 1</code>;\n\n</li>\n<li> the dimensions of the output array is equal to <code style=\"white-space: pre;\">c(dim(x), max(tabulate(grp))</code>;\n\n</li>\n<li> the <code>dimnames</code> of the output array is equal to <code>c(dimnames(x), list(levels(grp)))</code>. <br /> <br />\n\n</li></ul>\n\n\n\n### Back transformation\n\nFrom the casted array, <br />\n<code>out = acast(x, margin, grp)</code>, <br />\none can get the original <code>x</code> back by using <br />\n<code>back = asplit(out, ndim(out)) |&gt; bind_array(along = margin)</code>. <br />\nNote, however, the following about the back-transformed array <code>back</code>:\n\n\n<ul>\n<li> <code>back</code> will be ordered by <code>grp</code> along dimension <code>margin</code>;\n\n</li>\n<li> if the levels of <code>grp</code> did not have equal frequencies,\nthen <code>dim(back)[margin] &gt; dim(x)[margin]</code>,\nand <code>back</code> will have more missing values than <code>x</code>. <br /> <br />\n\n</li></ul>\n\n\n\n### Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"broadcast\")\n\n\nx <- cbind(id = c(rep(1:3, each = 2), 1), grp = c(rep(1:2, 3), 2), val = rnorm(7))\nprint(x)\n##      id grp           val\n## [1,]  1   1 -0.0568356647\n## [2,]  1   2  1.6026083513\n## [3,]  2   1 -0.4675473207\n## [4,]  2   2 -0.1380753997\n## [5,]  3   1 -0.6669718473\n## [6,]  3   2 -0.0004787917\n## [7,]  1   2 -0.4268307270\n\ngrp <- as.factor(x[, 2])\nlevels(grp) <- c(\"a\", \"b\")\nmargin <- 1L\n\nacast(x, margin, grp, fill = TRUE)\n## , , a\n## \n##      id grp         val\n## [1,]  1   1 -0.05683566\n## [2,]  2   1 -0.46754732\n## [3,]  3   1 -0.66697185\n## [4,] NA  NA          NA\n## \n## , , b\n## \n##      id grp           val\n## [1,]  1   2  1.6026083513\n## [2,]  2   2 -0.1380753997\n## [3,]  3   2 -0.0004787917\n## [4,]  1   2 -0.4268307270\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}