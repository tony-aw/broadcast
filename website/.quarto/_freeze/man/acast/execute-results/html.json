{
  "hash": "439189cde13ac2faa3d56fdbf3b637a4",
  "result": {
    "markdown": "---\ntitle: acast\n---\n\n## Simple and Fast Casting/Pivoting of an Array {.unnumbered}\n\n\n### Description\n\nThe <code>acast()</code> function spreads subsets of an array margin over a new dimension. <br />\nWritten in 'C' and 'C++' for high speed and memory efficiency. <br />\n<br />\nRoughly speaking, <code>acast()</code> can be thought of as the &quot;array&quot; analogy to\n<code>data.table::dcast()</code>. <br />\nBut note 2 important differences:\n\n\n<ul>\n<li> <code>acast()</code> works on arrays instead of data.tables.\n\n</li>\n<li> <code>acast()</code> casts into a completely new dimension\n(namely <code>ndim(x) + 1</code>),\ninstead of casting into new columns.\n\n</li></ul>\n\n\n\n### Usage\n\n<pre><code class='language-R'>acast(\n  x,\n  margin,\n  grp,\n  fill = FALSE,\n  fill_val = if (is.atomic(x)) NA else list(NULL)\n)\n</code></pre>\n\n\n### Arguments\n\n<table>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"x\">x</code></td>\n<td>\nan atomic or recursive array.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"margin\">margin</code></td>\n<td>\na scalar integer, specifying the margin to cast from.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"grp\">grp</code></td>\n<td>\na factor, where <code>length(grp) == dim(x)[margin]</code>, with at least <code>2</code> unique values,\nspecifying which indices of <code>dim(x)[margin]</code> belong to which group. <br />\nEach group will be cast onto a separate index of dimension <code>ndim(x) + 1</code>. <br />\nUnused levels of <code>grp</code> will be dropped. <br />\nAny <code>NA</code> values or levels found in <code>grp</code> will result in an error.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"fill\">fill</code></td>\n<td>\nBoolean. <br />\nWhen factor <code>grp</code> is unbalanced (i.e. has unequally sized groups)\nthe result will be an array where some slices have missing values, which need to be filled.\nIf <code>fill = TRUE</code>, an unbalanced <code>grp</code> factor is allowed,\nand missing values will be filled with <code>fill_val</code>. <br />\nIf <code>fill = FALSE</code> (default), an unbalanced <code>grp</code> factor is not allowed,\nand providing an unbalanced factor for <code>grp</code> produces an error. <br />\nWhen <code>x</code> has type of <code>raw</code>, unbalanced <code>grp</code> is never allowed.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"fill_val\">fill_val</code></td>\n<td>\nscalar of the same type of <code>x</code>,\ngiving value to use to fill in the gaps when <code>fill = TRUE</code>. <br />\nThe <code>fill_val</code> argument is ignored when <code>fill = FALSE</code> or when <code>x</code> has type of <code>raw</code>.\n</td></tr>\n</table>\n\n\n### Details\n\nFor the sake of illustration, consider a matrix <code>x</code> and a grouping factor <code>grp</code>. <br />\nLet the integer scalar <code>k</code> represent a group in <code>grp</code>, such that <code>k</code> $\\in$ <code>1:nlevels(grp)</code>. <br />\nThen the code <br />\n<code>out = acast(x, margin = 1, grp = grp)</code> <br />\nessentially performs the following for every group <code>k</code>:\n\n\n<ul>\n<li> copy-paste the subset <code>x[grp == k, ]</code> to the subset <code>out[, , k]</code>.\n\n</li></ul>\n\nPlease see the examples section\nto get a good idea on how this function casts an array. <br />\nA more detailed explanation of the <code>acast()</code> function\ncan be found on the website. <br /> <br />\n\n\n\n### Value\n\nAn array with the following properties:\n\n\n<ul>\n<li> the number of dimensions of the output array is equal to <code>ndim(x) + 1</code>;\n\n</li>\n<li> the dimensions of the output array is equal to <code style=\"white-space: pre;\">c(dim(x), max(tabulate(grp))</code>;\n\n</li>\n<li> the <code>dimnames</code> of the output array is equal to <code>c(dimnames(x), list(levels(grp)))</code>. <br /> <br />\n\n</li></ul>\n\n\n\n### Back transformation\n\nFrom the casted array, <br />\n<code>out = acast(x, margin, grp)</code>, <br />\none can get the original <code>x</code> back by using <br />\n<code>back = asplit(out, ndim(out)) |&gt; bind_array(along = margin)</code>. <br />\nNote, however, the following about the back-transformed array <code>back</code>:\n\n\n<ul>\n<li> <code>back</code> will be ordered by <code>grp</code> along dimension <code>margin</code>;\n\n</li>\n<li> if the levels of <code>grp</code> did not have equal frequencies,\nthen <code>dim(back)[margin] &gt; dim(x)[margin]</code>,\nand <code>back</code> will have more missing values than <code>x</code>. <br /> <br />\n\n</li></ul>\n\n\n\n### Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"broadcast\")\n\n\nx <- cbind(id = c(rep(1:3, each = 2), 1), grp = c(rep(1:2, 3), 2), val = rnorm(7))\nprint(x)\n##      id grp         val\n## [1,]  1   1 -0.56912847\n## [2,]  1   2  1.57779116\n## [3,]  2   1  1.07395678\n## [4,]  2   2  1.08131601\n## [5,]  3   1  0.71766590\n## [6,]  3   2 -0.02989804\n## [7,]  1   2  0.28645305\n\ngrp <- as.factor(x[, 2])\nlevels(grp) <- c(\"a\", \"b\")\nmargin <- 1L\n\nacast(x, margin, grp, fill = TRUE)\n## , , a\n## \n##      id grp        val\n## [1,]  1   1 -0.5691285\n## [2,]  2   1  1.0739568\n## [3,]  3   1  0.7176659\n## [4,] NA  NA         NA\n## \n## , , b\n## \n##      id grp         val\n## [1,]  1   2  1.57779116\n## [2,]  2   2  1.08131601\n## [3,]  3   2 -0.02989804\n## [4,]  1   2  0.28645305\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}