{
  "hash": "e15518f2888991f096b0c424bd02a01c",
  "result": {
    "markdown": "---\ntitle: bc_ifelse\n---\n\n## Broadcasted Ifelse {.unnumbered}\n\n\n### Description\n\nThe <code>bc_ifelse()</code> function\nperforms a broadcasted form of ifelse. <br />\n\n\n\n### Usage\n\n<pre><code class='language-R'>bc_ifelse(cond, yes, no)\n</code></pre>\n\n\n### Arguments\n\n<table>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"cond\">cond</code></td>\n<td>\n<code>logical</code> vector or array with the length equal to <code>prod(bc_dim(yes, no))</code>.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"yes\">yes</code>, <code id=\"no\">no</code></td>\n<td>\nconformable arrays of the same type. <br />\nAll atomic types (see atomic) are supported. <br />\nRecursive arrays of type <code>list</code> are also supported. <br /> <br />\n</td></tr>\n</table>\n\n\n### Value\n\nThe ouput, here referred to as <code>out</code>,\nwill be an array of the same type as <code>yes</code> and <code>no</code>. <br />\nAfter broadcasting <code>yes</code> against <code>no</code>,\ngiven any element index <code>i</code>,\nthe following will hold for the output:\n\n\n<ul>\n<li> when <code>cond[i] == TRUE</code>, <code>out[i]</code> is <code>yes[i]</code>;\n\n</li>\n<li> when <code>cond[i] == FALSE</code>, <code>out[i]</code> is <code>no[i]</code>;\n\n</li>\n<li> when <code>cond[i]</code> is <code>NA</code>,\n<code>out[i]</code> is <code>NA</code> when <code>yes</code> and <code>no</code> are atomic,\nand <code>out[i]</code> is <code>list(NULL)</code> when <code>yes</code> and <code>no</code> are recursive. <br /> <br />\n\n</li></ul>\n\n\n\n### Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"broadcast\")\n\nx.dim <- c(c(10, 2,2))\nx.len <- prod(x.dim)\n\ngen <- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx <- array(gen(10), x.dim)\ny <- array(gen(10), c(10,1,1))\n\ncond <- bc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))\n) |> as_bool()\n\nbc_ifelse(cond, yes = x, no = y)\n## , , 1\n## \n##       [,1]         [,2]        \n##  [1,] character,12 character,12\n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] integer,10   integer,10  \n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] character,12 character,12\n## [10,] integer,10   integer,10  \n## \n## , , 2\n## \n##       [,1]         [,2]        \n##  [1,] character,12 character,12\n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] integer,10   integer,10  \n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] character,12 character,12\n## [10,] integer,10   integer,10\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}