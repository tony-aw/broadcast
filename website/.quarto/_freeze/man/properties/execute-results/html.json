{
  "hash": "53527824ea677fb1a3eb2f854a07d8d1",
  "result": {
    "markdown": "---\ntitle: properties\n---\n\n## Small property functions {.unnumbered}\n\n\n### Description\n\n<code>ndim()</code> returns the number of dimensions of an object. <br />\n<code>lst.ndim()</code> returns the number of dimensions of every list-element. <br />\n<code>lst.typeof()</code> returns the (internal) type of every list-element. <br />\n<code>len()</code> is an alias for <code>length</code>. <br />\n<code>lst.len()</code> is an alias for <code>lengths</code>. <br />\n<br />\nThese functions were all designed to be efficient. <br />\n<br />\n\n\n\n### Usage\n\n<pre><code class='language-R'>ndim(x)\n\nlst.ndim(x)\n\nlst.typeof(x)\n</code></pre>\n\n\n### Arguments\n\n<table>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"x\">x</code></td>\n<td>\nan object.<br />\nFor functions starting with <code>lst.</code>, <code>x</code> must be a list (i.e. recursive vector or recursive array). <br />\n</td></tr>\n</table>\n\n\n### Value\n\nAn integer scalar\n\n\n\n### Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"broadcast\")\n\n\n# bind_array ====\n\n# here, atomic and recursive arrays are mixed,\n# resulting in recursive arrays\n\n# creating the arrays\nx <- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx <- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) <- list(letters[1:4], LETTERS[1:3])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C           \na logical,3    logical,3    logical,3   \nb integer,10   integer,10   integer,10  \nc numeric,10   numeric,10   numeric,10  \nd character,26 character,26 character,26\n```\n:::\n\n```{.r .cell-code}\ny <- matrix(1:12, 4, 3)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n\n```{.r .cell-code}\n# binding the arrays\ninput <- list(x = x, y = y)\nbind_array(input, along = 0L) # binds on new dimension before first\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 1         2          3          4           \n\n, , 2\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 5         6          7          8           \n\n, , 3\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 9         10         11         12          \n```\n:::\n\n```{.r .cell-code}\nbind_array(input, along = 1L) # binds on first dimension (i.e. rows)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    A            B            C           \na   logical,3    logical,3    logical,3   \nb   integer,10   integer,10   integer,10  \nc   numeric,10   numeric,10   numeric,10  \nd   character,26 character,26 character,26\ny.1 1            5            9           \ny.2 2            6            10          \ny.3 3            7            11          \ny.4 4            8            12          \n```\n:::\n\n```{.r .cell-code}\nbind_array(input, along = 2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C            y.1 y.2 y.3\na logical,3    logical,3    logical,3    1   5   9  \nb integer,10   integer,10   integer,10   2   6   10 \nc numeric,10   numeric,10   numeric,10   3   7   11 \nd character,26 character,26 character,26 4   8   12 \n```\n:::\n\n```{.r .cell-code}\nbind_array(input, along = 3L) # bind on new dimension after last\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , x\n\n  A            B            C           \na logical,3    logical,3    logical,3   \nb integer,10   integer,10   integer,10  \nc numeric,10   numeric,10   numeric,10  \nd character,26 character,26 character,26\n\n, , y\n\n  A B C \na 1 5 9 \nb 2 6 10\nc 3 7 11\nd 4 8 12\n```\n:::\n\n```{.r .cell-code}\nbind_array(input, revalong = 0L) # binds on new dimension after last\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , x\n\n  A            B            C           \na logical,3    logical,3    logical,3   \nb integer,10   integer,10   integer,10  \nc numeric,10   numeric,10   numeric,10  \nd character,26 character,26 character,26\n\n, , y\n\n  A B C \na 1 5 9 \nb 2 6 10\nc 3 7 11\nd 4 8 12\n```\n:::\n\n```{.r .cell-code}\nbind_array(input, revalong = 1L) # binds on last dimension (i.e. columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C            y.1 y.2 y.3\na logical,3    logical,3    logical,3    1   5   9  \nb integer,10   integer,10   integer,10   2   6   10 \nc numeric,10   numeric,10   numeric,10   3   7   11 \nd character,26 character,26 character,26 4   8   12 \n```\n:::\n\n```{.r .cell-code}\nbind_array(input, revalong = 2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    A            B            C           \na   logical,3    logical,3    logical,3   \nb   integer,10   integer,10   integer,10  \nc   numeric,10   numeric,10   numeric,10  \nd   character,26 character,26 character,26\ny.1 1            5            9           \ny.2 2            6            10          \ny.3 3            7            11          \ny.4 4            8            12          \n```\n:::\n\n```{.r .cell-code}\nbind_array(input, revalong = 3L) # bind on new dimension before first\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 1         2          3          4           \n\n, , 2\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 5         6          7          8           \n\n, , 3\n\n  a         b          c          d           \nx logical,3 integer,10 numeric,10 character,26\ny 9         10         11         12          \n```\n:::\n\n```{.r .cell-code}\n# binding, with empty arrays\nemptyarray <- array(numeric(0L), c(0L, 3L))\ndimnames(emptyarray) <- list(NULL, paste(\"empty\", 1:3))\nprint(emptyarray)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     empty 1 empty 2 empty 3\n```\n:::\n\n```{.r .cell-code}\ninput <- list(x = x, y = emptyarray)\nbind_array(input, along = 1L, comnames_from = 2L) # row-bind\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C           \na logical,3    logical,3    logical,3   \nb integer,10   integer,10   integer,10  \nc numeric,10   numeric,10   numeric,10  \nd character,26 character,26 character,26\n```\n:::\n\n```{.r .cell-code}\n################################################################################\n\n# bind_mat ====\n\n# here, atomic and recursive matrices are mixed,\n# resulting in a recursive matrix\n\nx <- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx <- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) <- list(letters[1:4], LETTERS[1:3])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C           \na logical,3    logical,3    logical,3   \nb integer,10   integer,10   integer,10  \nc numeric,10   numeric,10   numeric,10  \nd character,26 character,26 character,26\n```\n:::\n\n```{.r .cell-code}\ny <- matrix(1:12, 4, 3)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n\n```{.r .cell-code}\nbind_mat(list(x = x, y = y), 2L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A            B            C                  \na logical,3    logical,3    logical,3    1 5 9 \nb integer,10   integer,10   integer,10   2 6 10\nc numeric,10   numeric,10   numeric,10   3 7 11\nd character,26 character,26 character,26 4 8 12\n```\n:::\n\n```{.r .cell-code}\n################################################################################\n\n# bind_dt ====\n\n\nx <- data.frame(a = 1:12, b = month.abb) # data.frame\ny <- data.table::data.table(a = 1:12, b = month.abb) # data.table\n\nbind_dt(list(x = x, y = y), 2L) # column bind\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x.a    x.b   y.a    y.b\n    <int> <char> <int> <char>\n 1:     1    Jan     1    Jan\n 2:     2    Feb     2    Feb\n 3:     3    Mar     3    Mar\n 4:     4    Apr     4    Apr\n 5:     5    May     5    May\n 6:     6    Jun     6    Jun\n 7:     7    Jul     7    Jul\n 8:     8    Aug     8    Aug\n 9:     9    Sep     9    Sep\n10:    10    Oct    10    Oct\n11:    11    Nov    11    Nov\n12:    12    Dec    12    Dec\n```\n:::\n\n```{.r .cell-code}\nbind_dt(list(x = x, y = y), 1L) # row bind\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        a      b\n    <int> <char>\n 1:     1    Jan\n 2:     2    Feb\n 3:     3    Mar\n 4:     4    Apr\n 5:     5    May\n 6:     6    Jun\n 7:     7    Jul\n 8:     8    Aug\n 9:     9    Sep\n10:    10    Oct\n11:    11    Nov\n12:    12    Dec\n13:     1    Jan\n14:     2    Feb\n15:     3    Mar\n16:     4    Apr\n17:     5    May\n18:     6    Jun\n19:     7    Jul\n20:     8    Aug\n21:     9    Sep\n22:    10    Oct\n23:    11    Nov\n24:    12    Dec\n        a      b\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}