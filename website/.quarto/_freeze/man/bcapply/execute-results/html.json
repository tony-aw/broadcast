{
  "hash": "abae89ffa03f61caa2414d895c06f8fe",
  "result": {
    "markdown": "---\ntitle: bcapply\n---\n\n## Apply a Function to 2 Broadcasted Arrays {.unnumbered}\n\n\n### Description\n\nThe <code>bcapply()</code> function\napplies a function to 2 arrays with broadcasting. <br />\n\n\n\n### Usage\n\n<pre><code class='language-R'>bcapply(x, y, f, v = \"list\")\n</code></pre>\n\n\n### Arguments\n\n<table>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"x\">x</code>, <code id=\"y\">y</code></td>\n<td>\nconformable atomic or recursive arrays.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"f\">f</code></td>\n<td>\na function that takes in exactly <b>2</b> arguments,\nand <b>returns</b> a result\nthat can be stored in a single element of a recursive or atomic array.\n</td></tr>\n<tr><td style = \"white-space: collapse; font-family: monospace; vertical-align: top\"><code id=\"v\">v</code></td>\n<td>\na single string, giving the scalar type for a single iteration. <br />\nIf <code>NULL</code> or <code>\"list\"</code> (default), the result will be a recursive array. <br />\nIf it is certain that, for every iteration,\n<code>f()</code> always results in a <b>single atomic scalar</b>,\nthe user can specify the type in <code>v</code> to pre-allocate the result. <br />\nPre-allocating the results leads to slightly faster and more memory efficient code. <br />\nNOTE: Incorrectly specifying <code>v</code> leads to undefined behaviour. <br />\n</td></tr>\n</table>\n\n\n### Value\n\nAn atomic or recursive array with dimensions <code>bc_dim(x, y)</code>. <br />\n\n\n\n### Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"broadcast\")\n\nx.dim <- c(c(10, 2,2))\nx.len <- prod(x.dim)\n\ngen <- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx <- array(gen(10), x.dim)\ny <- array(gen(10), c(10,1,1))\n\nf <- function(x, y) list(x, y)\nbcapply(x, y, f)\n## , , 1\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n## \n## , , 2\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}