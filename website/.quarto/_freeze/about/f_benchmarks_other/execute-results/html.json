{
  "hash": "c30a89aac53d92d8ac5639a3378efdcc",
  "result": {
    "markdown": "---\ntitle: \"Other benchmarks\"\nformat: html\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n# Introduction\n\nThis page benchmarks some of the functions from 'broadcast' with some near-equivalent functions from other packages. The code is given here also.\n\n&nbsp;\n\n# `abind::abind()`\n\nIn this section, te performance of the [bind_array()](/man/bind_array.qmd) function from 'broadcast' is compared to the performance of the `abind()` function from the 'abind' package.\n\n&nbsp;\n\nThe following code was used:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 110L\nnms <- function(n) sample(letters, n, TRUE)\nx <- array(as.double(1:25), c(n, n, n))\ny <- array(as.double(-1:-25), c(n, n, n))\ndimnames(x) <- lapply(dim(x), nms)\ndimnames(y) <- lapply(dim(y), nms)\ninput <- list(x, y, x)\n\ngc()\nbm_abind <- bench::mark(\n  abind = abind::abind(input, along = 2),\n  broadcast = bind_array(input, 2),\n  min_iterations = 100,\n  check = FALSE # because abind adds empty dimnames\n)\nsummary(bm_abind)\nplot(bm_abind)\n\n```\n:::\n\n\nAnd here are the results:\n\n\n::: {.cell}\n\n```\n#> # A data frame: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 abind        43.3ms   43.3ms      23.1   121.9MB    2821.\n#> 2 broadcast    19.3ms     20ms      48.1    91.4MB     131.\n#> Loading required namespace: tidyr\n```\n\n::: {.cell-output-display}\n![](f_benchmarks_other_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n\nClearly, the [bind_array()](/man/bind_array.qmd) implementation from 'broadcast' is about 2 times faster than the implementation from the 'abind' package. It is also about 1.5 times more memory efficient.\n\n&nbsp;\n\n# `Rfast::Outer()`\n\nAn outer computation is a special case of broadcasting, namely broadcasting between a row vector and a column vector (or vice-versa). The `outer()` function from base 'R' is too slow and consumes too much memory to provide any meaningful benchmark. But the 'Rfast' package provides a very fast implementation of the `outer()` function. It may be interesting how broadcasted operations hold up to the famously fast 'Rfast' package.\n\nHere the outer-sum between a column-vector `x` and row-vector `y` is computed using `Rfast::outer()` and `broadcast::bc.num()`, and their speeds and memory consumption are compared.\n\nThe following code was used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nn <- 1e4\nx <- array(rnorm(10), c(n, 1))\ny <- array(rnorm(10), c(1, n))\ngc()\nbm_outer <- bench::mark(\n  Rfast = Rfast::Outer(x, y, \"+\"),\n  broadcast = bc.num(x, y, \"+\"),\n  min_iterations = 100,\n  check = FALSE # because Rfast flips the dimensions of the results\n)\nsummary(bm_outer)\nplot(bm_outer)\n\n```\n:::\n\n\nAnd here are the results:\n\n\n::: {.cell}\n\n```\n#> # A tibble: 2 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 Rfast         124ms    131ms      7.50     763MB     2.50\n#> 2 broadcast     123ms    133ms      7.43     763MB     2.48\n```\n\n::: {.cell-output-display}\n![](f_benchmarks_other_files/figure-html/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\n\n\nIt seems that the implementations of 'broadcast' and the blazingly fast 'Rfast' package reach similar speeds and use the same amount of memory.\n\nNote, however, that `Rfast::Outer()` unfortunately only supports numeric vectors, and does not provide higher-dimensional broadcasting. 'broadcast', on the other hand, supports all atomic types as well as the `list` recursive type, and supports arrays of any dimensions up to 16 dimensions.\n\n&nbsp;\n\n\n",
    "supporting": [
      "f_benchmarks_other_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}