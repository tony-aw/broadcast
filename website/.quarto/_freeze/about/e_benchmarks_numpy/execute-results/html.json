{
  "hash": "3aa581531e8eecf465dbdb9b594329b5",
  "result": {
    "markdown": "---\ntitle: \"Benchmarks with Numpy\"\nformat: html\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n# Introduction\n\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions replication mechanism.\n\nBefore the emergence of the 'broadcast' package, if `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} users wished to employ broadcasting, they essentially had to use broadcasting as it existed in a different programming language. For example, they might use the broadcasting as available in the 'Python' module 'Numpy' (perhaps via the 'reticulate' package). Or perhaps they might use the 'C++' library 'xtensor' via the R-package of the same name (or an extension thereof, like 'rray').\n\nWith the emergence of the 'broadcast' `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} package, users can now call broadcasted implementations without using external libraries, which spares the computing power needed for translating between object structures of different languages.\n\nThe \"broadcasting\" implementation in the 'broadcast' package is conceptually (though not programmatically) inspired by the broadcasting employed by the 'Numpy' module for 'Python', which might be the first implementation of broadcasting. More importantly, 'Numpy' is remarkably fast, and the 'broadcast' `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} package aims to be somewhat comparably fast.  \n\nThis page presents the comparisons in the speed of broadcasted operations, between 'broadcast' and 'Numpy'. The operation that is compared is a simple, element-wise, broadcasted addition, given by the code `x + y` in the 'Numpy' module for 'Python', and `bc.num(x, y, \"+\")` in the 'broadcast' `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} package.\n\nPlease bear in mind these are rough comparisons of speed. Since the comparisons involve 2 separate programming languages, `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} and 'Python', \"proper\" speed comparison is rather difficult to do fairly.\n\n&nbsp;\n\n\n# Methodology\n\n## Difficulties in comparing `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} with 'Python'\n\nBenchmarking a 'Python' code snippet in 'Python' using a 'Python' module, and benchmarking an `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} code snippet in `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} using an `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} package, means mechanisms from different modules/packages are used for the benchmarking, and those 2 benchmarks may not (and probably won't) use the same timing mechanisms.\n\n'Python' and `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} are both languages that use garbage collections (GC). But GC really does mess up benchmarking. The way to circumvent this issue differs in 'Python' and `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}. In 'Python', GC can temporarily be disabled. `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} does not support this, so instead for `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} benchmarks with heavy GC calls just had to be filtered out.\n\nDue to the above (and other) considerations, any form of benchmarks between `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} and 'Python' - including the ones given in this page - should be taken with a grain of salt.\n\n\n&nbsp;\n\n## The Set-Up\n\nThe operation that was bench-marked in this study, is the operation `x + y` in 'Numpy' and the equivalent `bc. num(x, y, \"+\")` in 'broadcast'.  \nHere `x` and `y` were both decimal numeric arrays (type of 64 bit `double` in `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} and 64 bit `float` in 'Python'), and had the same number of dimensions.  \nThis operation was run for pairs of arrays with different number of dimensions, going from 2 dimensional to 7 dimensional.  \nSo we have `x + y` where both arrays were 2-dimensional (i.e. matrices), and `x + y` where both arrays were 3-dimensional, and so on up to 7-dimensional arrays.  \n\nThe pairs of arrays are fully orthogonal (\"orthogonal\" in the sense as explained [here](/vignettes/d_broadcasting_explained.qmd)), thus the maximum amount of broadcasting will be employed.  \nGiven, for example, 4-dimensional arrays, the dimensions of `x` are `(n, 1, n, 1)` and the dimensions of `y` are `(1, n, 1, n)`.  \nThe value of `n`, so the size of each dimension, varied as follows: \n\n - For 2-dimensional arrays, `n` goes from 1250 to 9500, with step size 750.\n - For 3-dimensional arrays, `n` goes from 65 to 450, with step size 35.\n - For 4-dimensional arrays, `n` goes from 9 to 99, with step size 10.\n - For 5-dimensional arrays, `n` goes from 6 to 39, with step size 3.\n - For 6-dimensional arrays, `n` goes from 3 to 21, with step size 2.\n - For 7-dimensional arrays, `n` goes from 2 to 14, with step size 1.\n\nThese values `n` were chosen as follows. The maximum `n` was specified such that the broadcasted element-wise addition of `x` and `y` resulted in an array with between 90 to 100 million elements. The minimum `n` was chosen to be (approximately) one-seventh of the maximum `n` value. And the step size was set to a value such that the sequence had a length between 10 and 15\n\nFor each pair of arrays, the element-wise addition was computed using 'broadcast' and 'Numpy'. This computation was repeated 100 times (though see some technical details about this in the next sub-section). From these 100 benchmarks, the median, first quartile, and third quartiles were computed. There are some caveats here, in order to keep the comparisons between 'broadcast' and 'Numpy' fair, and these caveats are explained in the next sub-section.\n\n&nbsp;\n\n## Keeping comparisons (somewhat) fair\n\nTo keep the comparisons between 'broadcast' and 'Numpy' fair, a number of measures have been taken.\n\n\nDistributions of benchmarks tend to be heavily skewed. Therefore, the median measure (together with the quartiles) were taken. The median is also more stable than the mean in the face of outliers.\n\n\nGarbage collection was disabled in Python. In `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}, only benchmarks with no garbage collection, or level 0 garbage collection, were used. I feel this keeps the comparisons relatively fair (but it's not perfect).\n\n\nSince only benchmarks with no garbage collection, or level 0 garbage collection, are used for `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}, the benchmarks were run 200 times, and a check was performed that at least 100 benchmark measurements were kept in. If there were less than 100 benchmarks for a particular computation, the benchmarks would be thrown away, and another attempt would be made at benchmarking (but this never happened).\n\n\n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} has more support for missing values than 'Numpy', which also leads to a difference in speed. But both `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} and 'Numpy' handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} ), through the `NaN` construct. Therefore, only operations on decimal numbers are compared.\n\n\nOperations like power (`^`) and division (`/`) need to handle special cases (like when the right-hand side of the operation is 0). I cannot guarantee that 'broadcast' and 'Numpy' will handle these special cases in the exact same way. The plus (`+`) operator, however, has no such special cases. Therefore, the comparisons on this page only involve summation.\n\n&nbsp;\n\n## Resources and Code\n\nThe 'benchmark' package was used for measuring speed in `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}, as this package can also be used to check and filter for garbage collector calls.\n\nIn 'Python', the `time.perf_counter()` function was used to accurately measure the time an operation takes. To ensure no time was wasted on printing the result in 'Python', the operation `a + b` was wrapped inside a function without a return statement.\n\nThe figures in the Results section were created using the 'tinyplot' package, to display the median, first quartile, and third quartile, of the computation times.\n\nThe benchmarks were all run on the same computer (processor: 12th Gen Intel(R) Core(TM) i5-12500H @ 2.50 GHz) with 32GB of Ram and running the Windows 11 OS (64 bit).\n\nThe code used to run the benchmarks can be found at the bottom of this page. `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} version 4.4.0 was used to run the `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} code, and 'Python' version 3.12.0 with 'Numpy' version 2.2.1 was used to run the 'Python' code.\n\nThe `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} code was sourced from the 'RGui', from a freshly started computer. The 'Python' code was run via 'Jupyter', also from a freshly started computer. This is to ensure that neither code was slowed down due to prior RAM usage or background processes.\n\n&nbsp;\n\n# Results\n\n&nbsp;\n\n::: {.panel-tabset}\n\n\n::: {.cell}\n\n:::\n\n\n\n## 2d arrays\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 1: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 2 - dimensional arrays. <br>The dimensions of `x` are {n, 1}; <br>the dimensions of `y` are {1, n}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n## 3d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 2: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 3 - dimensional arrays. <br>The dimensions of `x` are {n, 1, n}; <br>the dimensions of `y` are {1, n, 1}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n## 4d arrays\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 3: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 4 - dimensional arrays. <br>The dimensions of `x` are {n, 1, n, 1}; <br>the dimensions of `y` are {1, n, 1, n}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n## 5d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 4: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 5 - dimensional arrays. <br>The dimensions of `x` are {n, 1, n, 1, n}; <br>the dimensions of `y` are {1, n, 1, n, 1}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n\n## 6d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 5: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 6 - dimensional arrays. <br>The dimensions of `x` are {n, 1, n, 1, n, 1}; <br>the dimensions of `y` are {1, n, 1, n, 1, n}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n## 7d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Figure 6: Benchmarks of the element-wise broadcasted addition of 2 decimal numeric arrays,\n    comparing the code `x + y` in the 'Numpy' 'Python'-module,\n    against the code `bc.num(x, y,\"+\")` in the 'broadcast' 'R'-package. <br>Both arrays are 7 - dimensional arrays. <br>The dimensions of `x` are {n, 1, n, 1, n, 1, n}; <br>the dimensions of `y` are {1, n, 1, n, 1, n, 1}. <br>Here, `n` is shown on the x-axis. <br>The y-axis shows the time (in ms) it took to run the code. The solid line gives the median time, and the shaded ribbon gives the first and third quartiles. The higher a value is on the y-axis, the more time it takes to run the code, the slower the code.](e_benchmarks_numpy_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n\n&nbsp;\n\n:::\n\n&nbsp;\n\n# Conclusion & Discussion\n\nIt appears that 'broadcast' is slightly faster than 'Numpy', though the differences in the computation times between 'broadcast' and 'Numpy' are rather small. It seems reasonable to conclude that, in general, 'broadcast' and 'Numpy' have somewhat similar speeds. It can also be observed that 'broadcast' has a bit more spread in its computation time than 'Numpy'.\n\n&nbsp;\n\nAs stated earlier, comparing benchmarks between 'R' and 'Python' should be taken with a grain of salt. I am open for suggestions on how to improve the computation time comparisons between 'broadcast' and 'Numpy', and make them more fair (so feel free to post suggestions on the GitHub Discussions page).\n\n\n&nbsp;\n\n# The code\n\n::: {.panel-tabset}\n\n## R code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set-up ====\nlibrary(broadcast)\nget_times <- function(obj, j) {\n  nms <- names(res$expression)\n  j <- which(nms == j)\n  idx <- rowSums(obj$gc[[j]][, 2:3]) == 0\n  times <- obj$time[[j]][idx]\n  return(times)\n}\n\n\n# loop 2d ====\ngc()\ndimsizes <- seq(1250L, 9500L,  by = 750L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- c(n, 1L)\n  y.dims <- c(1L, n)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_2d.RData\"\n)\n\n\n\n# loop 3d ====\ngc()\ndimsizes <- seq(65L, 450L,  by = 35L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 2)[1:3]\n  y.dims <- rep(c(1L, n), 2)[1:3]\n\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  \n  \n  counter <- counter + 1L\n}\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_3d.RData\"\n)\n\n\n# loop 4d ====\ngc()\ndimsizes <- seq(9L, 99L,  by = 10L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 2)[1:4]\n  y.dims <- rep(c(1L, n), 2)[1:4]\n\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  \n  \n  counter <- counter + 1L\n}\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_4d.RData\"\n)\n\n\n\n\n# loop 5d ====\ngc()\ndimsizes <- seq(6L, 39L,  by = 3L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 3)[1:5]\n  y.dims <- rep(c(1L, n), 3)[1:5]\n\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  \n  \n  counter <- counter + 1L\n}\n\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_5d.RData\"\n)\n\n\n\n# loop 6d ====\ngc()\ndimsizes <- seq(3L, 21L,  by = 2L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 3)[1:6]\n  y.dims <- rep(c(1L, n), 3)[1:6]\n\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  \n  \n  counter <- counter + 1L\n}\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_6d.RData\"\n)\n\n\n# loop 7d ====\ngc()\ndimsizes <- seq(2L, 14L,  by = 1L)\nprint(dimsizes)\nniter <- length(dimsizes)\nmedian_bc <- q1_bc <- q3_bc <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 4)[1:7]\n  y.dims <- rep(c(1L, n), 4)[1:7]\n\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  \n  median_bc[counter] <- median(bc_all)\n  \n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  \n  \n  \n  counter <- counter + 1L\n}\n\n\nmedian_bc <- median_bc * 1000\nq1_bc <- q1_bc * 1000\nq3_bc <- q3_bc * 1000\n\nsave(\n  dimsizes, median_bc, q1_bc, q3_bc,\n  file = \"benchmarks/bm_bc_7d.RData\"\n)\ngc()\n\n```\n:::\n\n\n\n## Python code\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# set-up #\nimport numpy as np\nimport gc\nfrom time import perf_counter\ndef myfunc(a, b):\n  a + b\n\n# end set-up #\n\n\n# 2d array #\ngc.disable()\ndimsizes = np.arange(1250, 9501, 750)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1)\n  bdims = (1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_2d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_2d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_2d_q3.txt\", q3_np)\n# end 2d array #\n\n\n\n# 3d array #\ngc.disable()\ndimsizes = np.arange(65, 451, 35)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n)\n  bdims = (1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_3d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_3d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_3d_q3.txt\", q3_np)\n# end 3d array #\n\n\n\n\n# 4d array #\ngc.disable()\ndimsizes = np.arange(9, 100, 10)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1)\n  bdims = (1, n, 1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_4d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_4d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_4d_q3.txt\", q3_np)\n# end 4d array #\n\n\n# 5d array #\ngc.disable()\ndimsizes = np.arange(6, 40, 3)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n)\n  bdims = (1, n, 1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_5d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_5d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_5d_q3.txt\", q3_np)\n# end 5d array #\n\n\n\n\n# 6d array #\ngc.disable()\ndimsizes = np.arange(3, 22, 2)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n, 1)\n  bdims = (1, n, 1, n, 1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_6d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_6d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_6d_q3.txt\", q3_np)\n# end 5d array #\n\n\n\n# 7d array #\ngc.disable()\ndimsizes = np.arange(2, 15, 1)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n, 1, n)\n  bdims = (1, n, 1, n, 1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_7d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_7d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_7d_q3.txt\", q3_np)\n# end 7d array #\n\n```\n:::\n\n\n:::\n\n\n&nbsp;\n",
    "supporting": [
      "e_benchmarks_numpy_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}