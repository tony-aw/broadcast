{
  "hash": "224f550a6e522c9315323a1b93f2bd00",
  "result": {
    "markdown": "---\ntitle: \"Benchmarks with Numpy+reticulate\"\nformat: html\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n# Introduction\n\nOn this page the speed of computing the outer sum of 2 fully orthogonal arrays is compared across 2 workflows:\n\n - The workflow using 'broadcast'\n - The workflow using 'reticulate' + 'Numpy', though without the time- and memory consuming translations between `fa(\"r-project\")` and `Python` objects.\n\n\n&nbsp;\n\n\n# Methodology\n\n\n## The Set-Up\n\nThe benchmarks are run for multiple dimensionalities, and multiple dimension sizes.\n\nFor each combination of dimensionality and dimension size, pairs of decimal number arrays are created in both 'R' and 'Numpy'.  These pairs of arrays are fully orthogonal, thus the maximum amount of broadcasting will be employed.\n\nFor each pair of array the outer sum is computed using 'broadcast' and 'Numpy'. This computation is repeated 200 times. From these 200 benchmarks, the median, first quartile, and third quartiles are taken. There are some caveats here, in order to keep the comparisons between 'broadcast' and 'reticulate' + 'Numpy' fair, and these caveats are explained in the next sub-section.\n\n\n\n&nbsp;\n\n\n## Keeping comparisons fair\n\nTo keep the comparisons between 'broadcast' and 'Numpy'+'reticulate' fair, a number of measures have been taken:\n \n - Distributions of benchmarks tend to be heavily skewed. Therefore, the median measure (together with the quartiles) are taken.\n - conversion from Numpy to 'R' is DISABLED; this allows for comparing the speed more fairly. When conversion would be enabled, precious time would be wasted to convert from Numpy structures to comparable 'R' structures.\n - garbage collection is disabled in reticulate's Python. In `fa(\"r-project\")`, only benchmarks with no garbage collection, or level 0 garbage collection, are used. I feel this keeps the comparisons relatively fair (but it's not perfect).\n - Since only benchmarks with no garbage collection, or level 0 garbage collection, are used for `fa(\"r-project\")`, a check is made that at least 100 benchmark measurements are kept in (out 200 in total). Note that the median value \n - 'R' has more support for missing values than 'Numpy', which also leads to a difference in speed. But both 'R' and 'Numpy' handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in 'R' ), through the `NaN` construct. Therefore, only operations on decimal numbers are compared.\n - Operations like power (`^`) and division (`/`) need to handle special cases (like when the right-hand side of the operation is 0). I cannot guarantee that 'broadcast' and 'Numpy' will handle these special cases in the exact same way. The plus (`+`) operator, however, has no such special cases. Therefore, the comparisons on this page involve only summation.\n\n\n&nbsp;\n\n## Resources used\n\nThe 'benchmark' package was used for measuring speed, as this package can also be used to check and filter for garbage collector calls.\n\nThe plots are created using the 'tinyplot' package, to display the median, first quartile, and third quartile, of the computation times.\n\nThe code can be found at the end of this guide.\n\n&nbsp;\n\n# Results\n\n&nbsp;\n\n## 2d arrays\n\nUsing {tinyplot}, the median, first quartile, and third quartile of the bench-marked computation times are presented in the following graph:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-2-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n## 3d arrays\n\nUsing {tinyplot}, the median, first quartile, and third quartile of the bench-marked computation times are presented in the following graph:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n## 4d arrays\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n## 5d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n\n\n## 6d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n\n## 7d arrays\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](f_benchmarks_numpy_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n\n&nbsp;\n\n# Conclusion\n\nThe differences are rather small, however, and one can say in general that 'broadcast' and 'Numpy' have somewhat similar speeds.\n\n\n&nbsp;\n\n# The code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n\n# set-up ====\nlibrary(broadcast)\nlibrary(reticulate)\nnp <- import(\"numpy\", convert = FALSE)\ngc <- import(\"gc\", convert = FALSE)\ngc$disable()\nget_times <- function(obj, j) {\n  nms <- names(res$expression)\n  j <- which(nms == j)\n  idx <- rowSums(obj$gc[[j]][, 2:3]) == 0\n  times <- obj$time[[j]][idx]\n  return(times)\n}\n\n\n# loop 2d ====\ngc()\ndimsizes <- seq(1000L, 3000L,  by = 200L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- c(n, 1L)\n  y.dims <- c(1L, n)\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_2d.RData\"\n)\n\n\n\n# loop 3d ====\ngc()\ndimsizes <- seq(20L, 150L,  by = 10L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 2)[1:3]\n  y.dims <- rep(c(1L, n), 2)[1:3]\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_3d.RData\"\n)\n\n\n# loop 4d ====\ngc()\ndimsizes <- seq(10L, 55L,  by = 5L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 2)[1:4]\n  y.dims <- rep(c(1L, n), 2)[1:4]\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_4d.RData\"\n)\n\n\n\n\n# loop 5d ====\ngc()\ndimsizes <- seq(5L, 25L,  by = 5L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 3)[1:5]\n  y.dims <- rep(c(1L, n), 3)[1:5]\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_5d.RData\"\n)\n\n\n\n# loop 6d ====\ngc()\ndimsizes <- seq(1L, 15L,  by = 2L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 3)[1:6]\n  y.dims <- rep(c(1L, n), 3)[1:6]\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_6d.RData\"\n)\n\n\n# loop 7d ====\ngc()\ndimsizes <- seq(1L, 10L,  by = 1L)\nniter <- length(dimsizes)\nmedian_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector(\"numeric\", niter)\ncounter <- 1L\n\nfor(i in seq_along(dimsizes)) {\n  print(i)\n  n <- dimsizes[i]\n  x.dims <- rep(c(n, 1L), 4)[1:7]\n  y.dims <- rep(c(1L, n), 4)[1:7]\n  a.dims <- r_to_py(as.list(x.dims))\n  b.dims <- r_to_py(as.list(y.dims))\n  \n  npa <- np$random$random_sample(a.dims)\n  npb <- np$random$random_sample(b.dims)\n  a <- array(runif(100), x.dims)\n  b <- array(runif(100), y.dims)\n  \n  res <- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 200\n  )\n  bc_all <- get_times(res, \"broadcast\")\n  if(length(bc_all) < 100) {\n    stop(\"too few benchmarks for 'R'\")\n  }\n  np_all <- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] <- median(bc_all)\n  median_np[counter] <- median(np_all)\n  q1_bc[counter] <- quantile(bc_all, 0.25)\n  q3_bc[counter] <- quantile(bc_all, 0.75)\n  q1_np[counter] <- quantile(np_all, 0.25)\n  q3_np[counter] <- quantile(np_all, 0.75)\n  \n  counter <- counter + 1L\n}\n\n\n\n\nsave(\n  dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,\n  file = \"bm_numpy_loop_7d.RData\"\n)\n\n```\n:::\n\n\n\n&nbsp;\n\n&nbsp;\n",
    "supporting": [
      "f_benchmarks_numpy_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}