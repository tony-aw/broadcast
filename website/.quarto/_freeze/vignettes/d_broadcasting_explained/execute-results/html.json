{
  "hash": "6056ab86dc598ce620c7b1748e41852e",
  "result": {
    "markdown": "---\ntitle: \"Broadcasting Explained\"\nformat:\n  html:\n    number-sections: true\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n# Introduction\n\nIn the context of operations involving 2 (or more) arrays, \"broadcasting\" refers to recycling array dimensions **without** allocating additional memory or making needles copies. This is considerably **faster** and **more memory-efficient** than `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}'s regular dimensions repetition (and similar) mechanisms.\n\nThis page explains the concept of \"broadcasting\" in more detail.\nA good understanding of atomic and recursive arrays in base `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} is somewhat essential to follow this page.\n\n&nbsp;\n\n# What is broadcasting and why is it needed?\n\n## Example case\n\nLet's start with a simple example.  \nConsider the matrices `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:20, c(4, 5))\ny <- array(1:5*10, c(1, 5))\nprint(x)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nprint(y)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   10   20   30   40   50\n```\n:::\n\n\nSuppose one wishes to compute the element-wise addition of these 2 arrays.  \n\nThis won't work in base `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\nError in x + y : non-conformable arrays\n```\n:::\n\n\n\nWhen computing the element-wise sum of these arrays, one or both of them need to be recycled so that they are equal size, in order to compute the element-wise computation.\n\nIn this case, matrix `y` needs its single row to be recycled 4 times, making   `y` the same size as `x`, and thus conformable.  \n\n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} provides linear **vector** recycling, but not recycling of array dimensions. Instead, in base `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} we need to **replicate** (and thus **copy**) the array dimensions. This can be done manually, like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y[rep(1L, 4L),]\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   25   39   53   67\n#> [2,]   12   26   40   54   68\n#> [3,]   13   27   41   55   69\n#> [4,]   14   28   42   56   70\n```\n:::\n\n\n\n&nbsp;\n\n## What is the problem?\n\nThere are several problems.\n\nFirst and foremost, when the arrays become larger, the replicated arrays become larger, and if the arrays become too large, you may require more memory than is available in your current system, resulting in a message like the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> Error: cannot allocate vector of size\n```\n:::\n\n\n\nThe problem isn't limited to available memory. As the required memory to allocate increase, the speed decreases. And let's not forget that computational inefficiency in general is also bad for the environment.\n\nAdditionally, a solution like `x + y[rep(1L, 4L),]` is not easily scalable for other arrays when the dimensions of `x` and `y` are not known a-priori.\n\n&nbsp;\n\n## Introducing Broadcasting\n\nIn an operation like `x + y[rep(1L, 4L),]`, `y` is replicated to become the same size as `x`. The thing is, physical replication - and thus copying - of the dimensions of an array should not be necessary; arrays only need to be recycled virtually.  \n\nVirtual recycling does not actually physically replicate arrays. Instead, nested loops in 'C' and 'C++' are used to simulate a recycled array.  \nThis is similar to how `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} recycles regular (i.e. dimensionless) vectors.  \nVirtual recycling requires no additional memory (apart from allocating the final end result); it is much faster and much more memory efficient than replicating dimensions.\n\nAnd **that** is what broadcasting does: broadcasting provides **fast** virtual recycling of array dimensions in the context of element-wise operations involving 2 (or more) arrays **without** allocating additional memory. Broadcasting in this package is also scalable to arrays of any dimensions (up to 16 dimensions).\n\nIn the earlier example, we used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y[rep(1L, 4L),]\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   25   39   53   67\n#> [2,]   12   26   40   54   68\n#> [3,]   13   27   41   55   69\n#> [4,]   14   28   42   56   70\n```\n:::\n\n\nTo compute the element-wise addition using broadcasting through the 'broadcast' package, we can do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broadcast)\n\nbc.num(x, y, \"+\")\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   25   39   53   67\n#> [2,]   12   26   40   54   68\n#> [3,]   13   27   41   55   69\n#> [4,]   14   28   42   56   70\n```\n:::\n\n\nThe result is the same (as it should). But as the size of the resulting array increases, the broadcasted functions become more and more efficient in terms of both speed and memory, in comparison with base `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} approaches.  \n\nTechnically, one can also use `t(t(x) + drop(y))`, but that has a similar problem: one needs to perform transposition twice, which makes unnecessary copies, is slow, and is - again - not scalable to arrays where the dimensions are not known a-priori.\n\nBenchmarks can be found on the website.\n\n&nbsp;\n\n# Illustrating Broadcasting\n\n## Retracing the first example\n\nIn the previous example the following arrays were used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:20, c(4, 5))\ny <- array(1:5*10, c(1, 5))\n```\n:::\n\n\nLet's see what happens if we sum them together using broadcasting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbc.num(x, y, \"+\")\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   25   39   53   67\n#> [2,]   12   26   40   54   68\n#> [3,]   13   27   41   55   69\n#> [4,]   14   28   42   56   70\n```\n:::\n\n\nWhat happens here is that `x` remains the same, but row vector `y` is **virtually** recycled 4 times, but without requiring 4 times more memory. This is also illustrated here:\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_s02m5r9gmtcvpp2fxued(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_s02m5r9gmtcvpp2fxued\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_s02m5r9gmtcvpp2fxued');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_s02m5r9gmtcvpp2fxued(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_s02m5r9gmtcvpp2fxued\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 0, j: 0 }, { i: 1, j: 0 }, { i: 2, j: 0 }, { i: 3, j: 0 }, { i: 0, j: 1 }, { i: 1, j: 1 }, { i: 2, j: 1 }, { i: 3, j: 1 }, { i: 0, j: 2 }, { i: 1, j: 2 }, { i: 2, j: 2 }, { i: 3, j: 2 }, { i: 0, j: 3 }, { i: 1, j: 3 }, { i: 2, j: 3 }, { i: 3, j: 3 }, { i: 0, j: 4 }, { i: 1, j: 4 }, { i: 2, j: 4 }, { i: 3, j: 4 },  ], css_id: 'tinytable_css_3l9cfh8vamq0izzids66',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_s02m5r9gmtcvpp2fxued(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_3l9cfh8vamq0izzids66, .table th.tinytable_css_3l9cfh8vamq0izzids66 { border: solid black 0.1em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-bordered\" id=\"tinytable_s02m5r9gmtcvpp2fxued\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>x[1, 1] + y[1, 1]</td>\n                  <td>x[1, 2] + y[1, 2]</td>\n                  <td>x[1, 3] + y[1, 3]</td>\n                  <td>x[1, 4] + y[1, 4]</td>\n                  <td>x[1, 5] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[2, 1] + y[1, 1]</td>\n                  <td>x[2, 2] + y[1, 2]</td>\n                  <td>x[2, 3] + y[1, 3]</td>\n                  <td>x[2, 4] + y[1, 4]</td>\n                  <td>x[2, 5] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[3, 1] + y[1, 1]</td>\n                  <td>x[3, 2] + y[1, 2]</td>\n                  <td>x[3, 3] + y[1, 3]</td>\n                  <td>x[3, 4] + y[1, 4]</td>\n                  <td>x[3, 5] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[4, 1] + y[1, 1]</td>\n                  <td>x[4, 2] + y[1, 2]</td>\n                  <td>x[4, 3] + y[1, 3]</td>\n                  <td>x[4, 4] + y[1, 4]</td>\n                  <td>x[4, 5] + y[1, 5]</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n:::\n:::\n\n\n&nbsp;\n\n## Perpendicular vectors\n\nLet's now consider another scenario.\nWe not take again 2 matrices `x` and `y`, but `x` is a column vector (i.e. a matrix with 1 column and multiple rows), and `y` is a row vector (i.e. a matrix with 1 row and multiple columns):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:5, c(5, 1))\ny <- array(1:5 * 10, c(1, 5))\nprint(x)\n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\nprint(y)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   10   20   30   40   50\n```\n:::\n\n\n\nComputing the broadcasted element-wise sum of `x` and `y` produces the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbc.num(x, y, \"+\")\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   21   31   41   51\n#> [2,]   12   22   32   42   52\n#> [3,]   13   23   33   43   53\n#> [4,]   14   24   34   44   54\n#> [5,]   15   25   35   45   55\n```\n:::\n\n\n\nSo what exactly does broadcasting compute here?\n\nThe following table illustrates what broadcasting does, conceptually:\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_tl1fs1e7qsdtwhci8q3n(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_tl1fs1e7qsdtwhci8q3n\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_tl1fs1e7qsdtwhci8q3n');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tl1fs1e7qsdtwhci8q3n(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_tl1fs1e7qsdtwhci8q3n\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 0, j: 0 }, { i: 1, j: 0 }, { i: 2, j: 0 }, { i: 3, j: 0 }, { i: 4, j: 0 }, { i: 0, j: 1 }, { i: 1, j: 1 }, { i: 2, j: 1 }, { i: 3, j: 1 }, { i: 4, j: 1 }, { i: 0, j: 2 }, { i: 1, j: 2 }, { i: 2, j: 2 }, { i: 3, j: 2 }, { i: 4, j: 2 }, { i: 0, j: 3 }, { i: 1, j: 3 }, { i: 2, j: 3 }, { i: 3, j: 3 }, { i: 4, j: 3 }, { i: 0, j: 4 }, { i: 1, j: 4 }, { i: 2, j: 4 }, { i: 3, j: 4 }, { i: 4, j: 4 },  ], css_id: 'tinytable_css_s6lixpi9woq6vi3yqca5',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_tl1fs1e7qsdtwhci8q3n(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_s6lixpi9woq6vi3yqca5, .table th.tinytable_css_s6lixpi9woq6vi3yqca5 { border: solid black 0.1em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-bordered\" id=\"tinytable_tl1fs1e7qsdtwhci8q3n\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>x[1, 1] + y[1, 1]</td>\n                  <td>x[1, 1] + y[1, 2]</td>\n                  <td>x[1, 1] + y[1, 3]</td>\n                  <td>x[1, 1] + y[1, 4]</td>\n                  <td>x[1, 1] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[2, 1] + y[1, 1]</td>\n                  <td>x[2, 1] + y[1, 2]</td>\n                  <td>x[2, 1] + y[1, 3]</td>\n                  <td>x[2, 1] + y[1, 4]</td>\n                  <td>x[2, 1] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[3, 1] + y[1, 1]</td>\n                  <td>x[3, 1] + y[1, 2]</td>\n                  <td>x[3, 1] + y[1, 3]</td>\n                  <td>x[3, 1] + y[1, 4]</td>\n                  <td>x[3, 1] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[4, 1] + y[1, 1]</td>\n                  <td>x[4, 1] + y[1, 2]</td>\n                  <td>x[4, 1] + y[1, 3]</td>\n                  <td>x[4, 1] + y[1, 4]</td>\n                  <td>x[4, 1] + y[1, 5]</td>\n                </tr>\n                <tr>\n                  <td>x[5, 1] + y[1, 1]</td>\n                  <td>x[5, 1] + y[1, 2]</td>\n                  <td>x[5, 1] + y[1, 3]</td>\n                  <td>x[5, 1] + y[1, 4]</td>\n                  <td>x[5, 1] + y[1, 5]</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n:::\n:::\n\n\n&nbsp;\n\n\n# Broadcasting limitations and rules\n\nThe examples shown so far used matrices. But 'broadcast' is not restricted to only handling matrices; this package can handle any array, provided it does not have more than 16 dimensions.\nMoreover, any number of dimensions (provided <= 16) can be broadcasted simultaneously.\n\nThe examples show so far only used addition. But 'broadcast' supports a wide variety of binary operations, inlcuding relational-, arithmetic-, Boolean-, and string operations.\n\n\n&nbsp;\n\n## Normalization\n\nBefore broadcasting occurs, the number of dimensions of `x` and `y` are normalized, such that `ndim(x)` and `ndim(y)` are the same ( the `ndim(x)` function is the same as `length(dim(x))`).\n\nThis normalization achieved by appending dimensions of size 1 to the array with the smaller number of dimensions until both array have the same number of dimensions.\n\nFor example, if `dim(x) = c(3, 4, 3)` and `dim(y) = c(3, 4)`, then internally `dim(y)` is changed to `c(3, 4, 1)`.\n\n&nbsp;\n\n\n## Conformability\n\nBroadcasted operations only work when 2 arrays are conformable for broadcasting.  \n\nConsider again 2 arrays `x` and `y`, and their dimensions given by `dim(x)` and `dim(y)`, respectively.  \n'broadcast' goes through `dim(x)` and `dim(y)`, from left (i.e. first dimension / rows) to right (i.e. the last dimension), and checks for each axis `i` if **at least one** of the following conditions is TRUE:\n\n - `dim(x)[i]` and `dim(y)[i]` are equal;\n - either `dim(x)[i]` or `dim(y)[i]` is `1`;\n - either `dim(x)[i]` or `dim(y)[i]` is non-existing (see also the \"Normalization\" sub-section above)\n \nif at least one of the above conditions is true for each and every one of the dimensions of `x` and `y`, the 2 arrays are compatible for broadcasted operations. If not, they are not compatible, and attempting to perform a broadcasted operations results in an error.\n\n\nTo illustrate, let's check 2 arrays to see if they are compatible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 1))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_ntfuotpbclr4uokiotzq(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_ntfuotpbclr4uokiotzq\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_ntfuotpbclr4uokiotzq');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_ntfuotpbclr4uokiotzq(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_ntfuotpbclr4uokiotzq\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 4, j: 0 }, { i: 4, j: 1 }, { i: 4, j: 2 }, { i: 4, j: 3 },  ], css_id: 'tinytable_css_qjfgm216rw3bhuz2jrzf',}, \n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 }, { i: 0, j: 2 }, { i: 0, j: 3 },  ], css_id: 'tinytable_css_5uusnnzgmqwwdn78wtxo',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_ntfuotpbclr4uokiotzq(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_qjfgm216rw3bhuz2jrzf, .table th.tinytable_css_qjfgm216rw3bhuz2jrzf { border-bottom: solid #d3d8dc 0.1em; }\n      .table td.tinytable_css_5uusnnzgmqwwdn78wtxo, .table th.tinytable_css_5uusnnzgmqwwdn78wtxo { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_ntfuotpbclr4uokiotzq\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">dim(x)</th>\n                <th scope=\"col\">dim(y)</th>\n                <th scope=\"col\">compatible</th>\n                <th scope=\"col\">reason</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>10</td>\n                  <td>10</td>\n                  <td>TRUE</td>\n                  <td>equal</td>\n                </tr>\n                <tr>\n                  <td>1</td>\n                  <td>5</td>\n                  <td>TRUE</td>\n                  <td>either is 1</td>\n                </tr>\n                <tr>\n                  <td>9</td>\n                  <td>1</td>\n                  <td>TRUE</td>\n                  <td>either is 1</td>\n                </tr>\n                <tr>\n                  <td>6</td>\n                  <td>NA</td>\n                  <td>TRUE</td>\n                  <td>either is missing</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n:::\n:::\n\n\nAs shown in the data.frame above, all dimensions of `x` and `y` are compatible.  \nTherefore, broadcasted binary operations involving `x` and `y` can be performed.\n\n&nbsp;\n\nNow let's look at another 2 arrays, and see if they are compatible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(rnorm(10), c(10, 1, 9, 6))\ny <- array(rnorm(10), c(10, 5, 2))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_5lo5vget09dvr9nrnwgu(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_5lo5vget09dvr9nrnwgu\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_5lo5vget09dvr9nrnwgu');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_5lo5vget09dvr9nrnwgu(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_5lo5vget09dvr9nrnwgu\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 }, { i: 0, j: 2 }, { i: 0, j: 3 },  ], css_id: 'tinytable_css_uv9qgu6gufrrj8pgagss',}, \n          { positions: [ { i: 4, j: 0 }, { i: 4, j: 1 }, { i: 4, j: 2 }, { i: 4, j: 3 },  ], css_id: 'tinytable_css_0qk7fy33e6u7ef4vmf79',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_5lo5vget09dvr9nrnwgu(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_uv9qgu6gufrrj8pgagss, .table th.tinytable_css_uv9qgu6gufrrj8pgagss { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n      .table td.tinytable_css_0qk7fy33e6u7ef4vmf79, .table th.tinytable_css_0qk7fy33e6u7ef4vmf79 { border-bottom: solid #d3d8dc 0.1em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_5lo5vget09dvr9nrnwgu\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">dim(x)</th>\n                <th scope=\"col\">dim(y)</th>\n                <th scope=\"col\">compatible</th>\n                <th scope=\"col\">reason</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>10</td>\n                  <td>10</td>\n                  <td>TRUE</td>\n                  <td>equal</td>\n                </tr>\n                <tr>\n                  <td>1</td>\n                  <td>5</td>\n                  <td>TRUE</td>\n                  <td>either is 1</td>\n                </tr>\n                <tr>\n                  <td>9</td>\n                  <td>2</td>\n                  <td>FALSE</td>\n                  <td>not equal & neither is 1/missing</td>\n                </tr>\n                <tr>\n                  <td>6</td>\n                  <td>NA</td>\n                  <td>TRUE</td>\n                  <td>either is missing</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n:::\n:::\n\n\nOne of the dimensions, namely the third dimension, is not compatible. Therefore, these 2 arrays are **not** conformable for broadcasted operations.\n\n&nbsp;\n\n## Which dimensions are broadcasted\n\nIn the context of an operation involving exactly 2 arrays, this sub-section explains which dimensions of which array is broadcasted, and which dimension of which array is left as-is.  \nThere are 3 scenarios relevant for this explanation.\n\n&nbsp;\n\n**Scenario 1:**  \nFor some dimension `i`, `dim(x)[i]` and `dim(y)[i]` are equal.  \nIn this scenario, no broadcasting needs to occur on that dimension for either array.\n\n&nbsp;\n\n\n**Scenario 2:**  \nFor some dimension `i`, suppose `dim(x)[i] == 1` and `dim(y)[i] > 1`.  \nThen dimension `dim(x)[i]` is **broadcasted** to size `dim(y)[i]`.  \nSimilarly, if `dim(x)[i] > 1` and `dim(y)[i] == 1`, dimension `dim(y)[i]` is **broadcasted** to size `dim(x)[i]`.\n\n&nbsp;\n\n\n**Scenario 3:**  \nFinally, suppose for some dimension `i`, `dim(x)[i] > 1`, and `dim(y)[i]` is non-existing.  \nI.e., `x` has more dimensions than `y`.  \nIn this case, the missing dimension in `y` is replaced with a dimensions of size `1`, and scenario 2 is used.  \nSimilarly, if `dim(y)[i] > 1` and `dim(x)[i]` is non-existing, the missing dimension in `x` is replaced with a dimension of size `1` and we get back to scenario 2.  \n\nIt does not matter how much difference there is between the number of dimensions of `x` and the number of dimensions of `y`: any number of missing dimensions will be replaced with `1`, as long as the total number of dimensions for each array does not exceed `16`.\n\n&nbsp;\n\n**Illustration**\n\nTo illustrate, let's check 2 conformable arrays, and see which dimension of which array is broadcasted by how much\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(rnorm(10), c(10, 1, 1, 9, 6))\ny <- array(rnorm(10), c(10, 1, 5, 1))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_76egnay7ck2fvhbhe7k5(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_76egnay7ck2fvhbhe7k5\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_76egnay7ck2fvhbhe7k5');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_76egnay7ck2fvhbhe7k5(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_76egnay7ck2fvhbhe7k5\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 5, j: 0 }, { i: 5, j: 1 }, { i: 5, j: 2 }, { i: 5, j: 3 }, { i: 5, j: 4 }, { i: 5, j: 5 },  ], css_id: 'tinytable_css_wuzxqf7vfxn2x9302zwl',}, \n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 }, { i: 0, j: 2 }, { i: 0, j: 3 }, { i: 0, j: 4 }, { i: 0, j: 5 },  ], css_id: 'tinytable_css_s69j3uez8ifadvdzz6qe',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_76egnay7ck2fvhbhe7k5(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_wuzxqf7vfxn2x9302zwl, .table th.tinytable_css_wuzxqf7vfxn2x9302zwl { border-bottom: solid #d3d8dc 0.1em; }\n      .table td.tinytable_css_s69j3uez8ifadvdzz6qe, .table th.tinytable_css_s69j3uez8ifadvdzz6qe { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_76egnay7ck2fvhbhe7k5\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">i</th>\n                <th scope=\"col\">dim(x)</th>\n                <th scope=\"col\">dim(y)</th>\n                <th scope=\"col\">broadcasted</th>\n                <th scope=\"col\">reason</th>\n                <th scope=\"col\">note</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>1</td>\n                  <td>10</td>\n                  <td>10</td>\n                  <td>neither</td>\n                  <td>dims equal</td>\n                  <td></td>\n                </tr>\n                <tr>\n                  <td>2</td>\n                  <td>1</td>\n                  <td>1</td>\n                  <td>neither</td>\n                  <td>dims equal</td>\n                  <td></td>\n                </tr>\n                <tr>\n                  <td>3</td>\n                  <td>1</td>\n                  <td>5</td>\n                  <td>x</td>\n                  <td>dim(x)[i] == 1</td>\n                  <td>dim(x)[i] recycled to size 5</td>\n                </tr>\n                <tr>\n                  <td>4</td>\n                  <td>9</td>\n                  <td>1</td>\n                  <td>y</td>\n                  <td>dim(y)[i] == 1</td>\n                  <td>dim(y)[i] recycled to size 9</td>\n                </tr>\n                <tr>\n                  <td>5</td>\n                  <td>6</td>\n                  <td>NA</td>\n                  <td>y</td>\n                  <td>dim(y)[i] is missing</td>\n                  <td>dim(y) extended with a 1; dim(y)[i] recycled to size 6</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n:::\n:::\n\n\n\n&nbsp;\n\n# Orthogonal Arrays\n\nIn the documentation of 'broadcast', the reader may come across the term \"orthogonal arrays\" here and there.  \n\"orthogonal\" is a term that can mean a great many things; this section therefore explains what \"orthogonal\" means in the context of broadcasting.\n\nConsider a column-vector `x` and row-vector `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\nprint(x)\n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\nprint(y)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   10   20   30   40   50\n```\n:::\n\n\nThese vectors are (in a very literal sense) perpendicular to each other, and thus in that sense orthogonal to each other.  \nThis type of orthogonality can be extended to arrays as follows.  \nFor the purposes of broadcasting, any pair of arrays, `x` and `y`, can be referred to as being \"orthogonal\" if **all** of the following holds for that pair of arrays:  \n\n - For **every** dimension index `i`, `dim(x)[i] != dim(y)[i]`\n - For **every** dimensions index `i`,`dim(x)[i]` is `1` or missing, **OR** `dim(y)[i]` is `1` or missing.\n\n\nFor example, the following 2 arrays are orthogonal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(1, 9, 1, 9, 1, 11))\n\n```\n:::\n\n\nAnd the following 2 arrays are not orthogonal:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:10, c(10, 1, 8, 1, 10))\ny <- array(1:10, c(10, 9, 1, 9, 10))\n\n```\n:::\n\n\n\n&nbsp;\n\n\n# Broadcasting vs outer\n\nThe base `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} `outer()` function performs outer computations on vectors and arrays.\n\nEarlier in this guide, we used the following computation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:5, c(5, 1))\ny <- array(1:5*10, c(1, 5))\n\nbc.num(x, y, \"+\")\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   21   31   41   51\n#> [2,]   12   22   32   42   52\n#> [3,]   13   23   33   43   53\n#> [4,]   14   24   34   44   54\n#> [5,]   15   25   35   45   55\n```\n:::\n\n\n\nThis is equivalent to using the `outer()` function as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nouter(as.vector(x), as.vector(y), \"+\")\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   11   21   31   41   51\n#> [2,]   12   22   32   42   52\n#> [3,]   13   23   33   43   53\n#> [4,]   14   24   34   44   54\n#> [5,]   15   25   35   45   55\n```\n:::\n\n\n\nAs you can see, broadcasting 2 orthogonal vectors is equivalent to using `outer()` on 2 dimensionless vectors.\n\nThe `outer()` approach has the same problems as the `x[, rep(1L, 5L)] + y[rep(1L, 5L),]` approach: it consumes a lot of unnecessary memory, and is slow.\n\nBroadcasting can thus be used as a more efficient alternative to `outer()` in case of vector inputs, simply by making the inputs orthogonal. But please don't confuse outer computations with broadcasting: broadcasting is efficient array recycling for element-wise computations.\n\n&nbsp;\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}