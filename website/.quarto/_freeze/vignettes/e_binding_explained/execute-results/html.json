{
  "hash": "38a5a98acc5a83566197c2559e9c1b79",
  "result": {
    "markdown": "---\ntitle: \"Broadcasted Dimensional Binding Explained\"\nformat:\n  html:\n    number-sections: true\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n\n'broadcast' provides 3 dimensional binding implementations: [bind_mat()](/man/bind.qmd), [bind_array()](/man/bind.qmd), and [bind_dt()](/man/bind.qmd). The [bind_mat()](/man/bind.qmd) function supports vector recycling, but only [bind_array()](/man/bind.qmd) supports full broadcasting. This page explains some details on broadcasting that are specific to [bind_array()](/man/bind.qmd).\n\n\n&nbsp;\n\n\n[bind_array()](/man/bind.qmd) fully supports broadcasting. It's easy to reason about broadcasting when it involves only 2 arrays. But any more and it becomes more difficult. `bind_array()` supports binding any number of arrays simultaneously. Therefore, `bind_array()` comes with the `ndim2bc` argument (an abbreviation of \" maximum number of dimensions to broadcast\"), which allows users to specify the maximum number of dimensions that are allowed to be broadcasted while binding arrays. This way, users won't get unpleasant surprises.\n\nThis should be fairly obvious, but the dimension specified in `along` is never broadcasted.\n\n&nbsp;\n\nBy default, `ndim2bc` is set to `1`. This means that, by default, [bind_array()](/man/bind.qmd) will broadcast no more than 1 dimension for each array in the input list, when necessary.\n\nConsider the following arrays:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nx <- array(1:20, c(4, 5))\ny <- array(1:5*10, c(1, 5))\nprint(x)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nprint(y)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   10   20   30   40   50\n```\n:::\n\n\nBinding them together with `abind()` won't work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabind::abind(x, y, along = 2)\nError in abind::abind(x, y, along = 2) : \n  arg 'X2' has dims=1, 5; but need dims=4, X\n```\n:::\n\n\nTo bind `x` and `y` together along columns, `y` needs its single row to be recycled (broadcasted) 4 times.\n\nThis can be done in a highly efficient way using [bind_array()](/man/bind.qmd), like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n```\n:::\n\n\n&nbsp;\n\n\n\nBut what if broadcasting is explicitly **not** desired? What if one actually wants this to produce an error, like `abind()`? Fret not, for that's what the `ndim2bc` argument is for. Setting it to `0` will disable broadcasting altogether:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L, ndim2bc = 0)\nError in bind_array(list(x, y), 2L, ndim2bc = 0) : \n  maximum number of dimensions to be broadcasted (1) exceeds `ndim2bc` (0)\n```\n:::\n\n\n\n&nbsp;\n\n\nLet's replace `x` with a 3 dimensional array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:20, c(4, 5, 3))\nprint(x)\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n```\n:::\n\n\nTrying to bind `x` with `y` now will produce an error even with [bind_array()](/man/bind.qmd), to protect the user from unintended broadcasting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L)\nError in bind_array(list(x, y), 2L) : \n  maximum number of dimensions to be broadcasted (2) exceeds `ndim2bc` (1)\n```\n:::\n\n\nIf you know you actually do want to broadcast multiple dimensions, simply increase `ndim2bc`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L, ndim2bc = 3L)\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n```\n:::\n\n\n\n\n&nbsp;\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}