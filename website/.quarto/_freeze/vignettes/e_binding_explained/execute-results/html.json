{
  "hash": "e976f4dd72d91888e9a623c4f77039e5",
  "result": {
    "markdown": "---\ntitle: \"Broadcasted Dimensional Binding Explained\"\nformat:\n  html:\n    number-sections: true\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n\nThis page explains some details on broadcasting that are specific to the [bind_array()](/man/bind_array.qmd) function.\n\n\n&nbsp;\n\n\nThe [bind_array()](/man/bind_array.qmd) function binds 2 or more arrays together along a dimension, and fully supports broadcasting. While it's relatively easy to reason about broadcasting when it involves only 2 arrays, reasoning about broadcasting when it involves more than 2 arrays becomes a bit more difficult. Therefore, [bind_array()](/man/bind_array.qmd) comes with the `ndim2bc` argument (an abbreviation of \" maximum number of dimensions to broadcast\"), which allows users to specify the maximum number of dimensions that are allowed to be broadcasted while binding arrays. This way, users won't get unpleasant surprises.\n\nThis should be fairly obvious, but the dimension specified in `along` is never broadcasted.\n\n&nbsp;\n\nBy default, `ndim2bc` is set to `1`. This means that, by default, [bind_array()](/man/bind_array.qmd) will broadcast no more than 1 dimension for each array in the input list, when necessary.\n\nConsider the following arrays:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nx <- array(1:20, c(4, 5))\ny <- array(1:5*10, c(1, 5))\nprint(x)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\nprint(y)\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]   10   20   30   40   50\n```\n:::\n\n\nBinding them together with `abind()` won't work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabind::abind(x, y, along = 2)\nError in abind::abind(x, y, along = 2) : \n  arg 'X2' has dims=1, 5; but need dims=4, X\n```\n:::\n\n\nTo bind `x` and `y` together along columns, `y` needs its single row to be recycled (broadcasted) 4 times.\n\nThis can be done in a highly efficient way using [bind_array()](/man/bind_array.qmd), like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L)\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n```\n:::\n\n\n&nbsp;\n\n\n\nBut what if broadcasting is explicitly **not** desired? What if one actually wants this to produce an error, like `abind()`? Fret not, for that's what the `ndim2bc` argument is for. Setting it to `0` will disable broadcasting altogether:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L, ndim2bc = 0)\nError in bind_array(list(x, y), 2L, ndim2bc = 0) : \n  maximum number of dimensions to be broadcasted (1) exceeds `ndim2bc` (0)\n```\n:::\n\n\n\n&nbsp;\n\n\nLet's replace `x` with a 3 dimensional array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(1:20, c(4, 5, 3))\nprint(x)\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    5    9   13   17\n#> [2,]    2    6   10   14   18\n#> [3,]    3    7   11   15   19\n#> [4,]    4    8   12   16   20\n```\n:::\n\n\nTrying to bind `x` with `y` now will produce an error even with [bind_array()](/man/bind_array.qmd), to protect the user from unintended broadcasting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L)\nError in bind_array(list(x, y), 2L) : \n  maximum number of dimensions to be broadcasted (2) exceeds `ndim2bc` (1)\n```\n:::\n\n\nIf you know you actually do want to broadcast multiple dimensions, simply increase `ndim2bc`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_array(list(x, y), 2L, ndim2bc = 3L)\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n#> \n#> , , 3\n#> \n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    5    9   13   17   10   20   30   40    50\n#> [2,]    2    6   10   14   18   10   20   30   40    50\n#> [3,]    3    7   11   15   19   10   20   30   40    50\n#> [4,]    4    8   12   16   20   10   20   30   40    50\n```\n:::\n\n\n\n\n&nbsp;\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}