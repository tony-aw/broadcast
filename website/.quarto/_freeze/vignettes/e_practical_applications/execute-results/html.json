{
  "hash": "238182efd332bf5e9209f3cf1ae21a25",
  "result": {
    "markdown": "---\ntitle: \"Practical Applications\"\noutput:\n  rmarkdown::html_vignette:\n    toc: true\n    number_sections: true\nvignette: >\n  %\\VignetteIndexEntry{Practical Applications}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n&nbsp;\n\n# Introduction\n\nBroadcasting comes up frequent enough in real world problems. This articles gives a few examples of these.\n\n\n&nbsp;\n\n# Vector quantization\n\nThis first example is taken from Numpy's own documentation.\n\nThe basic operation in Vector Quantization (VQ) finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown below, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, codes[0] is the closest class indicating that the athlete is likely a basketball player.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nobservation <- array(c(111.0, 188.0), dim = c(1, 2))\ncodes <- array(\n  c(102.0, 203.0,\n    132.0, 193.0,\n    45.0, 155.0,\n    57.0, 173.0),\n  dim = c(4, 2)\n)\n\ndiff <- bc.num(codes, observation, \"-\")\ndist <- apply(diff^2, 2L, sum) |> sqrt()\nwhich.min(dist); dist[which.min(dist)]\n#> [1] 1\n#> [1] 125.3395\n```\n:::\n\n\n\n&nbsp;\n\n\n# Find most resembling string\n\nIf you have 2 vectors of strings, and you want to find which pair of strings (one string from each vector), you'll need to find the string distance of all possible combinations.\n\nThis can be done very fast and very conveniently with 'broadcast', using the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(month.name)\ny <- array(month.abb, c(1, 12))\n\nout <- bc.str(x, y, \"levenshtein\")\ndimnames(out) <- list(x, y)\nprint(out)\n#>           Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n#> January     4   7   5   6   5   5   5   6   7   7   7   7\n#> February    7   5   6   7   6   7   7   7   7   8   8   7\n#> March       4   5   2   4   3   5   5   5   5   4   5   4\n#> April       5   5   4   2   5   5   4   4   5   5   5   5\n#> May         2   3   1   3   0   3   3   3   3   3   3   3\n#> June        2   4   4   4   4   1   2   3   4   4   4   4\n#> July        3   4   4   4   3   2   1   3   4   4   4   4\n#> August      6   6   6   5   6   5   5   3   6   5   6   6\n#> September   9   7   8   7   9   9   9   9   6   8   9   8\n#> October     7   6   6   6   7   7   7   7   6   4   6   6\n#> November    8   6   7   7   8   8   8   8   7   8   5   7\n#> December    8   6   7   7   8   8   8   8   7   7   8   5\n```\n:::\n\n\n\n&nbsp;\n\n\n\n\n\n\n\n\n&nbsp;\n&nbsp;\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}