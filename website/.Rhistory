rd_links(filepath, outpath, funs)
}
## convert Rd to qmd ====
lst.files <- list.files(file.path("preprocess", "man"), pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("preprocess", "man", i)
temp_html <- stri_replace_last(i, ".html", fixed = ".Rd")
temp_html <- file.path("preprocess", "man", temp_html)
outpath <- file.path("website", "man")
rd2qmd(filepath, temp_html, outpath, pkgpath)
}
## adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
print(i)
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
## unpack links in man pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "man", i)
outpath <- file.path("website", "man")
qmd_extractlinks(filepath, outpath, funs)
}
################################################################################
# Process Vignettes, Index page, and GitHub Readme ====
#
# copy & render intro template ====
from <- "intro_template.qmd"
to <- file.path("website", "vignettes", "a_readme.qmd")
file.copy(from, to, overwrite = TRUE)
to <- "README.qmd"
file.copy(from, to, overwrite = TRUE)
gfm <- readLines("README.qmd")
gfm <- stri_replace_all(
gfm,
"'R'",
fixed = '`r fa("r-project")`'
)
writeLines(gfm, to)
quarto::quarto_render(to, "gfm", "README.md")
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
# copy readme vignette to index page ====
from <- file.path("website", "vignettes", "a_readme.qmd")
to <- file.path("website", "index.qmd")
file.copy(from, to, overwrite = TRUE)
################################################################################
# Process About pages ====
#
# create links in About pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "About"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "About", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "About", i))
}
# end of rd2qmd ====
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
quarto_render()
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
# set-up ====
library(stringi)
source("siteutils.R")
## pre-process Rds for linking ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
source("siteutils.R")
################################################################################
# Create man pages ====
#
## pre-process Rds for linking ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("man", i)
outpath <- file.path("preprocess", "man")
rd_links(filepath, outpath, funs)
}
## convert Rd to qmd ====
lst.files <- list.files(file.path("preprocess", "man"), pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("preprocess", "man", i)
temp_html <- stri_replace_last(i, ".html", fixed = ".Rd")
temp_html <- file.path("preprocess", "man", temp_html)
outpath <- file.path("website", "man")
rd2qmd(filepath, temp_html, outpath, pkgpath)
}
## adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
print(i)
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
## unpack links in man pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "man", i)
outpath <- file.path("website", "man")
qmd_extractlinks(filepath, outpath, funs)
}
################################################################################
# Process Vignettes, Index page, and GitHub Readme ====
#
# copy & render intro template ====
from <- "intro_template.qmd"
to <- file.path("website", "vignettes", "a_readme.qmd")
file.copy(from, to, overwrite = TRUE)
to <- "README.qmd"
file.copy(from, to, overwrite = TRUE)
gfm <- readLines("README.qmd")
gfm <- stri_replace_all(
gfm,
"'R'",
fixed = '`r fa("r-project")`'
)
writeLines(gfm, to)
quarto::quarto_render(to, "gfm", "README.md")
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
# copy readme vignette to index page ====
from <- file.path("website", "vignettes", "a_readme.qmd")
to <- file.path("website", "index.qmd")
file.copy(from, to, overwrite = TRUE)
################################################################################
# Process About pages ====
#
# create links in About pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "About"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "About", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "About", i))
}
# end of rd2qmd ====
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
quarto_render()
setwd("D:/D Desktop/Publications/R package broadcast")
sessionInfo()
# change script contents ===
file_find_replace <- function(filepath, pattern, replacement) {
file_contents <- readLines(filepath)
updated_contents <- stringi::stri_replace_all(
file_contents, fixed = pattern, replacement = replacement,
case_insensitive = TRUE, vectorize_all = FALSE
)
cat(updated_contents, file = filepath, sep = "\n")
}
my_r_scripts <- list.files(
path = file.path(getwd(), "/broadcast/website/vignettes/"), pattern = "qmd$",
recursive = TRUE, full.names = TRUE
)
print(my_r_scripts)
for (r_script in my_r_scripts ) {
file_find_replace(
r_script,
'bind.qmd',
'bind_array.qmd'
)
}
my_r_scripts <- list.files(
path = file.path(getwd(), "/broadcast/website/about/"), pattern = "qmd$",
recursive = TRUE, full.names = TRUE
)
print(my_r_scripts)
for (r_script in my_r_scripts ) {
file_find_replace(
r_script,
'bind.qmd',
'bind_array.qmd'
)
}
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
quarto_render()
# wait until render is done!
quarto_preview()
# creating the arrays:
x <- c(
lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
lapply(1:3, \(x)sample(1:10)),
lapply(1:3, \(x)rnorm(10)),
lapply(1:3, \(x)sample(letters))
) |> matrix(4, 3, byrow = TRUE)
dimnames(x) <- list(letters[1:4], LETTERS[1:3])
print(x)
y <- matrix(1:12, 4, 3)
print(y)
# column-binding:
bind_array(input, along = 2L)
library(broadcast)
# column-binding:
bind_array(input, along = 2L)
# column-binding:
input <- list(x = x, y = y)
bind_array(input, along = 2L)
# creating the arrays:
x <- c(
lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
lapply(1:3, \(x)sample(1:10)),
lapply(1:3, \(x)rnorm(10)),
lapply(1:3, \(x)sample(letters))
) |> matrix(4, 3, byrow = TRUE)
dimnames(x) <- list(letters[1:4], LETTERS[1:3])
print(x)
y <- matrix(1:12, 4, 3)
print(y)
z <- matrix(letters, c(4, 6))
z <- matrix(letters[1:24], c(4, 6))
# column-binding:
input <- list(x = x, y = y, z = z)
bind_array(input, along = 2L)
# Illustrating `along` argument ====
input <- list(y = y, z = z)
bind_array(input, along = 0L) # binds on new dimension before first
# Illustrating `along` argument ====
x <- matrix(1:12, 4, 6)
print(y)
# Illustrating `along` argument ====
x <- matrix(1:12, 4, 6)
print(x)
# Illustrating `along` argument ====
x <- matrix(1:24, 4, 6)
print(x)
z <- matrix(letters[1:24], c(4, 6))
# Illustrating `along` argument ====
x <- matrix(1:24, 4, 6)
z <- matrix(letters[1:24], c(4, 6))
input <- list(y = y, z = z)
bind_array(input, along = 0L) # binds on new dimension before first
# Illustrating `along` argument ====
x <- matrix(1:24, 4, 6)
z <- matrix(letters[1:24], c(4, 6))
input <- list(x = x, z = z)
bind_array(input, along = 0L) # binds on new dimension before first
bind_array(input, along = 1L) # binds on first dimension (i.e. rows)
bind_array(input, along = 2L)
# creating the arrays:
x <- c(
lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
lapply(1:3, \(x)sample(1:10)),
lapply(1:3, \(x)rnorm(10)),
lapply(1:3, \(x)sample(letters))
) |> matrix(4, 3, byrow = TRUE)
dimnames(x) <- list(letters[1:4], LETTERS[1:3])
print(x)
y <- matrix(1:12, 4, 3)
print(y)
z <- matrix(letters[1:12], c(4, 3))
# column-binding:
input <- list(x = x, y = y, z = z)
bind_array(input, along = 2L)
# Illustrating `along` argument ====
input <- list(x = x, z = z)
bind_array(input, along = 0L) # binds on new dimension before first
bind_array(input, along = 1L) # binds on first dimension (i.e. rows)
bind_array(input, along = 2L)
# Illustrating `along` argument ====
# using recursive arrays for clearer visual distinction
input <- list(x = x, y = y)
bind_array(input, along = 0L) # binds on new dimension before first
bind_array(input, along = 1L) # binds on first dimension (i.e. rows)
bind_array(input, along = 2L)
bind_array(input, along = 3L) # bind on new dimension after last
bind_array(input, along = 0L, TRUE) # binds on new dimension after last
bind_array(input, along = 1L, TRUE) # binds on last dimension (i.e. columns)
bind_array(input, along = 2L, TRUE)
bind_array(input, along = 3L, TRUE) # bind on new dimension before first
# binding, with empty arrays ====
emptyarray <- array(numeric(0L), c(0L, 3L))
dimnames(emptyarray) <- list(NULL, paste("empty", 1:3))
print(emptyarray)
input <- list(x = x, y = emptyarray)
bind_array(input, along = 1L, comnames_from = 2L) # row-bind
# Illustrating `name_along` ====
x <- array(1:20, c(5, 3), list(NULL, LETTERS[1:3]))
y <- array(-1:-20, c(5, 3))
z <- array(-1:-20, c(5, 3))
bind_array(list(a = x, b = y, z), 2L)
bind_array(list(x, y, z), 2L)
bind_array(list(a = unname(x), b = y, c = z), 2L)
bind_array(list(x, a = y, b = z), 2L)
input <- list(x, y, z)
names(input) <- c("", NA, "")
bind_array(input, 2L)
# Simple example ====
x <- array(1:20, c(5, 3), list(NULL, LETTERS[1:3]))
y <- array(-1:-20, c(5, 3))
z <- array(-1:-20, c(5, 3))
input <- list(x, y, z)
# column binding:
bind_array(input, 2L)
# creating the arrays:
x <- c(
lapply(1:3, \(x)sample(c(TRUE, FALSE, NA))),
lapply(1:3, \(x)sample(1:10)),
lapply(1:3, \(x)rnorm(10)),
lapply(1:3, \(x)sample(letters))
) |> matrix(4, 3, byrow = TRUE)
# Simple example ====
x <- array(1:20, c(5, 3), list(NULL, LETTERS[1:3]))
y <- array(-1:-20, c(5, 3))
z <- array(21:40, c(5, 3))
input <- list(x, y, z)
# column binding:
bind_array(input, 2L)
# Simple example ====
x <- array(1:20, c(5, 4), list(NULL, LETTERS[1:4]))
y <- array(-1:-15, c(5, 3))
z <- array(21:40, c(5, 4))
input <- list(x, y, z)
# column binding:
bind_array(input, 2L)
# Simple example ====
x <- array(1:20, c(5, 4))
y <- array(-1:-15, c(5, 3))
z <- array(21:40, c(5, 4))
input <- list(x, y, z)
# column binding:
bind_array(input, 2L)
y.data <- sample(c(-10:10, NA), 100, TRUE)
# and ====
nres <- 10 * 5 * 5 # number of tests performed here
expected <- out <- vector("list", nres)
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dims <- function(n) {
# make dimensions that are randomly of size 1 or 5:
out <- lapply(1:n, \(n)sample(c(1, 5), 1)) |> unlist()
# check if the dimensions produce a too large object.
# If so, replace one >1L dimension with 1L
if(prod(out) > 5000L) {
ind <- which(out > 1L)[1L]
out[ind] <- 1L
}
return(out)
}
.return_missing <- broadcast:::.return_missing
# and ====
nres <- 10 * 5 * 5 # number of tests performed here
expected <- out <- vector("list", nres)
x.data <- sample(c(-10:10, NA), 100, TRUE)
y.data <- sample(c(-10:10, NA), 100, TRUE)
i <- 1L
# and ====
nres <- 10 * 5 * 5 # number of tests performed here
expected <- out <- vector("list", nres)
x.data <- sample(c(-10:10, NA), 100, TRUE)
y.data <- sample(c(-10:10, NA), 100, TRUE)
i <- 1L
# and ====
nres <- 10 * 5 * 5 # number of tests performed here
expected <- out <- vector("list", nres)
x.data <- sample(c(-10:10, NA), 100, TRUE)
y.data <- sample(c(-10:10, NA), 100, TRUE)
i <- 1L
for(iSample in 1:10) { # re-do tests with different random configurations
for(iDimX in c(1, 2, 5, 8, 9)) { # different dimensions for x
x.dim <- test_make_dims(iDimX)
x.len <- prod(x.dim)
for(iDimY in c(1, 2, 5, 8, 9)) { # different dimensions for y
y.dim <- test_make_dims(iDimY)
y.len <- prod(y.dim)
x <- array(x.data[[iDataX]][1:x.len], dim = x.dim)
y <- array(y.data[[iDataY]][1:y.len], dim = y.dim)
expected[[i]] <- dim(bc.b(x, y, "&"))
out[[i]] <- bc_dim(x, y)
i <- i + 1L
}
}
}
i <- 1L
for(iSample in 1:10) { # re-do tests with different random configurations
for(iDimX in c(1, 2, 5, 8, 9)) { # different dimensions for x
x.dim <- test_make_dims(iDimX)
x.len <- prod(x.dim)
for(iDimY in c(1, 2, 5, 8, 9)) { # different dimensions for y
y.dim <- test_make_dims(iDimY)
y.len <- prod(y.dim)
x <- array(x.data[1:x.len], dim = x.dim)
y <- array(y.data[1:y.len], dim = y.dim)
expected[[i]] <- dim(bc.b(x, y, "&"))
out[[i]] <- bc_dim(x, y)
i <- i + 1L
}
}
}
enumerate <- enumerate + i # count number of tests
# test results:
expect_equal(
expected, out
)
library(tinytest)
# test results:
expect_equal(
expected, out
)
# set-up ====
enumerate <- 0L
errorfun <- function(tt) {
if(isTRUE(tt)) print(tt)
if(isFALSE(tt)) stop(print(tt))
}
test_make_dims <- function(n) {
# make dimensions that are randomly of size 1 or 5:
out <- lapply(1:n, \(n)sample(c(1, 5), 1)) |> unlist()
# check if the dimensions produce a too large object.
# If so, replace one >1L dimension with 1L
if(prod(out) > 5000L) {
ind <- which(out > 1L)[1L]
out[ind] <- 1L
}
return(out)
}
.return_missing <- broadcast:::.return_missing
# and ====
nres <- 10 * 5 * 5 # number of tests performed here
expected <- out <- vector("list", nres)
x.data <- sample(c(-10:10, NA), 100, TRUE)
y.data <- sample(c(-10:10, NA), 100, TRUE)
i <- 1L
for(iSample in 1:10) { # re-do tests with different random configurations
for(iDimX in c(1, 2, 5, 8, 9)) { # different dimensions for x
x.dim <- test_make_dims(iDimX)
x.len <- prod(x.dim)
for(iDimY in c(1, 2, 5, 8, 9)) { # different dimensions for y
y.dim <- test_make_dims(iDimY)
y.len <- prod(y.dim)
x <- array(x.data[1:x.len], dim = x.dim)
y <- array(y.data[1:y.len], dim = y.dim)
expected[[i]] <- dim(bc.b(x, y, "&"))
out[[i]] <- bc_dim(x, y)
i <- i + 1L
}
}
}
enumerate <- enumerate + i # count number of tests
# test results:
expect_equal(
expected, out
)
