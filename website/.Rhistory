R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
.rcpp_longint_test(1,0)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# Preview documentation ====
library(broadcast)
?bc.d
?install.packages("pkgdown")
library(altdoc)
sessionInfo()
library(quarto)
sessionInfo()
library(broadcast)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
# from the altdoc package:
.readlines <- function(x) {
readLines(x, warn = FALSE)
}
.rd2qmd <- function(source_file, target_dir, path) {
if (missing(source_file) || !file.exists(source_file)) {
stop("source_file must be a valid file path.", call. = FALSE)
}
if (missing(source_file) || !dir.exists(target_dir)) {
stop("target_dir must be a valid directory.", call. = FALSE)
}
# Rd -> html
rd <- tools::parse_Rd(source_file)
tmp_html <- paste0(tempfile(), ".html")
tools::Rd2HTML(rd, out = tmp_html)
# superfluous header and footer
tmp <- .readlines(tmp_html)
tmp <- tmp[(grep("</table>$", tmp)[1] + 1):length(tmp)]
tmp <- utils::head(tmp, -4)
# first column (odd entries) of table in Arguments should not be wrapped
idx <- grep("<td>", tmp)
idx <- idx[seq_along(idx) %% 2 == 1]
tmp[idx] <- sub(
"<td>",
'<td style = "white-space: collapse; font-family: monospace; vertical-align: top">',
tmp[idx]
)
# escape the $ in man pages otherwise it thinks it is a latex equation and
# doesn't escape symbols between two $.
tmp <- gsub("\\$", "\\\\$", tmp)
# process \doi{...} tags that were expanded to \Sexpr[results=rd]{tools:::Rd_expr_doi("...")}
tmp <- gsub(
"(\\\\Sexpr\\[results=rd\\]\\{tools:::Rd_expr_doi\\(\\\")([^\\\"]+)(\\\"\\)\\})",
"[doi:\\2](https://doi.org/\\2)",
tmp
)
# examples: evaluate code blocks (assume examples are always last)
pkg <- .pkg_name(path)
pkg_load <- paste0("library(\"", pkg, "\")")
idx <- which(tmp == "<h3>Examples</h3>")
if (length(idx) == 1) {
# until next section or the end
idx_post_examples <- grep("<h3>", tmp)
idx_post_examples <- idx_post_examples[idx_post_examples > idx]
if (length(idx_post_examples) > 0) {
ex <- tmp[(idx + 1):(idx_post_examples[1] - 1)]
} else {
ex <- tmp[(idx + 1):length(tmp)]
}
ex <- gsub("<.*>", "", ex)
ex <- gsub("&lt;", "<", ex)
ex <- gsub("&gt;", ">", ex)
ex <- gsub("&amp;", "&", ex)
ex <- gsub("\\$", "$", ex, fixed = TRUE)
ex <- ex[!grepl("## Not run:", ex)]
ex <- ex[!grepl("## End", ex)]
# respect \dontrun{} and \donttest{}. This is too aggressive because it
# ignores all tests whenever one of the two tags appear anywhere, but it
# would be very hard to parse different examples wrapped or not wrapped in a
# \donttest{}.
block_eval <- !any(grepl("dontrun|donttest|## Not run:", tmp))
# hack to support `examplesIf`. This is very ugly and probably fragile
# added in roxygen2::rd-examples.R
# https://github.com/r-lib/roxygen2/blob/db4dd9a4de2ce6817c17441d481cf5d03ef220e2/R/rd-examples.R#L17
regex <- ') (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf'
exampleIf <- grep(regex, rd, fixed = TRUE)[1]
if (!is.na(exampleIf[1])) {
exampleIf <- sub(
regex,
"",
as.character(rd)[exampleIf],
fixed = TRUE
)
exampleIf <- sub("^if \\(", "", exampleIf)
if (!isTRUE(try(eval(parse(text = exampleIf)), silent = TRUE))) {
block_eval <- FALSE
}
}
block <- sprintf(
"```{r, warning=FALSE, message=FALSE, eval=%s}",
block_eval
)
tmp <- c(tmp[2:idx], block, pkg_load, ex, "```")
}
# cleanup equations
tmp <- gsub(
'<code class="reqn">(.*?)&gt;(.*?)</code>',
'<code class="reqn">\\1>\\2</code>',
tmp
)
tmp <- gsub(
'<code class="reqn">(.*?)&lt;(.*?)</code>',
'<code class="reqn">\\1<\\2</code>',
tmp
)
tmp <- gsub('<code class="reqn">(.*?)</code>', "\\$\\1\\$", tmp)
# cleanup code
tmp <- gsub("&#8288;", "", tmp, fixed = TRUE)
# title
tmp <- gsub("<h2[^>]*>(.*)</h2>", "## \\1 {.unnumbered}\n", tmp)
# Fix title level (use ## and not <h2> so that the TOC can be generated by
# mkdocs)
tmp <- gsub("<h2[^>]*>", "", tmp, perl = TRUE)
tmp <- gsub("<.h2>", "", tmp)
tmp <- gsub("<h3>", "### ", tmp)
tmp <- gsub("</h3>", "", tmp)
# paragraph tags are unnecessary in markdown
tmp <- gsub("<p>", "", tmp, fixed = TRUE)
tmp <- gsub("</p>", "", tmp, fixed = TRUE)
# write to file
fn <- file.path(target_dir, sub("Rd$", "qmd", basename(source_file)))
writeLines(tmp, con = fn)
}
# my overwrite:
.pkg_name <- function(path) {
return("broadcast")
}
# convert Rd to qmd ====
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("man", i)
outpath <- file.path("website", "man")
.rd2qmd(filepath, outpath, pkgpath)
}
# adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
# move man files to proper folder ====
outerfiles <- paste0("bc.", c("b", "i", "d", "cplx", "str", "list"), ".qmd")
file.copy(
file.path("website", "man", outerfiles),
file.path("website", "man", "outer", outerfiles),
overwrite = TRUE
)
bindfiles <- paste0(c("bind", "aaa01_broadcast_bind"), ".qmd")
file.copy(
file.path("website", "man", bindfiles),
file.path("website", "man", "bind", bindfiles),
overwrite = TRUE
)
genericfiles <- c("bc_ifelse.qmd", "bcapply.qmd")
file.copy(
file.path("website", "man", genericfiles),
file.path("website", "man", "generic", genericfiles),
overwrite = TRUE
)
otherfiles <- setdiff(
list.files(file.path("website", "man"), pattern = ".qmd"),
c(outerfiles, bindfiles, genericfiles, "aaa00_broadcast_help.qmd")
)
file.copy(
file.path("website", "man", otherfiles),
file.path("website", "man", "other", otherfiles),
overwrite = TRUE
)
# cut moved files ====
lst.files <- list.files(file.path("website", "man"), pattern = ".qmd")
lst.files <- setdiff(lst.files, "aaa00_broadcast_help.qmd")
file.remove(file.path("website", "man", lst.files))
# end of rd2qmd ====
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
library(stringi)
file.copy("index.qmd", "vignettes/a_readme.qmd", overwrite = TRUE)
quarto_render()
# wait until render is done!
quarto_preview()
