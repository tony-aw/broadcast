if (a == b) {
return a;
}
if (a > b) {
return gcd(a - b, b);
}
return gcd(a, b - a);
}
"
)
gcd(12, 15)
gcd(-12, 15)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
.rcpp_longint_test(1,0)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
long long *px = (long long *) REAL(x);
long long *py = (long long *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
code <- "
#include <Rcpp/Lightest>
using namespace Rcpp;
#define INTMIN (-pow(2, 53))
#define INTMAX (pow(2, 53))
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_plus)]]
double rcpp_longint_plus(
long long x, long long y, bool isNA, bool & overflow
) {
if(isNA) {
return NA_REAL;
}
long long out = x + y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_min)]]
double rcpp_longint_min(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x - y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_mult)]]
double rcpp_longint_mult(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x * y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_div)]]
double rcpp_longint_div(
long long x, long long y, bool isNA, bool & overflow
) {
long long out = x / y;
if(out > INTMAX || out < INTMIN) {
overflow = TRUE;
return NA_REAL;
}
return out;
}
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# Preview documentation ====
library(broadcast)
?bc.d
?install.packages("pkgdown")
library(altdoc)
sessionInfo()
library(quarto)
sessionInfo()
library(broadcast)
library(broadcast)
?bc.i
?help
?
help()
help("bc.i", help_type = "text")
help("bc.i", help_type = "pdf")
help("bc.i", help_type = "html")
utils:::index.search("bc.i", find.package())
utils:::index.search("bind_array", find.package())
# map functions to Rds ====
utils:::index.search("bind_array", "broadcast")
# map functions to Rds ====
utils:::index.search("bind_array", find.package())
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
source("siteutils.R")
# pre-process Rds for linking ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("man", i)
outpath <- file.path("preprocess", "man")
rd_links(filepath, outpath, funs)
}
# convert Rd to qmd ====
lst.files <- list.files(file.path("preprocess", "man"), pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("preprocess", "man", i)
temp_html <- stri_replace_last(i, ".html", fixed = ".Rd")
temp_html <- file.path("preprocess", "man", temp_html)
outpath <- file.path("website", "man")
rd2qmd(filepath, temp_html, outpath, pkgpath)
}
# adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
# unpack links ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "man", i)
outpath <- file.path("website", "man")
qmd_extractlinks(filepath, outpath, funs)
}
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("\\link{", funs, "}")
rp <- paste0("[`", funs, "()`]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
# make readmes ====
quarto::quarto_render("website/index.qmd", "gfm", "Readme.md")
file.copy("website/Readme.md", "Readme.md")
# end of rd2qmd ====
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("\link{", funs, "}")
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("\\link{", funs, "()}")
rp <- paste0("[`", funs, "()`]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
library(stringi)
file.copy("index.qmd", "vignettes/a_readme.qmd", overwrite = TRUE)
quarto_render()
# wait until render is done!
quarto_preview()
