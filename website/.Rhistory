//' @noRd
// [[Rcpp::export(.rcpp_longint_test)]]
SEXP rcpp_longint_test(
SEXP x, SEXP y
) {
R_xlen_t n = Rf_xlength(x);
double *px = (double *) REAL(x);
double *py = (double *) REAL(y);
SEXP out = PROTECT(Rf_allocVector(REALSXP, n));
double *pout = REAL(out);
bool is_na = FALSE;
bool overflow = FALSE;
for(R_xlen_t i = 0; i < n; ++i) {
is_na = (px[i] == NA_REAL || py[i] == NA_REAL);
pout[i] = rcpp_longint_plus(px[i], py[i], is_na, overflow);
}
if(overflow) {
warning(\"overflow!\");
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
.rcpp_longint_test(1,1)
5^5
10^10
as.raw(0) & as.raw(1)
as.raw(0) & as.raw(0)
as.raw(1) & as.raw(1)
as.raw(1) & as.raw(2)
as.raw(2) & as.raw(2)
?anyNA
body_anyNULL <- "
int inv = LOGICAL(invert)[0];
R_xlen_t n = Rf_xlength(x);
SEXP temp;
if(!inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp == R_NilValue) {
return(ScalarLogical(1));
}
}
}
if(inv) {
for(R_xlen_t i = 0; i < n; ++i) {
temp = VECTOR_ELT(x, i);
if(temp != R_NilValue) {
return(ScalarLogical(1));
}
}
}
"
?collapse::whichv
?broadcast::bc.i()
?broadcast::bc.d()
?broadcast::bc.i()
?broadcast::bc.b()
?broadcast::bc.str()
y <- arrAy(rnorm(10), c(10, 5, 1))
foo <- cbind(
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 1),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 2),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 3),
sprintf("x[%d] + y[%d, %d]", 1:5, 1:5, 4)
)
print(foo)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
foo <- cbind(
sprintf("x[%d] + y[%d]", 1:5, 1),
sprintf("x[%d] + y[%d]", 1:5, 2),
sprintf("x[%d] + y[%d]", 1:5, 3),
sprintf("x[%d] + y[%d]", 1:5, 4),
sprintf("x[%d] + y[%d]", 1:5, 5)
)
knitr::kable(foo) |> kableExtra::column_spec(1:5, border_left = TRUE, border_right = TRUE)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- arrAy(rnorm(10), c(10, 5, 2))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
x <- array(rnorm(10), c(10, 1, 9, 6))
y <- array(rnorm(10), c(10, 5, 1))
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = rep(TRUE, 4),
reason = c("equal", "either is 1", "either is 1", "either is missing"),
check.names = FALSE
)
dimx <- dim(x)
dimy <- dim(y)
data.frame(
`dim(x)` = dimx,
`dim(y)` = c(dimy, NA),
compatible = c(TRUE, TRUE, FALSE, TRUE),
reason = c("equal", "either is 1", "not equal & neither is 1/missing", "either is missing"),
check.names = FALSE
)
15/12
1.25*30
install.packages("altdoc")
# Preview documentation ====
library(broadcast)
?bc.d
?install.packages("pkgdown")
library(altdoc)
sessionInfo()
library(quarto)
sessionInfo()
library(broadcast)
library(broadcast)
?bc.i
?help
?
help()
help("bc.i", help_type = "text")
help("bc.i", help_type = "pdf")
help("bc.i", help_type = "html")
utils:::index.search("bc.i", find.package())
utils:::index.search("bind_array", find.package())
# map functions to Rds ====
utils:::index.search("bind_array", "broadcast")
# map functions to Rds ====
utils:::index.search("bind_array", find.package())
ifelse(TRUE, 1:10, letters)
?ifelse
ifelse(TRUE, 1:10, letters)
ifelse(NA, 1:10, letters)
ifelse(NULL, 1:10, letters)
# speed tests
library(broadcast)
code <- "
#include <Rcpp.h>
using namespace Rcpp;
//' @keywords internal
//' @noRd
// [[Rcpp::export(rcpp_bc_dbl_orthogonal_test)]]
SEXP rcpp_bc_dbl_orthogonal_test(
SEXP x, SEXP y,
SEXP dimcumprod_x, SEXP dimcumprod_y, SEXP out_dim, R_xlen_t nout
) {
double *pdcp_x = REAL(dimcumprod_x);
double *pdcp_y = REAL(dimcumprod_y);
const double *px = REAL_RO(x);
const double *py = REAL_RO(y);
double tempout;
SEXP out = PROTECT(Rf_allocVector(REALSXP, nout));
double *pout;
pout = REAL(out);
R_xlen_t counter = 0;
const int *pout_dim = INTEGER_RO(out_dim);
R_xlen_t flatind_x;
R_xlen_t flatind_y;
R_xlen_t y2, y4, x3;
for(int iter4 = 0; iter4 < pout_dim[3]; ++iter4) {
y4 = iter4 * pdcp_y[3];
for(int iter3 = 0; iter3 < pout_dim[2]; ++iter3) {
x3 = iter3 * pdcp_y[2];
for(int iter2 = 0; iter2 < pout_dim[1]; ++iter2) {
y2 = iter2 * pdcp_y[1];
for(int iter1 = 0; iter1 < pout_dim[0]; ++iter1) {
flatind_x = iter1 + x3;
flatind_y = y2 + y4;
tempout = (double)px[flatind_x] + (double)py[flatind_y];
pout[counter] = tempout;
counter++;
}
}
}
}
UNPROTECT(1);
return out;
}
"
Rcpp::sourceCpp(code = code)
n <- 75L
rt <- loadNamespace("reticulate")
np <- rt$import("numpy", convert = FALSE)
timeit <- rt$import("timeit", convert = FALSE)
npa <- np$random$rand(n, 1L, n, 1L)
npb <- np$random$rand(1L, n, 1L, n)
npa + npb
a.dim <- rep(c(n, 1L), 2)
b.dim <- rep(c(1L, n), 2)
a <- array(rnorm(100), a.dim)
b <- array(rnorm(100), b.dim)
by_a <- ifelse(dim(a) > 1L, 1L, 0L)
by_b <- ifelse(dim(b) > 1L, 1L, 0L)
dcp_a <- c(1, cumprod(dim(a)))
dcp_b <- c(1, cumprod(dim(b)))
out.dim <- pmax(dim(a), dim(b))
out.len <- prod(out.dim)
foo <- bench::mark(
bc = bc.num(a, b, "+"), # bc is massively better,
bc_internal = broadcast:::.rcpp_bc_dec_d(a, b, by_a, by_b, dcp_a, dcp_b, out.dim, out.len, 1L),
test = rcpp_bc_dbl_orthogonal_test(a, b, dcp_a, dcp_b, out.dim, out.len),
# `numpy (no conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100,
)
summary(foo)
ggplot2::autoplot(foo)
library(broadcast)
library(tinytest)
bc_ifelse(letters, LETTERS, letters)
bc_ifelse(c(TRUE, FALSE, TRUE, FALSE), letters[1:4], 1:4)
expect_error(
bc_ifelse(c(TRUE, FALSE, TRUE, FALSE), letters[1:4], 1:4),
pattern = "`yes` and `no` must be of the same type"
)
??cast
for(i in 1:(2^32)) i^2
for(i in 1:(2^16)) i+1
for(i in 1:(2^16)) i+1
for(i in 1:(2^16)) i-1
i
for(i in 1:(2^16)) i+1
i
for(i in 1:(2^16)) print(i)
2^16
6000^3
6000^3/1000
x <- rpois(10, 2)
x
tabulate(x)
table(x)
tabulate(as.factor(x))
table(as.factor(x))
levels(as.factor(x))
library(stringi)
# MACRO ====
all_N_decl <- sprintf("const int N%d = INTEGER(lens)[%d];\t\\", 1:16, 0:15)
all_ind_decl <- sprintf("const SEXP ind%d = VECTOR_ELT(subs, %d);\t\\", 1:16, 0:15)
all_ind_pointer <- sprintf("const int *pind%d = INTEGER_RO(ind%d);\t\\", 1:16, 1:16)
all_for <- c(
sprintf("\t for(int iter%d = 0; iter%d < N%d; ++iter%d) {\t\\", 1:16, 1:16, 1:16, 1:16)
)
forout <- sprintf("i_out%d = (pstarts[%d] + iter%d) * pdcp_out[%d];\t\\", 1:16, 0:15, 1:16, 0:15)
fory <- sprintf("i_y%d = (pind%d[iter%d] - 1) * pdcp_y[%d];\t\\", 1:16, 1:16, 1:16, 0:15)
all_for <- stri_c(all_for, forout, fory, sep = "\n")
cat(all_for[1])
cat(all_for[16])
all_parts_out <-  sprintf("i_out%d", 1:16)
all_parts_y <-  sprintf("i_y%d", 1:16)
all_out_decl <- sprintf("i_out%d", 1:16)
all_y_decl <- sprintf("i_y%d", 1:16)
temp <- "
#define MACRO_DIM_ACAST(DOCODE) do {              \\
if(Rf_length(subs) != 16) {                     \\
stop(\"subs not of length 16\");              \\
}                                               \\
if(Rf_length(starts) != 16) {                   \\
stop(\"starts not of length 16\");            \\
}                                               \\
if(Rf_length(lens) != 16) {                     \\
stop(\"lens not of length 16\");              \\
}                                               \\
if(Rf_length(dcp_y) != 16) {                    \\
stop(\"dcp_y not of length 16\");             \\
}                                               \\
if(Rf_length(dcp_out) != 16) {                  \\
stop(\"dcp_out not of length 16\");           \\
}                                               \\
\\
const double *pdcp_out = REAL_RO(dcp_out);      \\
const double *pdcp_y = REAL_RO(dcp_y);          \\
\\
const int *pstarts = INTEGER_RO(starts);        \\
\\
\\
<all_N_decl>
\\
<all_ind_decl>
\\
<all_ind_pointer>
\\
R_xlen_t flatind_out;       \\
R_xlen_t flatind_y;       \\
R_xlen_t <all_out_decl>; \\
R_xlen_t <all_y_decl>; \\
<startfor>
flatind_out = <main_out>;       \\
flatind_y = <main_y>;     \\
\\
DOCODE;                                                          \\
\\
flatind_out++;                      \\
<endfor>
} while(0)
"
i <- 16L
current_N_decl <- stri_c(all_N_decl[1:i], collapse = "\n")
current_ind_decl <- stri_c(all_ind_decl[1:i], collapse = "\n")
current_ind_pointer <- stri_c(all_ind_pointer[1:i], collapse = "\n")
current_out_decl <- stri_c(all_out_decl[1:(i)], collapse = ", ")
current_y_decl <- stri_c(all_y_decl[1:(i)], collapse = ", ")
current_for <- stri_c(all_for[i:1], collapse = "\n")
current_main_out <- stri_c(all_parts_out[1:i], collapse = " + ")
current_main_y <- stri_c(all_parts_y[1:i], collapse = " + ")
current_end <- stri_c(rep("\t }\t\\", i), collapse = "\n")
current_fixed <- c(
"<dtype>",
"<all_N_decl>",
"<all_ind_decl>",
"<all_ind_pointer>",
"<all_out_decl>",
"<all_y_decl>",
"<startfor>",
"<main_out>",
"<main_y>",
"<endfor>"
)
current_replacement <- c(
i,
current_N_decl,
current_ind_decl,
current_ind_pointer,
current_out_decl,
current_y_decl,
current_for,
current_main_out,
current_main_y,
current_end
)
out <- stri_replace_all(
temp,
fixed = current_fixed,
replacement = current_replacement,
case_insensitive = FALSE,
vectorize_all = FALSE
)
macro_dim_acast <- out
cat(macro_dim_acast)
header <- "
#include <Rcpp.h>
using namespace Rcpp;
"
main <- "
// [[Rcpp::export(rcpp_acast)]]
void rcpp_acast(
SEXP out, SEXP y, const SEXP starts, const SEXP lens, const SEXP subs,
const SEXP dcp_out, const SEXP dcp_y
) {
double *py = REAL(y);
double *pout = REAL(out);
MACRO_DIM_ACAST(pout[flatind_out] = py[flatind_y]);
}
"
code <- stri_c(header, "\n", macro_dim_acast, "\n", main)
cat(code)
Rcpp::sourceCpp(code = code)
library(broadcast)
testfun <- function(x, margin, grp) {
lvls <- levels(grp)
grp <- unclass(grp)
# get x & grp properties:
x.dim <- dim(x)
x.ndim <- ndim(x)
x.dimchunk <- c(x.dim, rep(1L, 16L - x.ndim))
grp_n <- length(unique(grp))
grp_mode <- max(tabulate(grp))
newdim <- x.ndim + 1L
# create output:
out.dim <- c(dim(x), grp_n)
out.dim[margin] <- grp_mode
out.ndim <- ndim(out)
out.dimchunk <- c(out.dim, rep(1L, 16L - out.ndim))
out <- array(NA_real_, out.dim)
# pre params:
subs <- lapply(1:16L, \(i)1:x.dimchunk[i])
starts <- rep(0L, 16L)
lens <- lengths(subs)
dcp_out <- cumprod(c(1, out.dimchunk))[1:16]
dcp_x <- cumprod(c(1, x.dimchunk))[1:16]
# loop:
for(i in 1:grp_n) {
subs[[margin]] <- which(grp == i)
lens[[margin]] <- sum(grp == i)
rcpp_acast(out, x, starts, lens, subs, dcp_out, dcp_x)
starts[newdim] <- starts[newdim] + grp_mode
}
return(out)
}
# after last ====
# expectation: group 1 is spread OVER rows, WITHIN layer 1
out <- array(NA_real_, c(3,3,3, rep(1L, 13L)))
x <- cbind(id = rep(1:3, each = 2), grp = rep(1:2, 3), val = rnorm(6))
grp <- as.factor(x[, 2])
testfun(out, 1L, grp)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
source("siteutils.R")
# pre-process Rds for linking ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("man", i)
outpath <- file.path("preprocess", "man")
rd_links(filepath, outpath, funs)
}
# convert Rd to qmd ====
lst.files <- list.files(file.path("preprocess", "man"), pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("preprocess", "man", i)
temp_html <- stri_replace_last(i, ".html", fixed = ".Rd")
temp_html <- file.path("preprocess", "man", temp_html)
outpath <- file.path("website", "man")
rd2qmd(filepath, temp_html, outpath, pkgpath)
}
# adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
# unpack links ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "man", i)
outpath <- file.path("website", "man")
qmd_extractlinks(filepath, outpath, funs)
}
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("\\link{", funs, "()}")
rp <- paste0("[`", funs, "()`]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
# make readmes ====
quarto::quarto_render("website/index.qmd", "gfm", "Readme.md")
file.copy("website/Readme.md", "Readme.md")
# end of rd2qmd ====
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
library(stringi)
file.copy("index.qmd", "vignettes/a_readme.qmd", overwrite = TRUE)
quarto_render()
# wait until render is done!
quarto_preview()
