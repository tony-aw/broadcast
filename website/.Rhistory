lens <- lengths(subs)
dcp_out <- cumprod(c(1, out.dimchunk))[1:16]
dcp_x <- cumprod(c(1, x.dimchunk))[1:16]
# loop:
for(i in 1:grp_n) {
subs[[margin]] <- which(grp == i)
lens[[margin]] <- sum(grp == i)
rcpp_acast(out, x, starts, lens, subs, dcp_out, dcp_x)
starts[newdim] <- starts[newdim] + grp_mode
}
return(out)
}
# after last ====
# expectation: group 1 is spread OVER rows, WITHIN layer 1
out <- array(NA_real_, c(3,3,3, rep(1L, 13L)))
x <- cbind(id = rep(1:3, each = 2), grp = rep(1:2, 3), val = rnorm(6))
grp <- as.factor(x[, 2])
testfun(out, 1L, grp)
# speed tests
library(broadcast)
library(tinytest)
tempfun <- function(x, grp) {
margin <- 1L
maxfreq <- max(tabulate(unclass(grp)))
out.dim <- c(dim(x), length(unique(grp)))
out.dim[margin] <- maxfreq
out <- array(NA_real_, out.dim)
for(k in 1:nlevels(grp)) {
extract <- x[grp == levels(grp)[k],, drop=FALSE]
out[1:nrow(extract), 1:ncol(extract), k] <- extract
}
return(out)
}
n <- 2500
x <- matrix(1:100, n, n)
grp <- as.factor(ceiling(x[, 2]/2))
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp)
)
foo <- bench::mark(
base = tempfun(x, grp),
acast = acast(x, 1L, grp),
check = FALSE,
min_iterations = 100
)
summary(foo)
ggplot2::autoplot(foo)
n <- 2500
x <- matrix(1:100, n, n)
grp <- as.factor(x[, 2] - 1L))
n <- 2500
x <- matrix(1:100, n, n)
grp <- as.factor(x[, 2] - 1L)
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp)
)
foo <- bench::mark(
base = tempfun(x, grp),
acast = acast(x, 1L, grp),
check = FALSE,
min_iterations = 100
)
n <- 2500
m <- 500
x <- matrix(1:m, n, n)
grp <- as.factor(sample(1:(m-1L), n, TRUE))
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp)
)
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp, TRUE)
)
foo <- bench::mark(
base = tempfun(x, grp),
acast = acast(x, 1L, grp, TRUE),
check = FALSE,
min_iterations = 100
)
summary(foo)
ggplot2::autoplot(foo)
pryr::show_c_source(.Primitive("%%"))
4.94065645841247E-324
4.94065645841247E-324 * 10
4.94065645841247E-324 * 10^324
4.94065645841247E-324 * 10^32
4.94065645841247E-324 * 10^320
4.94065645841247E-324 * 10^50
4.94065645841247E-324 * 10^60
4.94065645841247E-324 * 10^100
4.94065645841247E-324 * 10^200
4.94065645841247E-324 * 10^250
4.94065645841247E-324 * 10^300
4.94065645841247E-324 * 10^324
4.94065645841247E-324 * 10^323
4.94065645841247E-324 * 10^320
4.94065645841247E-324 * 10^310
4.94065645841247E-324 * 10^300
4.94065645841247E-324 * 10^310
4.94065645841247E-324 * 10^305
4.94065645841247E-324 * 10^306
4.94065645841247E-324 * 10^309
4.94065645841247E-324 * 10^308
4.94065645841247E-324 * 10^308 + 4*10^16
4.94065645841247E-324 * 10^308 + 4*10^15
4.94065645841247E-324 * 10^308
4.94065645841247E-324 * 10^309
4.94065645841247E-324 * 10^308 +10
4.94065645841247E-324 * 10^308 +1
2^53
1/(2^53)
1/(2^53) < 4.9e-324
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
library(broadcast)
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
reticulate::repl_python()
library(reticulate)
library(broadcast)
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
reticulate::repl_python()
setwd("D:/D Desktop/Publications/R package broadcast/broadcast")
# set-up ====
library(stringi)
source("siteutils.R")
################################################################################
# Create man pages ====
#
## pre-process Rds for linking ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("man", pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("man", i)
outpath <- file.path("preprocess", "man")
rd_links(filepath, outpath, funs)
}
## convert Rd to qmd ====
lst.files <- list.files(file.path("preprocess", "man"), pattern = "Rd")
pkgpath <- getwd()
for(i in lst.files) {
print(i)
filepath <- file.path("preprocess", "man", i)
temp_html <- stri_replace_last(i, ".html", fixed = ".Rd")
temp_html <- file.path("preprocess", "man", temp_html)
outpath <- file.path("website", "man")
rd2qmd(filepath, temp_html, outpath, pkgpath)
}
## adapt man titles ====
detection <- "---\ntitle:"
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
print(i)
filename <- i
title <- stri_replace_last(filename, "", fixed = ".qmd")
temp <- readLines(file.path("website", "man", filename))
check <- stringi::stri_detect(paste0(temp[1:2], collapse = "\n"), fixed = detection)
if(!check && !stri_detect(title, fixed = "aaa")) {
temp <- c("---", paste0("title: ", title), "---", temp)
writeLines(temp, file.path("website", "man", filename))
}
}
## unpack links in man pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files("website/man/", pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "man", i)
outpath <- file.path("website", "man")
qmd_extractlinks(filepath, outpath, funs)
}
################################################################################
# Process Vignettes, Index page, and GitHub Readme ====
#
# copy & render intro template ====
from <- "intro_template.qmd"
to <- file.path("website", "vignettes", "a_readme.qmd")
file.copy(from, to, overwrite = TRUE)
to <- "README.qmd"
file.copy(from, to, overwrite = TRUE)
gfm <- readLines("README.qmd")
gfm <- stri_replace_all(
gfm,
"'R'",
fixed = '`r fa("r-project")`'
)
writeLines(gfm, to)
quarto::quarto_render(to, "gfm", "README.md")
# create links in vignettes ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "vignettes"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "vignettes", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "vignettes", i))
}
# copy readme vignette to index page ====
from <- file.path("website", "vignettes", "a_readme.qmd")
to <- file.path("website", "index.qmd")
file.copy(from, to, overwrite = TRUE)
################################################################################
# Process About pages ====
#
# create links in About pages ====
funs <- getNamespaceExports("broadcast")
lst.files <- list.files(file.path("website", "About"), pattern = "qmd")
for(i in lst.files) {
filepath <- file.path("website", "About", i)
temp <- readLines(filepath)
p <- paste0("`", funs, "()`")
rp <- paste0("[", funs, "()]", "(/man/", rd_index(funs), ".qmd)")
temp <- stri_replace_all(
temp, rp, fixed = p, vectorize_all = FALSE
)
writeLines(temp, file.path("website", "About", i))
}
# end of rd2qmd ====
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website")
library(quarto)
quarto_render()
# wait until render is done!
quarto_preview()
