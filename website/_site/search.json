[
  {
    "objectID": "vignettes/f_practical_applications.html#casting-with-equal-group-sizes",
    "href": "vignettes/f_practical_applications.html#casting-with-equal-group-sizes",
    "title": "Practical Applications",
    "section": "Casting with equal group sizes",
    "text": "Casting with equal group sizes\nSuppose you read the following matrix from a file:\n\nx &lt;- cbind(\n  id = rep(1:3, each = 2),\n  grp = rep(1:2, 3),\n  val = 1:6 * 2\n)\nprint(x)\n#&gt;      id grp val\n#&gt; [1,]  1   1   2\n#&gt; [2,]  1   2   4\n#&gt; [3,]  2   1   6\n#&gt; [4,]  2   2   8\n#&gt; [5,]  3   1  10\n#&gt; [6,]  3   2  12\n\nFor computing purposes, you may need the rows of each group - defined in column “grp” - to be cast to a new dimension.\n‘broadcast’ allows users to cast subsets of an array onto a new dimension, based on some grouping factor. In this case, the following will do the job:\n\nmargin &lt;- 1L # we cast from the rows, so margin = 1\ngrp &lt;- as.factor(x[, 2]) # factor to define which rows belongs to which group\nlevels(grp) &lt;- c(\"a\", \"b\") # names for the new dimension\nout &lt;- acast(x, margin, grp) # casting is performed here\nprint(out)\n#&gt; , , a\n#&gt; \n#&gt;      id grp val\n#&gt; [1,]  1   1   2\n#&gt; [2,]  2   1   6\n#&gt; [3,]  3   1  10\n#&gt; \n#&gt; , , b\n#&gt; \n#&gt;      id grp val\n#&gt; [1,]  1   2   4\n#&gt; [2,]  2   2   8\n#&gt; [3,]  3   2  12\n\nNotice that the dimension-names of the new dimension (dimension 3) are equal to levels(grp).\nWith the cast array, one can use broadcasting to easily do things like multiply the values in each group with a different value, like so:\n\n\n# create the multiplication factor array\nmult &lt;- array(\n  1, c(1, 3, 2),\n  list(NULL, c(\"mult_id\", \"mult_grp\", \"mult_val\"), c(\"a\", \"b\"))\n)\nmult[, \"mult_val\", c(\"a\", \"b\")] &lt;- c(2, 10)\nprint(mult)\n#&gt; , , a\n#&gt; \n#&gt;      mult_id mult_grp mult_val\n#&gt; [1,]       1        1        2\n#&gt; \n#&gt; , , b\n#&gt; \n#&gt;      mult_id mult_grp mult_val\n#&gt; [1,]       1        1       10\n\nout2 &lt;- bc.num(out, mult, \"*\")\ndimnames(out2) &lt;- dimnames(out)\nprint(out2)\n#&gt; , , a\n#&gt; \n#&gt;      id grp val\n#&gt; [1,]  1   1   4\n#&gt; [2,]  2   1  12\n#&gt; [3,]  3   1  20\n#&gt; \n#&gt; , , b\n#&gt; \n#&gt;      id grp val\n#&gt; [1,]  1   2  40\n#&gt; [2,]  2   2  80\n#&gt; [3,]  3   2 120\n\nPerhaps you’d like to reverse-cast the array back when you’re done computing; reverse-casting an array can be done be combining asplit() with bind_array():\n\nasplit(out2, ndim(out2)) |&gt; bind_array(along = margin)\n#&gt;     id grp val\n#&gt; a.1  1   1   4\n#&gt; a.2  2   1  12\n#&gt; a.3  3   1  20\n#&gt; b.1  1   2  40\n#&gt; b.2  2   2  80\n#&gt; b.3  3   2 120\n\n…though the order of, in this case, the rows (because margin = 1) will not necessarily be the same as the original array."
  },
  {
    "objectID": "vignettes/f_practical_applications.html#casting-with-unequal-group-sizes",
    "href": "vignettes/f_practical_applications.html#casting-with-unequal-group-sizes",
    "title": "Practical Applications",
    "section": "Casting with unequal group sizes",
    "text": "Casting with unequal group sizes\nThe casting arrays also works when the groups have unequal sizes, though there are a few things to keep in mind.\nLet’s start again with the input array:\n\nx &lt;- cbind(\n  id = c(rep(1:3, each = 2), 1),\n  grp = c(rep(1:2, 3), 2),\n  val = rnorm(7)\n)\nprint(x)\n#&gt;      id grp        val\n#&gt; [1,]  1   1  1.0353663\n#&gt; [2,]  1   2 -0.9239074\n#&gt; [3,]  2   1  1.1651922\n#&gt; [4,]  2   2 -0.3891613\n#&gt; [5,]  3   1  0.7659485\n#&gt; [6,]  3   2  1.7019003\n#&gt; [7,]  1   2  0.8493321\n\nOnce again, the acast() function can be used to cast the group subsets from the rows over a new dimension. But this time, we need to specify fill = TRUE to allow acast() to fill the gaps, otherwise an error is called.\nThus one can cast in this case like so:\n\ngrp &lt;- as.factor(x[, 2])\nlevels(grp) &lt;- c(\"a\", \"b\")\nmargin &lt;- 1L\nout &lt;- acast(x, margin, grp, fill = TRUE)\nprint(out)\n#&gt; , , a\n#&gt; \n#&gt;      id grp       val\n#&gt; [1,]  1   1 1.0353663\n#&gt; [2,]  2   1 1.1651922\n#&gt; [3,]  3   1 0.7659485\n#&gt; [4,] NA  NA        NA\n#&gt; \n#&gt; , , b\n#&gt; \n#&gt;      id grp        val\n#&gt; [1,]  1   2 -0.9239074\n#&gt; [2,]  2   2 -0.3891613\n#&gt; [3,]  3   2  1.7019003\n#&gt; [4,]  1   2  0.8493321\n\nNotice that some values are missing ( NA ); if some groups have unequal number of elements, acast() needs to fill the gaps with missing values. By default, gaps are filled with NA if x is atomic, and with list(NULL) if x is recursive. The user can change the filling value through the fill_value argument.\nOnce again, we can get the original array back when we’re done like so:\n\nasplit(out, ndim(out)) |&gt; bind_array(along = margin)\n#&gt;     id grp        val\n#&gt; a.1  1   1  1.0353663\n#&gt; a.2  2   1  1.1651922\n#&gt; a.3  3   1  0.7659485\n#&gt; a.4 NA  NA         NA\n#&gt; b.1  1   2 -0.9239074\n#&gt; b.2  2   2 -0.3891613\n#&gt; b.3  3   2  1.7019003\n#&gt; b.4  1   2  0.8493321\n\n… but we do keep the missing values when the groups have an unequal number of elements."
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#example-case",
    "href": "vignettes/d_broadcasting_explained.html#example-case",
    "title": "Broadcasting Explained",
    "section": "2.1 Example case",
    "text": "2.1 Example case\nLet’s start with a simple example.\nConsider the matrices x and y:\n\nx &lt;- array(1:20, c(4, 5))\ny &lt;- array(1:5*10, c(1, 5))\nprint(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nSuppose one wishes to compute the element-wise addition of these 2 arrays.\nThis won’t work in base :\n\nx + y\nError in x + y : non-conformable arrays\n\nWhen computing the element-wise sum of these arrays, one or both of them need to be recycled so that they are equal size, in order to compute the element-wise computation.\nIn this case, matrix y needs its single row to be recycled 4 times, making y the same size as x, and thus conformable.\n provides linear vector recycling, but not recycling of array dimensions. Instead, in base  we need to replicate (and thus copy) the array dimensions. This can be done manually, like so:\n\nx + y[rep(1L, 4L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70"
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#what-is-the-problem",
    "href": "vignettes/d_broadcasting_explained.html#what-is-the-problem",
    "title": "Broadcasting Explained",
    "section": "2.2 What is the problem?",
    "text": "2.2 What is the problem?\nThere are several problems.\nFirst and foremost, when the arrays become larger, the replicated arrays become larger, and if the arrays become too large, you may require more memory than is available in your current system, resulting in a message like the following:\n\n&gt; Error: cannot allocate vector of size\n\nThe problem isn’t limited to available memory. As the required memory to allocate increase, the speed decreases. And let’s not forget that computational inefficiency in general is also bad for the environment.\nAdditionally, a solution like x + y[rep(1L, 4L),] is not easily scalable for other arrays when the dimensions of x and y are not known a-priori."
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#introducing-broadcasting",
    "href": "vignettes/d_broadcasting_explained.html#introducing-broadcasting",
    "title": "Broadcasting Explained",
    "section": "2.3 Introducing Broadcasting",
    "text": "2.3 Introducing Broadcasting\nIn an operation like x + y[rep(1L, 4L),], y is replicated to become the same size as x. The thing is, physical replication - and thus copying - of the dimensions of an array should not be necessary; arrays only need to be recycled virtually.\nVirtual recycling does not actually physically replicate arrays. Instead, nested loops in ‘C’ and ‘C++’ are used to simulate a recycled array.\nThis is similar to how  recycles regular (i.e. dimensionless) vectors.\nVirtual recycling requires no additional memory (apart from allocating the final end result); it is much faster and much more memory efficient than replicating dimensions.\nAnd that is what broadcasting does: broadcasting provides fast virtual recycling of array dimensions in the context of element-wise operations involving 2 (or more) arrays without allocating additional memory. Broadcasting in this package is also scalable to arrays of any dimensions (up to 16 dimensions).\nIn the earlier example, we used:\n\nx + y[rep(1L, 4L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70\n\nTo compute the element-wise addition using broadcasting through the ‘broadcast’ package, we can do the following:\n\nlibrary(broadcast)\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70\n\nThe result is the same (as it should). But as the size of the resulting array increases, the broadcasted functions become more and more efficient in terms of both speed and memory, in comparison with base  approaches.\nTechnically, one can also use t(t(x) + drop(y)), but that has a similar problem: one needs to perform transposition twice, which makes unnecessary copies, is slow, and is - again - not scalable to arrays where the dimensions are not known a-priori.\nBenchmarks can be found on the website."
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#retracing-the-first-example",
    "href": "vignettes/d_broadcasting_explained.html#retracing-the-first-example",
    "title": "Broadcasting Explained",
    "section": "3.1 Retracing the first example",
    "text": "3.1 Retracing the first example\nIn the previous example the following arrays were used:\n\nx &lt;- array(1:20, c(4, 5))\ny &lt;- array(1:5*10, c(1, 5))\n\nLet’s see what happens if we sum them together using broadcasting:\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70\n\nWhat happens here is that x remains the same, but row vector y is virtually recycled 4 times, but without requiring 4 times more memory. This is also illustrated here:\n\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n        \n        \n        \n                \n                  x[1, 1] + y[1, 1]\n                  x[1, 2] + y[1, 2]\n                  x[1, 3] + y[1, 3]\n                  x[1, 4] + y[1, 4]\n                  x[1, 5] + y[1, 5]\n                \n                \n                  x[2, 1] + y[1, 1]\n                  x[2, 2] + y[1, 2]\n                  x[2, 3] + y[1, 3]\n                  x[2, 4] + y[1, 4]\n                  x[2, 5] + y[1, 5]\n                \n                \n                  x[3, 1] + y[1, 1]\n                  x[3, 2] + y[1, 2]\n                  x[3, 3] + y[1, 3]\n                  x[3, 4] + y[1, 4]\n                  x[3, 5] + y[1, 5]\n                \n                \n                  x[4, 1] + y[1, 1]\n                  x[4, 2] + y[1, 2]\n                  x[4, 3] + y[1, 3]\n                  x[4, 4] + y[1, 4]\n                  x[4, 5] + y[1, 5]"
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#perpendicular-vectors",
    "href": "vignettes/d_broadcasting_explained.html#perpendicular-vectors",
    "title": "Broadcasting Explained",
    "section": "3.2 Perpendicular vectors",
    "text": "3.2 Perpendicular vectors\nLet’s now consider another scenario. We not take again 2 matrices x and y, but x is a column vector (i.e. a matrix with 1 column and multiple rows), and y is a row vector (i.e. a matrix with 1 row and multiple columns):\n\nx &lt;- array(1:5, c(5, 1))\ny &lt;- array(1:5 * 10, c(1, 5))\nprint(x)\n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    2\n#&gt; [3,]    3\n#&gt; [4,]    4\n#&gt; [5,]    5\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nComputing the broadcasted element-wise sum of x and y produces the following:\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55\n\nSo what exactly does broadcasting compute here?\nThe following table illustrates what broadcasting does, conceptually:\n\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n        \n        \n        \n                \n                  x[1, 1] + y[1, 1]\n                  x[1, 1] + y[1, 2]\n                  x[1, 1] + y[1, 3]\n                  x[1, 1] + y[1, 4]\n                  x[1, 1] + y[1, 5]\n                \n                \n                  x[2, 1] + y[1, 1]\n                  x[2, 1] + y[1, 2]\n                  x[2, 1] + y[1, 3]\n                  x[2, 1] + y[1, 4]\n                  x[2, 1] + y[1, 5]\n                \n                \n                  x[3, 1] + y[1, 1]\n                  x[3, 1] + y[1, 2]\n                  x[3, 1] + y[1, 3]\n                  x[3, 1] + y[1, 4]\n                  x[3, 1] + y[1, 5]\n                \n                \n                  x[4, 1] + y[1, 1]\n                  x[4, 1] + y[1, 2]\n                  x[4, 1] + y[1, 3]\n                  x[4, 1] + y[1, 4]\n                  x[4, 1] + y[1, 5]\n                \n                \n                  x[5, 1] + y[1, 1]\n                  x[5, 1] + y[1, 2]\n                  x[5, 1] + y[1, 3]\n                  x[5, 1] + y[1, 4]\n                  x[5, 1] + y[1, 5]"
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#normalization",
    "href": "vignettes/d_broadcasting_explained.html#normalization",
    "title": "Broadcasting Explained",
    "section": "4.1 Normalization",
    "text": "4.1 Normalization\nBefore broadcasting occurs, the number of dimensions of x and y are normalized, such that ndim(x) and ndim(y) are the same ( the ndim(x) function is the same as length(dim(x))).\nThis normalization achieved by appending dimensions of size 1 to the array with the smaller number of dimensions until both array have the same number of dimensions.\nFor example, if dim(x) = c(3, 4, 3) and dim(y) = c(3, 4), then internally dim(y) is changed to c(3, 4, 1)."
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#conformability",
    "href": "vignettes/d_broadcasting_explained.html#conformability",
    "title": "Broadcasting Explained",
    "section": "4.2 Conformability",
    "text": "4.2 Conformability\nBroadcasted operations only work when 2 arrays are conformable for broadcasting.\nConsider again 2 arrays x and y, and their dimensions given by dim(x) and dim(y), respectively.\n‘broadcast’ goes through dim(x) and dim(y), from left (i.e. first dimension / rows) to right (i.e. the last dimension), and checks for each axis i if at least one of the following conditions is TRUE:\n\ndim(x)[i] and dim(y)[i] are equal;\neither dim(x)[i] or dim(y)[i] is 1;\neither dim(x)[i] or dim(y)[i] is non-existing (see also the “Normalization” sub-section above)\n\nif at least one of the above conditions is true for each and every one of the dimensions of x and y, the 2 arrays are compatible for broadcasted operations. If not, they are not compatible, and attempting to perform a broadcasted operations results in an error.\nTo illustrate, let’s check 2 arrays to see if they are compatible:\n\nx &lt;- array(rnorm(10), c(10, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 5, 1))\n\n\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                dim(x)\n                dim(y)\n                compatible\n                reason\n              \n        \n        \n        \n                \n                  10\n                  10\n                  TRUE\n                  equal\n                \n                \n                  1\n                  5\n                  TRUE\n                  either is 1\n                \n                \n                  9\n                  1\n                  TRUE\n                  either is 1\n                \n                \n                  6\n                  NA\n                  TRUE\n                  either is missing\n                \n        \n      \n    \n\n\n\nAs shown in the data.frame above, all dimensions of x and y are compatible.\nTherefore, broadcasted binary operations involving x and y can be performed.\n \nNow let’s look at another 2 arrays, and see if they are compatible:\n\nx &lt;- array(rnorm(10), c(10, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 5, 2))\n\n\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                dim(x)\n                dim(y)\n                compatible\n                reason\n              \n        \n        \n        \n                \n                  10\n                  10\n                  TRUE\n                  equal\n                \n                \n                  1\n                  5\n                  TRUE\n                  either is 1\n                \n                \n                  9\n                  2\n                  FALSE\n                  not equal & neither is 1/missing\n                \n                \n                  6\n                  NA\n                  TRUE\n                  either is missing\n                \n        \n      \n    \n\n\n\nOne of the dimensions, namely the third dimension, is not compatible. Therefore, these 2 arrays are not conformable for broadcasted operations."
  },
  {
    "objectID": "vignettes/d_broadcasting_explained.html#which-dimensions-are-broadcasted",
    "href": "vignettes/d_broadcasting_explained.html#which-dimensions-are-broadcasted",
    "title": "Broadcasting Explained",
    "section": "4.3 Which dimensions are broadcasted",
    "text": "4.3 Which dimensions are broadcasted\nIn the context of an operation involving exactly 2 arrays, this sub-section explains which dimensions of which array is broadcasted, and which dimension of which array is left as-is.\nThere are 3 scenarios relevant for this explanation.\n \nScenario 1:\nFor some dimension i, dim(x)[i] and dim(y)[i] are equal.\nIn this scenario, no broadcasting needs to occur on that dimension for either array.\n \nScenario 2:\nFor some dimension i, suppose dim(x)[i] == 1 and dim(y)[i] &gt; 1.\nThen dimension dim(x)[i] is broadcasted to size dim(y)[i].\nSimilarly, if dim(x)[i] &gt; 1 and dim(y)[i] == 1, dimension dim(y)[i] is broadcasted to size dim(x)[i].\n \nScenario 3:\nFinally, suppose for some dimension i, dim(x)[i] &gt; 1, and dim(y)[i] is non-existing.\nI.e., x has more dimensions than y.\nIn this case, the missing dimension in y is replaced with a dimensions of size 1, and scenario 2 is used.\nSimilarly, if dim(y)[i] &gt; 1 and dim(x)[i] is non-existing, the missing dimension in x is replaced with a dimension of size 1 and we get back to scenario 2.\nIt does not matter how much difference there is between the number of dimensions of x and the number of dimensions of y: any number of missing dimensions will be replaced with 1, as long as the total number of dimensions for each array does not exceed 16.\n \nIllustration\nTo illustrate, let’s check 2 conformable arrays, and see which dimension of which array is broadcasted by how much\n\nx &lt;- array(rnorm(10), c(10, 1, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 1, 5, 1))\n\n\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                i\n                dim(x)\n                dim(y)\n                broadcasted\n                reason\n                note\n              \n        \n        \n        \n                \n                  1\n                  10\n                  10\n                  neither\n                  dims equal\n                  \n                \n                \n                  2\n                  1\n                  1\n                  neither\n                  dims equal\n                  \n                \n                \n                  3\n                  1\n                  5\n                  x\n                  dim(x)[i] == 1\n                  dim(x)[i] recycled to size 5\n                \n                \n                  4\n                  9\n                  1\n                  y\n                  dim(y)[i] == 1\n                  dim(y)[i] recycled to size 9\n                \n                \n                  5\n                  6\n                  NA\n                  y\n                  dim(y)[i] is missing\n                  dim(y) extended with a 1; dim(y)[i] recycled to size 6"
  },
  {
    "objectID": "vignettes/b_installation.html",
    "href": "vignettes/b_installation.html",
    "title": "Installation",
    "section": "",
    "text": "To install ‘broadcast’ from GitHub, one may run the following code in :\n\n\nremotes::install_github(\"https://github.com/tony-aw/broadcast\")\n\n‘broadcast’ is not a large package per-sé, but it does contain a large amount of compiled code (‘C’ and ‘C++’). Compilation of the package may therefore be slow on some operating systems, especially Linux systems; please be patient. On an average laptop running Windows 11, installation of the ‘broadcast’ package shouldn’t take more than just a few minutes.\nIf installation is too slow, one may try to speed up the installation using multi-threading, for example like so:\n\n\nnthreads &lt;- 8L # specify number of threads\nSys.setenv(MAKEFLAGS = paste0(\"-j\", nthreads)) # may speed up installation\n\nremotes::install_github(\"https://github.com/tony-aw/broadcast\")\n\n \nTo attach the package - thus expose its functions to the namespace - please use the following:\n\n\nlibrary(broadcast)\n\n \nTo open the introduction help page of the ‘broadcast’ package, please use any of the following:\n\n\n?broadcast::broadcast\n?broadcast::broadcast_help\n?broadcast::`broadcast-package`"
  },
  {
    "objectID": "man/typecast.html",
    "href": "man/typecast.html",
    "title": "typecast",
    "section": "",
    "text": "Type casting usually strips away attributes of objects.  The functions provided here preserve dimensions, dimnames, and names, which may be more convenient for arrays and array-like objects.   The functions are as follows: \n\n\nas_bool(): converts object to atomic type logical (TRUE, FALSE, NA).\n\n\nas_int(): converts object to atomic type integer.\n\n\nas_dbl(): converts object to atomic type double (AKA numeric).\n\n\nas_chr(): converts object to atomic type character.\n\n\nas_cplx(): converts object to atomic type complex.\n\n\nas_raw(): converts object to atomic type raw.\n\n\nas_list(): converts object to recursive type list. \n\n\nas_num() is an alias for as_dbl().  as_str() is an alias for as_chr().   See also typeof.  \n\n\n\nas_bool(x, ...)\n\nas_int(x, ...)\n\nas_dbl(x, ...)\n\nas_num(x, ...)\n\nas_chr(x, ...)\n\nas_str(x, ...)\n\nas_cplx(x, ...)\n\nas_raw(x, ...)\n\nas_list(x, ...)\n\n\n\n\n\n\n\n\nx\n\n\nan R object.\n\n\n\n\n…\n\n\nfurther arguments passed to or from other methods.\n\n\n\n\n\n\n\nThe converted object.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- matrix(sample(-1:28), ncol = 5)\ncolnames(x) &lt;- month.name[1:5]\nrownames(x) &lt;- month.abb[1:6]\nnames(x) &lt;- c(letters[1:20], LETTERS[1:10])\nprint(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\nas_bool(x)\n##     January February March April  May\n## Jan    TRUE     TRUE  TRUE  TRUE TRUE\n## Feb   FALSE     TRUE  TRUE  TRUE TRUE\n## Mar    TRUE     TRUE  TRUE  TRUE TRUE\n## Apr    TRUE     TRUE  TRUE  TRUE TRUE\n## May    TRUE     TRUE  TRUE  TRUE TRUE\n## Jun    TRUE     TRUE  TRUE  TRUE TRUE\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_int(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_dbl(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_chr(x)\n##     January February March April May \n## Jan \"2\"     \"6\"      \"-1\"  \"9\"   \"8\" \n## Feb \"0\"     \"3\"      \"11\"  \"17\"  \"28\"\n## Mar \"10\"    \"1\"      \"16\"  \"18\"  \"14\"\n## Apr \"5\"     \"22\"     \"27\"  \"23\"  \"24\"\n## May \"19\"    \"12\"     \"21\"  \"7\"   \"13\"\n## Jun \"4\"     \"15\"     \"25\"  \"26\"  \"20\"\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_cplx(x)\n##     January February March April   May\n## Jan    2+0i     6+0i -1+0i  9+0i  8+0i\n## Feb    0+0i     3+0i 11+0i 17+0i 28+0i\n## Mar   10+0i     1+0i 16+0i 18+0i 14+0i\n## Apr    5+0i    22+0i 27+0i 23+0i 24+0i\n## May   19+0i    12+0i 21+0i  7+0i 13+0i\n## Jun    4+0i    15+0i 25+0i 26+0i 20+0i\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_raw(x)\n##     January February March April May\n## Jan      02       06    00    09  08\n## Feb      00       03    0b    11  1c\n## Mar      0a       01    10    12  0e\n## Apr      05       16    1b    17  18\n## May      13       0c    15    07  0d\n## Jun      04       0f    19    1a  14\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\n\n################################################################################\n\n# factor example ====\nx &lt;- factor(month.abb, levels = month.abb)\nnames(x) &lt;- month.name\nprint(x)\n##   January  February     March     April       May      June      July    August \n##       Jan       Feb       Mar       Apr       May       Jun       Jul       Aug \n## September   October  November  December \n##       Sep       Oct       Nov       Dec \n## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nas_bool(as_int(x) &gt; 6)\n##   January  February     March     April       May      June      July    August \n##     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE \n## September   October  November  December \n##      TRUE      TRUE      TRUE      TRUE\nas_int(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_dbl(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_chr(x)\n##   January  February     March     April       May      June      July    August \n##     \"Jan\"     \"Feb\"     \"Mar\"     \"Apr\"     \"May\"     \"Jun\"     \"Jul\"     \"Aug\" \n## September   October  November  December \n##     \"Sep\"     \"Oct\"     \"Nov\"     \"Dec\"\nas_cplx(x)\n##   January  February     March     April       May      June      July    August \n##  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i\n## September   October  November  December \n##  9+0i 10+0i 11+0i 12+0i\nas_raw(x)\n##   January  February     March     April       May      June      July    August \n##        01        02        03        04        05        06        07        08 \n## September   October  November  December \n##        09        0a        0b        0c"
  },
  {
    "objectID": "man/typecast.html#atomic-and-list-type-casting-with-names-and-dimensions-preserved",
    "href": "man/typecast.html#atomic-and-list-type-casting-with-names-and-dimensions-preserved",
    "title": "typecast",
    "section": "",
    "text": "Type casting usually strips away attributes of objects.  The functions provided here preserve dimensions, dimnames, and names, which may be more convenient for arrays and array-like objects.   The functions are as follows: \n\n\nas_bool(): converts object to atomic type logical (TRUE, FALSE, NA).\n\n\nas_int(): converts object to atomic type integer.\n\n\nas_dbl(): converts object to atomic type double (AKA numeric).\n\n\nas_chr(): converts object to atomic type character.\n\n\nas_cplx(): converts object to atomic type complex.\n\n\nas_raw(): converts object to atomic type raw.\n\n\nas_list(): converts object to recursive type list. \n\n\nas_num() is an alias for as_dbl().  as_str() is an alias for as_chr().   See also typeof.  \n\n\n\nas_bool(x, ...)\n\nas_int(x, ...)\n\nas_dbl(x, ...)\n\nas_num(x, ...)\n\nas_chr(x, ...)\n\nas_str(x, ...)\n\nas_cplx(x, ...)\n\nas_raw(x, ...)\n\nas_list(x, ...)\n\n\n\n\n\n\n\n\nx\n\n\nan R object.\n\n\n\n\n…\n\n\nfurther arguments passed to or from other methods.\n\n\n\n\n\n\n\nThe converted object.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- matrix(sample(-1:28), ncol = 5)\ncolnames(x) &lt;- month.name[1:5]\nrownames(x) &lt;- month.abb[1:6]\nnames(x) &lt;- c(letters[1:20], LETTERS[1:10])\nprint(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\nas_bool(x)\n##     January February March April  May\n## Jan    TRUE     TRUE  TRUE  TRUE TRUE\n## Feb   FALSE     TRUE  TRUE  TRUE TRUE\n## Mar    TRUE     TRUE  TRUE  TRUE TRUE\n## Apr    TRUE     TRUE  TRUE  TRUE TRUE\n## May    TRUE     TRUE  TRUE  TRUE TRUE\n## Jun    TRUE     TRUE  TRUE  TRUE TRUE\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_int(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_dbl(x)\n##     January February March April May\n## Jan       2        6    -1     9   8\n## Feb       0        3    11    17  28\n## Mar      10        1    16    18  14\n## Apr       5       22    27    23  24\n## May      19       12    21     7  13\n## Jun       4       15    25    26  20\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_chr(x)\n##     January February March April May \n## Jan \"2\"     \"6\"      \"-1\"  \"9\"   \"8\" \n## Feb \"0\"     \"3\"      \"11\"  \"17\"  \"28\"\n## Mar \"10\"    \"1\"      \"16\"  \"18\"  \"14\"\n## Apr \"5\"     \"22\"     \"27\"  \"23\"  \"24\"\n## May \"19\"    \"12\"     \"21\"  \"7\"   \"13\"\n## Jun \"4\"     \"15\"     \"25\"  \"26\"  \"20\"\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_cplx(x)\n##     January February March April   May\n## Jan    2+0i     6+0i -1+0i  9+0i  8+0i\n## Feb    0+0i     3+0i 11+0i 17+0i 28+0i\n## Mar   10+0i     1+0i 16+0i 18+0i 14+0i\n## Apr    5+0i    22+0i 27+0i 23+0i 24+0i\n## May   19+0i    12+0i 21+0i  7+0i 13+0i\n## Jun    4+0i    15+0i 25+0i 26+0i 20+0i\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_raw(x)\n##     January February March April May\n## Jan      02       06    00    09  08\n## Feb      00       03    0b    11  1c\n## Mar      0a       01    10    12  0e\n## Apr      05       16    1b    17  18\n## May      13       0c    15    07  0d\n## Jun      04       0f    19    1a  14\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\n\n################################################################################\n\n# factor example ====\nx &lt;- factor(month.abb, levels = month.abb)\nnames(x) &lt;- month.name\nprint(x)\n##   January  February     March     April       May      June      July    August \n##       Jan       Feb       Mar       Apr       May       Jun       Jul       Aug \n## September   October  November  December \n##       Sep       Oct       Nov       Dec \n## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nas_bool(as_int(x) &gt; 6)\n##   January  February     March     April       May      June      July    August \n##     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE \n## September   October  November  December \n##      TRUE      TRUE      TRUE      TRUE\nas_int(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_dbl(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_chr(x)\n##   January  February     March     April       May      June      July    August \n##     \"Jan\"     \"Feb\"     \"Mar\"     \"Apr\"     \"May\"     \"Jun\"     \"Jul\"     \"Aug\" \n## September   October  November  December \n##     \"Sep\"     \"Oct\"     \"Nov\"     \"Dec\"\nas_cplx(x)\n##   January  February     March     April       May      June      July    August \n##  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i\n## September   October  November  December \n##  9+0i 10+0i 11+0i 12+0i\nas_raw(x)\n##   January  February     March     April       May      June      July    August \n##        01        02        03        04        05        06        07        08 \n## September   October  November  December \n##        09        0a        0b        0c"
  },
  {
    "objectID": "man/ndim.html",
    "href": "man/ndim.html",
    "title": "ndim",
    "section": "",
    "text": "ndim() returns the number of dimensions of an object.  lst.ndim() returns the number of dimensions of every list-element.  \n\n\n\nndim(x)\n\nlst.ndim(x)\n\n\n\n\n\n\n\n\nx\n\n\nan object. For functions starting with lst., x must be a list (i.e. recursive vector or recursive array). \n\n\n\n\n\n\n\nFor ndim(): an integer scalar.  For lst.ndim(): an integer vector, with the same length, names and dimensions as x. \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- list(\n  array(1:10, 10),\n  array(1:10, c(2, 5)),\n  array(c(letters, NA), c(3,3,3))\n)\nlst.ndim(x)\n## [1] 1 2 3"
  },
  {
    "objectID": "man/ndim.html#get-number-of-dimensions",
    "href": "man/ndim.html#get-number-of-dimensions",
    "title": "ndim",
    "section": "",
    "text": "ndim() returns the number of dimensions of an object.  lst.ndim() returns the number of dimensions of every list-element.  \n\n\n\nndim(x)\n\nlst.ndim(x)\n\n\n\n\n\n\n\n\nx\n\n\nan object. For functions starting with lst., x must be a list (i.e. recursive vector or recursive array). \n\n\n\n\n\n\n\nFor ndim(): an integer scalar.  For lst.ndim(): an integer vector, with the same length, names and dimensions as x. \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- list(\n  array(1:10, 10),\n  array(1:10, c(2, 5)),\n  array(c(letters, NA), c(3,3,3))\n)\nlst.ndim(x)\n## [1] 1 2 3"
  },
  {
    "objectID": "man/bc_ifelse.html",
    "href": "man/bc_ifelse.html",
    "title": "bc_ifelse",
    "section": "",
    "text": "The bc_ifelse() function performs a broadcasted form of ifelse. \n\n\n\nbc_ifelse(cond, yes, no)\n\n\n\n\n\n\n\n\ncond\n\n\nlogical vector or array with the length equal to prod(bc_dim(yes, no)).\n\n\n\n\nyes, no\n\n\nconformable arrays of the same type.  All atomic types are supported except for the type of raw.  Recursive arrays of type list are also supported.  \n\n\n\n\n\n\n\nThe ouput, here referred to as out, will be an array of the same type as yes and no.  After broadcasting yes against no, given any element index i, the following will hold for the output:\n\n\nwhen cond[i] == TRUE, out[i] is yes[i];\n\n\nwhen cond[i] == FALSE, out[i] is no[i];\n\n\nwhen cond[i] is NA, out[i] is NA when yes and no are atomic, and out[i] is list(NULL) when yes and no are recursive.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\ncond &lt;- bc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))\n) |&gt; as_bool()\n\nbc_ifelse(cond, yes = x, no = y)\n## , , 1\n## \n##       [,1]         [,2]        \n##  [1,] integer,10   integer,10  \n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] integer,10   integer,10  \n## [10,] character,12 character,12\n## \n## , , 2\n## \n##       [,1]         [,2]        \n##  [1,] integer,10   integer,10  \n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] integer,10   integer,10  \n## [10,] character,12 character,12"
  },
  {
    "objectID": "man/bc_ifelse.html#broadcasted-ifelse",
    "href": "man/bc_ifelse.html#broadcasted-ifelse",
    "title": "bc_ifelse",
    "section": "",
    "text": "The bc_ifelse() function performs a broadcasted form of ifelse. \n\n\n\nbc_ifelse(cond, yes, no)\n\n\n\n\n\n\n\n\ncond\n\n\nlogical vector or array with the length equal to prod(bc_dim(yes, no)).\n\n\n\n\nyes, no\n\n\nconformable arrays of the same type.  All atomic types are supported except for the type of raw.  Recursive arrays of type list are also supported.  \n\n\n\n\n\n\n\nThe ouput, here referred to as out, will be an array of the same type as yes and no.  After broadcasting yes against no, given any element index i, the following will hold for the output:\n\n\nwhen cond[i] == TRUE, out[i] is yes[i];\n\n\nwhen cond[i] == FALSE, out[i] is no[i];\n\n\nwhen cond[i] is NA, out[i] is NA when yes and no are atomic, and out[i] is list(NULL) when yes and no are recursive.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\ncond &lt;- bc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))\n) |&gt; as_bool()\n\nbc_ifelse(cond, yes = x, no = y)\n## , , 1\n## \n##       [,1]         [,2]        \n##  [1,] integer,10   integer,10  \n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] integer,10   integer,10  \n## [10,] character,12 character,12\n## \n## , , 2\n## \n##       [,1]         [,2]        \n##  [1,] integer,10   integer,10  \n##  [2,] character,26 character,26\n##  [3,] integer,10   integer,10  \n##  [4,] character,12 character,12\n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] character,26 character,26\n##  [9,] integer,10   integer,10  \n## [10,] character,12 character,12"
  },
  {
    "objectID": "man/bcapply.html",
    "href": "man/bcapply.html",
    "title": "bcapply",
    "section": "",
    "text": "The bcapply() function applies a function to 2 arrays element-wise with broadcasting. \n\n\n\nbcapply(x, y, f, v = NULL)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic or recursive arrays.\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a recursive or atomic array.\n\n\n\n\nv\n\n\neither NULL, or single string, giving the scalar type for a single iteration.  If NULL (default) or “list”, the result will be a recursive array.  If it is certain that, for every iteration, f() always results in a single atomic scalar, the user can specify the type in v to pre-allocate the result.  Pre-allocating the results leads to slightly faster and more memory efficient code.  NOTE: Incorrectly specifying v leads to undefined behaviour;  when unsure, leave v at its default value. \n\n\n\n\n\n\n\nAn atomic or recursive array with dimensions bc_dim(x, y). \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nf &lt;- function(x, y) list(x, y)\nbcapply(x, y, f)\n## , , 1\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n## \n## , , 2\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2"
  },
  {
    "objectID": "man/bcapply.html#apply-a-function-to-2-broadcasted-arrays",
    "href": "man/bcapply.html#apply-a-function-to-2-broadcasted-arrays",
    "title": "bcapply",
    "section": "",
    "text": "The bcapply() function applies a function to 2 arrays element-wise with broadcasting. \n\n\n\nbcapply(x, y, f, v = NULL)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic or recursive arrays.\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a recursive or atomic array.\n\n\n\n\nv\n\n\neither NULL, or single string, giving the scalar type for a single iteration.  If NULL (default) or “list”, the result will be a recursive array.  If it is certain that, for every iteration, f() always results in a single atomic scalar, the user can specify the type in v to pre-allocate the result.  Pre-allocating the results leads to slightly faster and more memory efficient code.  NOTE: Incorrectly specifying v leads to undefined behaviour;  when unsure, leave v at its default value. \n\n\n\n\n\n\n\nAn atomic or recursive array with dimensions bc_dim(x, y). \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nf &lt;- function(x, y) list(x, y)\nbcapply(x, y, f)\n## , , 1\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n## \n## , , 2\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2"
  },
  {
    "objectID": "man/bc.list.html",
    "href": "man/bc.list.html",
    "title": "bc.list",
    "section": "",
    "text": "The bc.list() function performs broadcasted operations on 2 Recursive arrays. \n\n\n\nbc.list(x, y, f)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable Recursive arrays (i.e. arrays of type list).\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a list. \n\n\n\n\n\n\n\nA recursive array. \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nbc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y), typeof(x) == typeof(y))\n)\n## , , 1\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2\n## \n## , , 2\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2"
  },
  {
    "objectID": "man/bc.list.html#broadcasted-operations-for-recursive-arrays",
    "href": "man/bc.list.html#broadcasted-operations-for-recursive-arrays",
    "title": "bc.list",
    "section": "",
    "text": "The bc.list() function performs broadcasted operations on 2 Recursive arrays. \n\n\n\nbc.list(x, y, f)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable Recursive arrays (i.e. arrays of type list).\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a list. \n\n\n\n\n\n\n\nA recursive array. \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nbc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y), typeof(x) == typeof(y))\n)\n## , , 1\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2\n## \n## , , 2\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2"
  },
  {
    "objectID": "man/bc.d.html",
    "href": "man/bc.d.html",
    "title": "bc.d",
    "section": "",
    "text": "The bc.d() function performs broadcasted decimal numeric operations on 2 numeric or logical arrays.  bc.num() is an alias for bc.d().  \n\n\n\nbc.d(x, y, op, tol = sqrt(.Machine\\$double.eps))\n\nbc.num(x, y, op, tol = sqrt(.Machine\\$double.eps))\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=, d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=. \n\n\n\n\ntol\n\n\na single number between 0 and 0.1, giving the machine tolerance to use.  Only relevant for the following operators:  d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=  See the %d==%, %d!=%, %d&lt;%, %d&gt;%, %d&lt;=%, %d&gt;=% operators from the ‘tinycodet’ package for details. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array as a result of the broadcasted decimal arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted decimal relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.d(x, y, \"+\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 624.1 259.1 801.1\n## [2,] 140.1 121.1 550.1\n## [3,] 762.1  73.1 803.1\n## [4,] 162.1 832.1 814.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 725.1 946.1  21.1\n## [2,] 511.1 818.1 477.1\n## [3,] 135.1  65.1 884.1\n## [4,] 613.1 174.1 453.1\nbc.d(x, y, \"-\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 622.1 257.1 799.1\n## [2,] 136.1 117.1 546.1\n## [3,] 756.1  67.1 797.1\n## [4,] 154.1 824.1 806.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 723.1 944.1  19.1\n## [2,] 507.1 814.1 473.1\n## [3,] 129.1  59.1 878.1\n## [4,] 605.1 166.1 445.1\nbc.d(x, y, \"*\")\n## , , 1\n## \n##        [,1]   [,2]   [,3]\n## [1,]  623.1  258.1  800.1\n## [2,]  276.2  238.2 1096.2\n## [3,] 2277.3  210.3 2400.3\n## [4,]  632.4 3312.4 3240.4\n## \n## , , 2\n## \n##        [,1]   [,2]   [,3]\n## [1,]  724.1  945.1   20.1\n## [2,] 1018.2 1632.2  950.2\n## [3,]  396.3  186.3 2643.3\n## [4,] 2436.4  680.4 1796.4\nbc.d(x, y, \"/\")\n## , , 1\n## \n##          [,1]      [,2]    [,3]\n## [1,] 623.1000 258.10000 800.100\n## [2,]  69.0500  59.55000 274.050\n## [3,] 253.0333  23.36667 266.700\n## [4,]  39.5250 207.02500 202.525\n## \n## , , 2\n## \n##           [,1]    [,2]    [,3]\n## [1,] 724.10000 945.100  20.100\n## [2,] 254.55000 408.050 237.550\n## [3,]  44.03333  20.700 293.700\n## [4,] 152.27500  42.525 112.275\nbc.d(x, y, \"^\")\n## , , 1\n## \n##              [,1]         [,2]         [,3]\n## [1,]       623.10 2.581000e+02 8.001000e+02\n## [2,]     19071.61 1.418481e+04 3.004136e+05\n## [3,] 437418326.07 3.444721e+05 5.121920e+08\n## [4,] 624780519.27 4.702525e+11 4.306798e+11\n## \n## , , 2\n## \n##              [,1]        [,2]         [,3]\n## [1,] 7.241000e+02       945.1 2.010000e+01\n## [2,] 2.591828e+05    666019.2 2.257200e+05\n## [3,] 2.305199e+06    239483.1 6.840307e+08\n## [4,] 1.376431e+11 837176934.7 4.067918e+10\n\nbc.d(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.d.html#broadcasted-decimal-numeric-operations",
    "href": "man/bc.d.html#broadcasted-decimal-numeric-operations",
    "title": "bc.d",
    "section": "",
    "text": "The bc.d() function performs broadcasted decimal numeric operations on 2 numeric or logical arrays.  bc.num() is an alias for bc.d().  \n\n\n\nbc.d(x, y, op, tol = sqrt(.Machine\\$double.eps))\n\nbc.num(x, y, op, tol = sqrt(.Machine\\$double.eps))\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=, d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=. \n\n\n\n\ntol\n\n\na single number between 0 and 0.1, giving the machine tolerance to use.  Only relevant for the following operators:  d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=  See the %d==%, %d!=%, %d&lt;%, %d&gt;%, %d&lt;=%, %d&gt;=% operators from the ‘tinycodet’ package for details. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array as a result of the broadcasted decimal arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted decimal relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.d(x, y, \"+\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 624.1 259.1 801.1\n## [2,] 140.1 121.1 550.1\n## [3,] 762.1  73.1 803.1\n## [4,] 162.1 832.1 814.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 725.1 946.1  21.1\n## [2,] 511.1 818.1 477.1\n## [3,] 135.1  65.1 884.1\n## [4,] 613.1 174.1 453.1\nbc.d(x, y, \"-\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 622.1 257.1 799.1\n## [2,] 136.1 117.1 546.1\n## [3,] 756.1  67.1 797.1\n## [4,] 154.1 824.1 806.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 723.1 944.1  19.1\n## [2,] 507.1 814.1 473.1\n## [3,] 129.1  59.1 878.1\n## [4,] 605.1 166.1 445.1\nbc.d(x, y, \"*\")\n## , , 1\n## \n##        [,1]   [,2]   [,3]\n## [1,]  623.1  258.1  800.1\n## [2,]  276.2  238.2 1096.2\n## [3,] 2277.3  210.3 2400.3\n## [4,]  632.4 3312.4 3240.4\n## \n## , , 2\n## \n##        [,1]   [,2]   [,3]\n## [1,]  724.1  945.1   20.1\n## [2,] 1018.2 1632.2  950.2\n## [3,]  396.3  186.3 2643.3\n## [4,] 2436.4  680.4 1796.4\nbc.d(x, y, \"/\")\n## , , 1\n## \n##          [,1]      [,2]    [,3]\n## [1,] 623.1000 258.10000 800.100\n## [2,]  69.0500  59.55000 274.050\n## [3,] 253.0333  23.36667 266.700\n## [4,]  39.5250 207.02500 202.525\n## \n## , , 2\n## \n##           [,1]    [,2]    [,3]\n## [1,] 724.10000 945.100  20.100\n## [2,] 254.55000 408.050 237.550\n## [3,]  44.03333  20.700 293.700\n## [4,] 152.27500  42.525 112.275\nbc.d(x, y, \"^\")\n## , , 1\n## \n##              [,1]         [,2]         [,3]\n## [1,]       623.10 2.581000e+02 8.001000e+02\n## [2,]     19071.61 1.418481e+04 3.004136e+05\n## [3,] 437418326.07 3.444721e+05 5.121920e+08\n## [4,] 624780519.27 4.702525e+11 4.306798e+11\n## \n## , , 2\n## \n##              [,1]        [,2]         [,3]\n## [1,] 7.241000e+02       945.1 2.010000e+01\n## [2,] 2.591828e+05    666019.2 2.257200e+05\n## [3,] 2.305199e+06    239483.1 6.840307e+08\n## [4,] 1.376431e+11 837176934.7 4.067918e+10\n\nbc.d(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.b.html",
    "href": "man/bc.b.html",
    "title": "bc.b",
    "section": "",
    "text": "The bc.b() function performs broadcasted Boolean operations on 2 logical (or 32bit integer) arrays.   Please note that these operations will treat the input as Boolean.  Therefore, something like bc.b(1, 2, “==”) returns TRUE, because both 1 and 2 are TRUE when cast as Boolean.  \n\n\n\nbc.b(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical (or 32bit integer) arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported Boolean operators: &, |, xor, nand, ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nA logical array as a result of the broadcasted Boolean operation.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.b(x, y, \"&\")\n## , , 1\n## \n##       [,1]  [,2] [,3]\n## [1,] FALSE    NA TRUE\n## [2,]    NA  TRUE TRUE\n## [3,]    NA    NA   NA\n## [4,]  TRUE FALSE   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]  TRUE   NA    NA\n## [2,] FALSE TRUE FALSE\n## [3,]  TRUE TRUE FALSE\n## [4,]  TRUE   NA  TRUE\nbc.b(x, y, \"|\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.b(x, y, \"xor\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]  TRUE    NA FALSE\n## [2,]    NA FALSE FALSE\n## [3,]    NA    NA    NA\n## [4,] FALSE  TRUE    NA\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE    NA    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE FALSE  TRUE\n## [4,] FALSE    NA FALSE\nbc.b(x, y, \"nand\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.b(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2] [,3]\n## [1,] FALSE    NA TRUE\n## [2,]    NA  TRUE TRUE\n## [3,]    NA    NA   NA\n## [4,]  TRUE FALSE   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]  TRUE   NA    NA\n## [2,] FALSE TRUE FALSE\n## [3,]  TRUE TRUE FALSE\n## [4,]  TRUE   NA  TRUE\nbc.b(x, y, \"!=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]  TRUE    NA FALSE\n## [2,]    NA FALSE FALSE\n## [3,]    NA    NA    NA\n## [4,] FALSE  TRUE    NA\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE    NA    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE FALSE  TRUE\n## [4,] FALSE    NA FALSE"
  },
  {
    "objectID": "man/bc.b.html#broadcasted-boolean-operations",
    "href": "man/bc.b.html#broadcasted-boolean-operations",
    "title": "bc.b",
    "section": "",
    "text": "The bc.b() function performs broadcasted Boolean operations on 2 logical (or 32bit integer) arrays.   Please note that these operations will treat the input as Boolean.  Therefore, something like bc.b(1, 2, “==”) returns TRUE, because both 1 and 2 are TRUE when cast as Boolean.  \n\n\n\nbc.b(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical (or 32bit integer) arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported Boolean operators: &, |, xor, nand, ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nA logical array as a result of the broadcasted Boolean operation.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.b(x, y, \"&\")\n## , , 1\n## \n##       [,1]  [,2] [,3]\n## [1,] FALSE    NA TRUE\n## [2,]    NA  TRUE TRUE\n## [3,]    NA    NA   NA\n## [4,]  TRUE FALSE   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]  TRUE   NA    NA\n## [2,] FALSE TRUE FALSE\n## [3,]  TRUE TRUE FALSE\n## [4,]  TRUE   NA  TRUE\nbc.b(x, y, \"|\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.b(x, y, \"xor\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]  TRUE    NA FALSE\n## [2,]    NA FALSE FALSE\n## [3,]    NA    NA    NA\n## [4,] FALSE  TRUE    NA\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE    NA    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE FALSE  TRUE\n## [4,] FALSE    NA FALSE\nbc.b(x, y, \"nand\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.b(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2] [,3]\n## [1,] FALSE    NA TRUE\n## [2,]    NA  TRUE TRUE\n## [3,]    NA    NA   NA\n## [4,]  TRUE FALSE   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]  TRUE   NA    NA\n## [2,] FALSE TRUE FALSE\n## [3,]  TRUE TRUE FALSE\n## [4,]  TRUE   NA  TRUE\nbc.b(x, y, \"!=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]  TRUE    NA FALSE\n## [2,]    NA FALSE FALSE\n## [3,]    NA    NA    NA\n## [4,] FALSE  TRUE    NA\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE    NA    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE FALSE  TRUE\n## [4,] FALSE    NA FALSE"
  },
  {
    "objectID": "man/aaa00_broadcast_help.html",
    "href": "man/aaa00_broadcast_help.html",
    "title": "R-package: broadcast",
    "section": "",
    "text": "broadcast:  Simple Broadcasted Binding and Binary Operations for Atomic and Recursive Arrays with Minimal Dependencies.   Implements simple broadcasted operations for atomic and recursive arrays.\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nThe implementations available in ‘broadcast’ include, but are not limited to, the following:\n\n\nA faster, more memory efficient, and broadcasted version of abind(), for binding arrays along an arbitrary dimension;\n\n\nA set of type-specific functions for broadcasted element-wise binary operations; they support a large set of relational-, arithmetic-, Boolean-, and string operations.\n\n\nA Broadcasted implementation of ifelse();\n\n\nA Broadcasted apply-like function;\n\n\nThe acast() function, for casting/pivoting an array into a new dimension.\n\n\nThe functions in the ‘broadcast’ package strive to minimize computation time and memory usage (which is not just good for efficient computing, but also for the environment).\n\n\n\nAn introduction and overview of the package can be found on the website.  Note that ‘broadcast’ is still somewhat experimental; if you find bugs or other issues, please report them promptly on the ‘broadcast’ GitHub page.  \n\n\n\nFunctions for broadcasted element-wise binary operations  ‘broadcast’ provides a set of functions for broadcasted element-wise binary operations with broadcasting.  These functions use an API similar to the outer function.   The following functions for type-specific binary operations are available:\n\n\nbc.b: Boolean operations;\n\n\nbc.i: integer (53bit) arithmetic and relational operations;\n\n\nbc.d: decimal (64bit) arithmetic and relational operations;\n\n\nbc.cplx: complex arithmetic and (in)equality operations;\n\n\nbc.str: string (in)equality, concatenation, and distance operations;\n\n\nbc.list: apply any ‘R’ function to 2 recursive arrays with broadcasting.  \n\n\nBinding Implementations  ‘broadcast’ provides the bind_array function, to bind arrays along an arbitrary dimension, with support for broadcasting.  \nGeneral functions  ‘broadcast’ also comes with 2 general broadcasted functions:\n\n\nbc_ifelse: Broadcasted version of ifelse.\n\n\nbcapply: Broadcasted apply-like function.  \n\n\nOther functions  ‘broadcast’ also provides type-casting functions, which preserve names and dimensions - convenient for arrays.  \n\n\n\nAuthor, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)"
  },
  {
    "objectID": "man/aaa00_broadcast_help.html#broadcast-simple-broadcasted-operations-for-atomic-and-recursive-arrays-with-minimal-dependencies",
    "href": "man/aaa00_broadcast_help.html#broadcast-simple-broadcasted-operations-for-atomic-and-recursive-arrays-with-minimal-dependencies",
    "title": "R-package: broadcast",
    "section": "",
    "text": "broadcast:  Simple Broadcasted Binding and Binary Operations for Atomic and Recursive Arrays with Minimal Dependencies.   Implements simple broadcasted operations for atomic and recursive arrays.\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nThe implementations available in ‘broadcast’ include, but are not limited to, the following:\n\n\nA faster, more memory efficient, and broadcasted version of abind(), for binding arrays along an arbitrary dimension;\n\n\nA set of type-specific functions for broadcasted element-wise binary operations; they support a large set of relational-, arithmetic-, Boolean-, and string operations.\n\n\nA Broadcasted implementation of ifelse();\n\n\nA Broadcasted apply-like function;\n\n\nThe acast() function, for casting/pivoting an array into a new dimension.\n\n\nThe functions in the ‘broadcast’ package strive to minimize computation time and memory usage (which is not just good for efficient computing, but also for the environment).\n\n\n\nAn introduction and overview of the package can be found on the website.  Note that ‘broadcast’ is still somewhat experimental; if you find bugs or other issues, please report them promptly on the ‘broadcast’ GitHub page.  \n\n\n\nFunctions for broadcasted element-wise binary operations  ‘broadcast’ provides a set of functions for broadcasted element-wise binary operations with broadcasting.  These functions use an API similar to the outer function.   The following functions for type-specific binary operations are available:\n\n\nbc.b: Boolean operations;\n\n\nbc.i: integer (53bit) arithmetic and relational operations;\n\n\nbc.d: decimal (64bit) arithmetic and relational operations;\n\n\nbc.cplx: complex arithmetic and (in)equality operations;\n\n\nbc.str: string (in)equality, concatenation, and distance operations;\n\n\nbc.list: apply any ‘R’ function to 2 recursive arrays with broadcasting.  \n\n\nBinding Implementations  ‘broadcast’ provides the bind_array function, to bind arrays along an arbitrary dimension, with support for broadcasting.  \nGeneral functions  ‘broadcast’ also comes with 2 general broadcasted functions:\n\n\nbc_ifelse: Broadcasted version of ifelse.\n\n\nbcapply: Broadcasted apply-like function.  \n\n\nOther functions  ‘broadcast’ also provides type-casting functions, which preserve names and dimensions - convenient for arrays.  \n\n\n\nAuthor, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)"
  },
  {
    "objectID": "about/f_benchmarks_other.html",
    "href": "about/f_benchmarks_other.html",
    "title": "Other benchmarks",
    "section": "",
    "text": "Introduction\nOn this page, the performance of the bind_array() function from ‘broadcast’ is compared to the performance of the abind() function from the ‘abind’ package.\n \nThe following code is used:\n\n\nalong &lt;- 2L\nn &lt;- 150L\nnms &lt;- function(n) sample(letters, n, TRUE)\nx &lt;- array(as.double(1:25), c(n, n, n))\ny &lt;- array(as.double(-1:-25), c(n, n, n))\ndimnames(x) &lt;- lapply(dim(x), nms)\ndimnames(y) &lt;- lapply(dim(y), nms)\ninput &lt;- list(x, y)\n\nbm_abind &lt;- bench::mark(\n  abind = abind::abind(input, along = 2),\n  broadcast = bind_array(input, 2),\n  cbind = do.call(cbind, input),\n  min_iterations = 100,\n  check = FALSE # because abind adds empty dimnames\n)\nsummary(bm_abind)\nplot(bm_abind)\n\nAnd here are the results:\n\nload(\"benchmarks/bm_abind.RData\")\nsummary(bm_abind)\n#&gt; # A data frame: 3 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 abind          69ms   79.5ms      11.0   206.3MB     12.9\n#&gt; 2 broadcast    23.5ms   30.9ms      28.0   103.4MB     22.7\n#&gt; 3 cbind         9.6ms   10.2ms      76.9    51.5MB     13.8\nplot(bm_abind)\n#&gt; Loading required namespace: tidyr"
  },
  {
    "objectID": "about/d_other_pkgs.html",
    "href": "about/d_other_pkgs.html",
    "title": "Other packages",
    "section": "",
    "text": "Alternatives to ‘broadcast’\nAt the time of writing, the only alternative to the ‘broadcast’ package with respect to having a large range of support for broadcasting, is using an  package that allows access to an external library from another programming language that does support ‘broadcasting’.\nFor example: Using the ‘reticulate’ package to access ‘Python’, and via that connection accessing the ‘Numpy’ module, which supports (and perhaps even had the first implementation) of broadcasting.\nAnother example is the ‘xtensor’ package (and extensiosn to that package, like ‘rray’), that allows  - users to access the ‘C++’ module of the same name.\nThese alternatives all need access to a different programming language, which brings with it a host of problems:\n\nDependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”).\nWasteful translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of  to that of the other language, and vice-versa, which wastes precious time, memory, and power.\nInconsistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour for some operations.\nFor example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas  supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’).\n\nSince the ‘broadcast’ package does not rely on any external library, other than linking to ‘Rcpp’, ‘broadcast’ avoids all of the above issues.\n \n\n\nComplimentary packages\nThe ‘broadcast’ fits well with the squarebrackets package, though that package is currently experimental, at the time of writing.\n \n\n\nThe tinyverse\nThe ‘broadcast’ package adheres to the ‘tinyverse’ philosophy (not to be confused with the ‘tidyverse’), which is the programming philosophy to primarily minimize dependencies, and secondarily to keep code efficient.\nOther  packages that share this philosophy include, but are not limited to, the following:\n\nthe core fastverse packages: ‘data.table’, ‘collapse’, and ‘kit’.\nstringi, the primary  package for string processing.\ntinycodet, for functions to help in coding etiquette.\ntinytable, for flexible table creation.\ntinyplot, for plotting graphs; much faster than, for example, ‘ggplot2’, and with zero dependencies.\ntinytest, for unit testing. Unlike ‘testthat’, ‘tinytest’ has zero dependencies.\nmatrixStats, for computing across rows or columns of matrices.\nand many others."
  },
  {
    "objectID": "about/b_NEWS.html",
    "href": "about/b_NEWS.html",
    "title": "Changelog",
    "section": "",
    "text": "…still testing…"
  },
  {
    "objectID": "about/a_acknowledgements.html",
    "href": "about/a_acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "Compiled code\nThe ‘broadcast’ package would not have been possible without the fantastic Rcpp package, which ‘broadcast’ links to.\nBesides linking to the aforementioned ‘Rcpp’, no code from external libraries (like ‘Numpy’ or ‘xtensor’) were used in any way whatsoever.\n \n\n\nUnit tests\nThe unit tests were facilitated using the impressive tinytest package.\n \n\n\nSite resources\nThe website itself was put together using ‘Quarto’ (out-of-the-box website producing packages, such as ‘pkgdown’ and ‘altdoc’, were not used).\nMost graphs on the website were created using the tinyplot package, and all tables were created using the tinytable package.\nSome of the icons were generated using the fontawesome package."
  },
  {
    "objectID": "about/c_LICENSE.html",
    "href": "about/c_LICENSE.html",
    "title": "License",
    "section": "",
    "text": "Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in\n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0."
  },
  {
    "objectID": "about/e_benchmarks_numpy.html#difficulties-in-comparing-with-python",
    "href": "about/e_benchmarks_numpy.html#difficulties-in-comparing-with-python",
    "title": "Benchmarks with Numpy",
    "section": "Difficulties in comparing  with ‘Python’",
    "text": "Difficulties in comparing  with ‘Python’\nBenchmarking a ‘Python’ code snippet in ‘Python’ using a ‘Python’ module, and benchmarking an  code snippet in  using an  package, means mechanisms from different modules/packages are used for the benchmarking, and those 2 benchmarks may not (and probably won’t) use the same timing mechanisms.\n‘Python’ and  are both languages that use garbage collections (GC). But GC really does mess up benchmarking. The way to circumvent this issue differs in ‘Python’ and . In ‘Python’, GC can temporarily be disabled.  does not support this, so instead for  benchmarks with heavy GC calls just had to be filtered out.\nDue to the above (and other) considerations, any form of benchmarks between  and ‘Python’ - including the ones given in this page - should be taken with a grain of salt."
  },
  {
    "objectID": "about/e_benchmarks_numpy.html#the-set-up",
    "href": "about/e_benchmarks_numpy.html#the-set-up",
    "title": "Benchmarks with Numpy",
    "section": "The Set-Up",
    "text": "The Set-Up\nThe operation that was bench-marked in this study, is the operation x + y in ‘Numpy’ and the equivalent bc. num(x, y, \"+\") in ‘broadcast’.\nHere x and y were both decimal numeric arrays (type of 64 bit double in  and 64 bit float in ‘Python’), and had the same number of dimensions.\nThis operation was run for pairs of arrays with different number of dimensions, going from 2 dimensional to 7 dimensional.\nSo we have x + y where both arrays were 2-dimensional (i.e. matrices), and x + y where both arrays were 3-dimensional, and so on up to 7-dimensional arrays.\nThe pairs of arrays are fully orthogonal (“orthogonal” in the sense as explained here), thus the maximum amount of broadcasting will be employed.\nGiven, for example, 4-dimensional arrays, the dimensions of x are (n, 1, n, 1) and the dimensions of y are (1, n, 1, n).\nThe value of n, so the size of each dimension, varied as follows:\n\nFor 2-dimensional arrays, n goes from 1250 to 9500, with step size 750.\nFor 3-dimensional arrays, n goes from 65 to 450, with step size 35.\nFor 4-dimensional arrays, n goes from 9 to 99, with step size 10.\nFor 5-dimensional arrays, n goes from 6 to 39, with step size 3.\nFor 6-dimensional arrays, n goes from 3 to 21, with step size 2.\nFor 7-dimensional arrays, n goes from 2 to 14, with step size 1.\n\nThese values n were chosen as follows. The maximum n was specified such that the broadcasted element-wise addition of x and y resulted in an array with between 90 to 100 million elements. The minimum n was chosen to be (approximately) one-seventh of the maximum n value. And the step size was set to a value such that the sequence had a length between 10 and 15\nFor each pair of arrays, the element-wise addition was computed using ‘broadcast’ and ‘Numpy’. This computation was repeated 100 times (though see some technical details about this in the next sub-section). From these 100 benchmarks, the median, first quartile, and third quartiles were computed. There are some caveats here, in order to keep the comparisons between ‘broadcast’ and ‘Numpy’ fair, and these caveats are explained in the next sub-section."
  },
  {
    "objectID": "about/e_benchmarks_numpy.html#keeping-comparisons-somewhat-fair",
    "href": "about/e_benchmarks_numpy.html#keeping-comparisons-somewhat-fair",
    "title": "Benchmarks with Numpy",
    "section": "Keeping comparisons (somewhat) fair",
    "text": "Keeping comparisons (somewhat) fair\nTo keep the comparisons between ‘broadcast’ and ‘Numpy’ fair, a number of measures have been taken.\nDistributions of benchmarks tend to be heavily skewed. Therefore, the median measure (together with the quartiles) were taken. The median is also more stable than the mean in the face of outliers.\nGarbage collection was disabled in Python. In , only benchmarks with no garbage collection, or level 0 garbage collection, were used. I feel this keeps the comparisons relatively fair (but it’s not perfect).\nSince only benchmarks with no garbage collection, or level 0 garbage collection, are used for , the benchmarks were run 200 times, and a check was performed that at least 100 benchmark measurements were kept in. If there were less than 100 benchmarks for a particular computation, the benchmarks would be thrown away, and another attempt would be made at benchmarking (but this never happened).\n has more support for missing values than ‘Numpy’, which also leads to a difference in speed. But both  and ‘Numpy’ handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in  ), through the NaN construct. Therefore, only operations on decimal numbers are compared.\nOperations like power (^) and division (/) need to handle special cases (like when the right-hand side of the operation is 0). I cannot guarantee that ‘broadcast’ and ‘Numpy’ will handle these special cases in the exact same way. The plus (+) operator, however, has no such special cases. Therefore, the comparisons on this page only involve summation."
  },
  {
    "objectID": "about/e_benchmarks_numpy.html#resources-used",
    "href": "about/e_benchmarks_numpy.html#resources-used",
    "title": "Benchmarks with Numpy",
    "section": "Resources used",
    "text": "Resources used\nThe ‘benchmark’ package was used for measuring speed in , as this package can also be used to check and filter for garbage collector calls.\nIn ‘Python’, the time.perf_counter() function is used to accurately measure the time an operation takes. To ensure no time is wasted on printing the result in ‘Python’, the operation a + b is wrapped inside a function without a return statement.\nThe plots are created using the ‘tinyplot’ package, to display the median, first quartile, and third quartile, of the computation times.\nThe benchmarks were run on a laptop (processor: 12th Gen Intel(R) Core(TM) i5-12500H 2.50 GHz) with 32GB of Ram and running Windows 11 (64 bit).\nThe code used to run the benchmarks can be found at the bottom of this page.  version 4.4.0 was used to run the  code, and ‘Python’ version 3.12.0 with ‘Numpy’ version 2.2.1 was used to run the ‘Python’ code"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "🗺️Overview",
    "text": "🗺️Overview\n‘broadcast’ is a relatively small  package that, as the name suggests, performs “broadcasting” (similar to broadcasting in the ‘Numpy’ module for ‘Python’).\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions replication mechanism.\nPlease read the article “Broadcasting explained” for a more complete explanation of what “broadcasting” is.\n \nAt its core, the ‘broadcast’ package provides 3 functionalities, all 3 related to “broadcasting”:\n \nFirst, ‘broadcast’ provides functions for broadcasted element-wise binary operations between any 2 arrays. They support a large set of relational-, arithmetic-, Boolean-, and string operations.\nThese functions have clear broadcasting rules, making it easy to accurately predict the dimensions of the result.\n \nSecond, ‘broadcast’ provides the bind_array() function, which is a broadcasted and enhanced form of the fantastic abind::abind() function:\n\nbind_array() allows for broadcasting (obviously), whereas abind::abind() does not.\nbind_array() is significantly faster and uses less memory than abind::abind().\nbind_array() also differs from abind::abind() in that it can handle recursive arrays properly; abind::abind() unlists everything to atomic arrays, ruining the structure.\n\n \nThird, ‘broadcast’ provides several generic functions for broadcasting:\n\nbcapply(): a broadcasted apply-like function that works on pairs of arrays.\nbc_ifelse(): a broadcasted ifelse() function. Broadcasts between the yes and no arguments.\n\n \nAdditionally, ‘broadcast’ includes the acast() function, for casting/pivoting an array into a new dimension. Roughly analogous to data.table::dcast(), but for arrays."
  },
  {
    "objectID": "index.html#why-use-broadcast",
    "href": "index.html#why-use-broadcast",
    "title": "Introduction",
    "section": "🤷🏽Why use ‘broadcast’",
    "text": "🤷🏽Why use ‘broadcast’\nEfficiency\nBroadcasting dimensions is faster and more memory efficient than replicating dimensions.\nEfficient programs use less energy and resources, and is thus better for the environment.\nAs a favoured language for the sciences,  should not throw away an opportunity to become more efficient.\nThe Benchmarks show that ‘broadcast’ has a somewhat similar speed as equivalent operations in ‘Numpy’.\n \nConvenience\nHave you ever been bothered by any of the following while programming in :\n\nabind::abind() being too slow, saying arrays are not conformable, and/or coercing recursive arrays to character arrays?\nthat there is no built-in way to cast or pivot arrays?\nReceiving the “non-conformable arrays” error message in a simple operation when it intuitively should work?\nReceiving the “Error: cannot allocate vector of size” error message because  unnecessarily allocates too much memory?\nTrying to perform a simple operation on all possible combinations, only to find out you need nested loops and/or grid expansions to do something that should be very simple?\n\nIf you answered “YES” to any of the above, ‘broadcast’ may very well be the  - package for you.\n \nMinimal Dependencies\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nNot using external libraries brings a number of advantages:\n\nAvoid dependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”). ‘broadcast’ thus avoids this.\nAvoid wasting resources for translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of  to that of the other language, and vice-versa, which wastes precious time, memory, and power. ‘broadcast’ requires no such translations of structures, and is therefore much less wasteful.\nEnsure consistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour for some operations. For example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas  supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’). Since ‘broadcast’ does not rely on external libraries, it can ensure behaviour that is consistent with the rest of .\n\n \nTested\nThe ‘broadcast’ package is frequently checked using a large suite of unit tests via the tinytest package. These tests have a coverage of approximately 95%. As such, the chance of a function from this package breaking is relatively low.\nSince ‘broadcast’ is still relatively new package, bugs are still very much possible. I encourage users who find bugs to report them swiftly to the GitHub page, and I will fix them as soon as time permits."
  },
  {
    "objectID": "index.html#quick-example",
    "href": "index.html#quick-example",
    "title": "Introduction",
    "section": "🚀Quick Example",
    "text": "🚀Quick Example\nConsider the matrices x and y:\n\nx &lt;- array(1:20, c(4, 5))\ny &lt;- array(1:5*10, c(1, 5))\nprint(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nSuppose one wishes to compute the element-wise addition of these 2 arrays.\nThis won’t work in base :\n\nx + y\nError in x + y : non-conformable arrays\n\nWhen computing the element-wise sum of these arrays, they both need to be recycled to equal size in order to compute the element-wise computation.\nI.e. y needs its single row to be recycled 4 times, creating 2 conformable matrices.\nYou could do the following….\n\nx + y[rep(1L, 4L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70\n\n… but this becomes an issue when x and/or y become very large, as the above operation involves replicating/copying y several times - which costs memory, reduces speed, and the code is not easily scalable for arrays with different dimensions.\nThe ‘broadcast’ package performs “broadcasting”, which can do the above, but faster, without unnecessary copies, and scalable to arrays of any size (up to 16 dimensions), like so:\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "Introduction",
    "section": "📖Documentation",
    "text": "📖Documentation\nThe documentation in the ‘broadcast’ website is divided into 3 main parts:\n\nGuides and Vignettes: contains the topic-oriented guides in the form of a few Vignettes.\nReference Manual: contains the function-oriented reference manual.\nAbout: Contains the Acknowledgements, Change logs and License file. Here you’ll also find some information regarding the relationship between ‘broadcast’ and other  packages"
  },
  {
    "objectID": "man/acast.html",
    "href": "man/acast.html",
    "title": "acast",
    "section": "",
    "text": "The acast() function spreads subsets of an array margin over a new dimension.  Written in ‘C’ and ‘C++’ for high speed and memory efficiency.   Roughly speaking, acast() can be thought of as the \"array\" analogy to data.table::dcast().  But note 2 important differences:\n\n\nacast() works on arrays instead of data.tables.\n\n\nacast() casts into a completely new dimension (namely ndim(x) + 1), instead of casting into new columns.\n\n\n\n\n\nacast(\n  x,\n  margin,\n  grp,\n  fill = FALSE,\n  fill_val = if (is.atomic(x)) NA else list(NULL)\n)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array.\n\n\n\n\nmargin\n\n\na scalar integer, specifying the margin to cast from.\n\n\n\n\ngrp\n\n\na factor, where length(grp) == dim(x)[margin], with at least 2 unique values, specifying which indices of dim(x)[margin] belong to which group.  Each group will be cast onto a separate index of dimension ndim(x) + 1.  Unused levels of grp will be dropped.  Any NA values or levels found in grp will result in an error.\n\n\n\n\nfill\n\n\nBoolean.  When factor grp is unbalanced (i.e. has unequally sized groups) the result will be an array where some slices have missing values, which need to be filled. If fill = TRUE, an unbalanced grp factor is allowed, and missing values will be filled with fill_val.  If fill = FALSE (default), an unbalanced grp factor is not allowed, and providing an unbalanced factor for grp produces an error.  When x has type of raw, unbalanced grp is never allowed.\n\n\n\n\nfill_val\n\n\nscalar of the same type of x, giving value to use to fill in the gaps when fill = TRUE.  The fill_val argument is ignored when fill = FALSE or when x has type of raw.\n\n\n\n\n\n\n\nFor the sake of illustration, consider a matrix x and a grouping factor grp.  Let the integer scalar k represent a group in grp, such that k \\(\\in\\) 1:nlevels(grp).  Then the code  out = acast(x, margin = 1, grp = grp)  essentially performs the following for every group k:\n\n\ncopy-paste the subset x[grp == k, ] to the subset out[, , k].\n\n\nPlease see the examples section to get a good idea on how this function casts an array.  A more detailed explanation of the acast() function can be found on the website.  \n\n\n\nAn array with the following properties:\n\n\nthe number of dimensions of the output array is equal to ndim(x) + 1;\n\n\nthe dimensions of the output array is equal to c(dim(x), max(tabulate(grp));\n\n\nthe dimnames of the output array is equal to c(dimnames(x), list(levels(grp))).  \n\n\n\n\n\nFrom the casted array,  out = acast(x, margin, grp),  one can get the original x back by using  back = asplit(out, ndim(out)) |&gt; bind_array(along = margin).  Note, however, the following about the back-transformed array back:\n\n\nback will be ordered by grp along dimension margin;\n\n\nif the levels of grp did not have equal frequencies, then dim(back)[margin] &gt; dim(x)[margin], and back will have more missing values than x.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- cbind(id = c(rep(1:3, each = 2), 1), grp = c(rep(1:2, 3), 2), val = rnorm(7))\nprint(x)\n##      id grp        val\n## [1,]  1   1 -0.3522636\n## [2,]  1   2 -1.0548565\n## [3,]  2   1  1.2500079\n## [4,]  2   2  0.9756140\n## [5,]  3   1  0.9914535\n## [6,]  3   2  1.7870643\n## [7,]  1   2  1.7280354\n\ngrp &lt;- as.factor(x[, 2])\nlevels(grp) &lt;- c(\"a\", \"b\")\nmargin &lt;- 1L\n\nacast(x, margin, grp, fill = TRUE)\n## , , a\n## \n##      id grp        val\n## [1,]  1   1 -0.3522636\n## [2,]  2   1  1.2500079\n## [3,]  3   1  0.9914535\n## [4,] NA  NA         NA\n## \n## , , b\n## \n##      id grp       val\n## [1,]  1   2 -1.054857\n## [2,]  2   2  0.975614\n## [3,]  3   2  1.787064\n## [4,]  1   2  1.728035"
  },
  {
    "objectID": "man/acast.html#simple-and-fast-castingpivoting-of-an-array",
    "href": "man/acast.html#simple-and-fast-castingpivoting-of-an-array",
    "title": "acast",
    "section": "",
    "text": "The acast() function spreads subsets of an array margin over a new dimension.  Written in ‘C’ and ‘C++’ for high speed and memory efficiency.   Roughly speaking, acast() can be thought of as the \"array\" analogy to data.table::dcast().  But note 2 important differences:\n\n\nacast() works on arrays instead of data.tables.\n\n\nacast() casts into a completely new dimension (namely ndim(x) + 1), instead of casting into new columns.\n\n\n\n\n\nacast(\n  x,\n  margin,\n  grp,\n  fill = FALSE,\n  fill_val = if (is.atomic(x)) NA else list(NULL)\n)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array.\n\n\n\n\nmargin\n\n\na scalar integer, specifying the margin to cast from.\n\n\n\n\ngrp\n\n\na factor, where length(grp) == dim(x)[margin], with at least 2 unique values, specifying which indices of dim(x)[margin] belong to which group.  Each group will be cast onto a separate index of dimension ndim(x) + 1.  Unused levels of grp will be dropped.  Any NA values or levels found in grp will result in an error.\n\n\n\n\nfill\n\n\nBoolean.  When factor grp is unbalanced (i.e. has unequally sized groups) the result will be an array where some slices have missing values, which need to be filled. If fill = TRUE, an unbalanced grp factor is allowed, and missing values will be filled with fill_val.  If fill = FALSE (default), an unbalanced grp factor is not allowed, and providing an unbalanced factor for grp produces an error.  When x has type of raw, unbalanced grp is never allowed.\n\n\n\n\nfill_val\n\n\nscalar of the same type of x, giving value to use to fill in the gaps when fill = TRUE.  The fill_val argument is ignored when fill = FALSE or when x has type of raw.\n\n\n\n\n\n\n\nFor the sake of illustration, consider a matrix x and a grouping factor grp.  Let the integer scalar k represent a group in grp, such that k \\(\\in\\) 1:nlevels(grp).  Then the code  out = acast(x, margin = 1, grp = grp)  essentially performs the following for every group k:\n\n\ncopy-paste the subset x[grp == k, ] to the subset out[, , k].\n\n\nPlease see the examples section to get a good idea on how this function casts an array.  A more detailed explanation of the acast() function can be found on the website.  \n\n\n\nAn array with the following properties:\n\n\nthe number of dimensions of the output array is equal to ndim(x) + 1;\n\n\nthe dimensions of the output array is equal to c(dim(x), max(tabulate(grp));\n\n\nthe dimnames of the output array is equal to c(dimnames(x), list(levels(grp))).  \n\n\n\n\n\nFrom the casted array,  out = acast(x, margin, grp),  one can get the original x back by using  back = asplit(out, ndim(out)) |&gt; bind_array(along = margin).  Note, however, the following about the back-transformed array back:\n\n\nback will be ordered by grp along dimension margin;\n\n\nif the levels of grp did not have equal frequencies, then dim(back)[margin] &gt; dim(x)[margin], and back will have more missing values than x.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- cbind(id = c(rep(1:3, each = 2), 1), grp = c(rep(1:2, 3), 2), val = rnorm(7))\nprint(x)\n##      id grp        val\n## [1,]  1   1 -0.3522636\n## [2,]  1   2 -1.0548565\n## [3,]  2   1  1.2500079\n## [4,]  2   2  0.9756140\n## [5,]  3   1  0.9914535\n## [6,]  3   2  1.7870643\n## [7,]  1   2  1.7280354\n\ngrp &lt;- as.factor(x[, 2])\nlevels(grp) &lt;- c(\"a\", \"b\")\nmargin &lt;- 1L\n\nacast(x, margin, grp, fill = TRUE)\n## , , a\n## \n##      id grp        val\n## [1,]  1   1 -0.3522636\n## [2,]  2   1  1.2500079\n## [3,]  3   1  0.9914535\n## [4,] NA  NA         NA\n## \n## , , b\n## \n##      id grp       val\n## [1,]  1   2 -1.054857\n## [2,]  2   2  0.975614\n## [3,]  3   2  1.787064\n## [4,]  1   2  1.728035"
  },
  {
    "objectID": "man/bc.cplx.html",
    "href": "man/bc.cplx.html",
    "title": "bc.cplx",
    "section": "",
    "text": "The bc.cplx() function performs broadcasted complex numeric operations pairs of arrays.   Note that bc.cplx() uses more strict NA checks than base ‘R’:  If for an element of either x or y, either the real or imaginary part is NA or NaN, than the result of the operation for that element is necessarily NA. \n\n\n\nbc.cplx(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type complex.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /.  Supported relational operators: ==, !=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A complex array as a result of the broadcasted arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\ngen &lt;- function() sample(c(rnorm(10), NA, NA, NaN, NaN, Inf, Inf, -Inf, -Inf))\nx &lt;- array(gen() + gen() * -1i, x.dim)\ny &lt;- array(gen() + gen() * -1i, c(4,1,1))\n\nbc.cplx(x, y, \"==\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]    NA   NA    NA\n## [2,]    NA   NA    NA\n## [3,] FALSE   NA FALSE\n## [4,]    NA   NA    NA\nbc.cplx(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,] TRUE   NA TRUE\n## [4,]   NA   NA   NA\n\nbc.cplx(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##               [,1] [,2]           [,3]\n## [1,]            NA   NA             NA\n## [2,]            NA   NA             NA\n## [3,] Inf+1.723794i   NA Inf-0.4579423i\n## [4,]            NA   NA             NA\n\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"==\")\n##  [1]    NA    NA    NA    NA    NA    NA    NA    NA FALSE    NA    NA FALSE\n## [13]    NA    NA    NA    NA    NA    NA\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"!=\")\n##  [1]   NA TRUE   NA   NA TRUE   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n## [16]   NA   NA   NA\n\nx &lt;- gen() + gen() * -1i\ny &lt;- gen() + gen() * -1i\nout &lt;- bc.cplx(array(x), array(y), \"*\")\ncbind(x, y, x*y, out)\n##                            x                       y                        \n##  [1,]        NaN+       Infi         NaN+       NaNi         NaN+       NaNi\n##  [2,]        Inf+0.35825091i -0.03600920+0.54745653i        -Inf+       Infi\n##  [3,]        Inf-0.37186135i                      NA         NaN-       Infi\n##  [4,] -0.1690462-0.02828919i  0.44102425+0.36861194i -0.06412576-0.07478868i\n##  [5,] -0.3659832+0.81246215i         NaN+       Infi        -Inf-       Infi\n##  [6,]                     NA                      NA                      NA\n##  [7,] -0.5781897-0.82925528i         NaN-1.41882323i         NaN+       NaNi\n##  [8,]       -Inf+0.91220018i        -Inf+1.01541055i         Inf-       Infi\n##  [9,]                     NA  1.22846673-0.60307926i                      NA\n## [10,]                     NA  0.09490571-0.61298877i        -Inf-       Infi\n## [11,]        NaN+       NaNi         NaN+       NaNi         NaN+       NaNi\n## [12,]                     NA         NaN+       Infi         NaN+       NaNi\n## [13,]  1.5653536+1.08759096i -2.25827636-0.03143679i -3.50081064-2.50529064i\n## [14,]        NaN-       Infi                      NA         NaN+       NaNi\n## [15,]        NaN-0.89854929i                      NA                      NA\n## [16,]  1.5962948-1.02123577i         Inf+1.09232581i         Inf-       Infi\n## [17,]  0.8103137+1.25225728i         NaN-       Infi         Inf-       Infi\n## [18,]        NaN+       Infi  0.04802723+0.07226508i        -Inf+       Infi\n##                           out\n##  [1,]                      NA\n##  [2,]        -Inf+       Infi\n##  [3,]                      NA\n##  [4,] -0.06412576-0.07478868i\n##  [5,]                      NA\n##  [6,]                      NA\n##  [7,]                      NA\n##  [8,]         Inf-       Infi\n##  [9,]                      NA\n## [10,]                      NA\n## [11,]                      NA\n## [12,]                      NA\n## [13,] -3.50081064-2.50529064i\n## [14,]                      NA\n## [15,]                      NA\n## [16,]         Inf-       Infi\n## [17,]                      NA\n## [18,]                      NA"
  },
  {
    "objectID": "man/bc.cplx.html#broadcasted-complex-numeric-operations",
    "href": "man/bc.cplx.html#broadcasted-complex-numeric-operations",
    "title": "bc.cplx",
    "section": "",
    "text": "The bc.cplx() function performs broadcasted complex numeric operations pairs of arrays.   Note that bc.cplx() uses more strict NA checks than base ‘R’:  If for an element of either x or y, either the real or imaginary part is NA or NaN, than the result of the operation for that element is necessarily NA. \n\n\n\nbc.cplx(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type complex.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /.  Supported relational operators: ==, !=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A complex array as a result of the broadcasted arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\ngen &lt;- function() sample(c(rnorm(10), NA, NA, NaN, NaN, Inf, Inf, -Inf, -Inf))\nx &lt;- array(gen() + gen() * -1i, x.dim)\ny &lt;- array(gen() + gen() * -1i, c(4,1,1))\n\nbc.cplx(x, y, \"==\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##       [,1] [,2]  [,3]\n## [1,]    NA   NA    NA\n## [2,]    NA   NA    NA\n## [3,] FALSE   NA FALSE\n## [4,]    NA   NA    NA\nbc.cplx(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,] TRUE   NA TRUE\n## [4,]   NA   NA   NA\n\nbc.cplx(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##               [,1] [,2]           [,3]\n## [1,]            NA   NA             NA\n## [2,]            NA   NA             NA\n## [3,] Inf+1.723794i   NA Inf-0.4579423i\n## [4,]            NA   NA             NA\n\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"==\")\n##  [1]    NA    NA    NA    NA    NA    NA    NA    NA FALSE    NA    NA FALSE\n## [13]    NA    NA    NA    NA    NA    NA\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"!=\")\n##  [1]   NA TRUE   NA   NA TRUE   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n## [16]   NA   NA   NA\n\nx &lt;- gen() + gen() * -1i\ny &lt;- gen() + gen() * -1i\nout &lt;- bc.cplx(array(x), array(y), \"*\")\ncbind(x, y, x*y, out)\n##                            x                       y                        \n##  [1,]        NaN+       Infi         NaN+       NaNi         NaN+       NaNi\n##  [2,]        Inf+0.35825091i -0.03600920+0.54745653i        -Inf+       Infi\n##  [3,]        Inf-0.37186135i                      NA         NaN-       Infi\n##  [4,] -0.1690462-0.02828919i  0.44102425+0.36861194i -0.06412576-0.07478868i\n##  [5,] -0.3659832+0.81246215i         NaN+       Infi        -Inf-       Infi\n##  [6,]                     NA                      NA                      NA\n##  [7,] -0.5781897-0.82925528i         NaN-1.41882323i         NaN+       NaNi\n##  [8,]       -Inf+0.91220018i        -Inf+1.01541055i         Inf-       Infi\n##  [9,]                     NA  1.22846673-0.60307926i                      NA\n## [10,]                     NA  0.09490571-0.61298877i        -Inf-       Infi\n## [11,]        NaN+       NaNi         NaN+       NaNi         NaN+       NaNi\n## [12,]                     NA         NaN+       Infi         NaN+       NaNi\n## [13,]  1.5653536+1.08759096i -2.25827636-0.03143679i -3.50081064-2.50529064i\n## [14,]        NaN-       Infi                      NA         NaN+       NaNi\n## [15,]        NaN-0.89854929i                      NA                      NA\n## [16,]  1.5962948-1.02123577i         Inf+1.09232581i         Inf-       Infi\n## [17,]  0.8103137+1.25225728i         NaN-       Infi         Inf-       Infi\n## [18,]        NaN+       Infi  0.04802723+0.07226508i        -Inf+       Infi\n##                           out\n##  [1,]                      NA\n##  [2,]        -Inf+       Infi\n##  [3,]                      NA\n##  [4,] -0.06412576-0.07478868i\n##  [5,]                      NA\n##  [6,]                      NA\n##  [7,]                      NA\n##  [8,]         Inf-       Infi\n##  [9,]                      NA\n## [10,]                      NA\n## [11,]                      NA\n## [12,]                      NA\n## [13,] -3.50081064-2.50529064i\n## [14,]                      NA\n## [15,]                      NA\n## [16,]         Inf-       Infi\n## [17,]                      NA\n## [18,]                      NA"
  },
  {
    "objectID": "man/bc.i.html",
    "href": "man/bc.i.html",
    "title": "bc.i",
    "section": "",
    "text": "The bc.i() function performs broadcasted integer numeric operations on 2 numeric or logical arrays.   Please note that these operations will treat the input as 53bit integers, and will efficiently truncate when necessary.  Therefore, something like bc.i(1, 1.5, “==”) returns TRUE, because trunc(1.5) equals 1.  \n\n\n\nbc.i(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, gcd, %%, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=.  The \"gcd\" operator performs the Greatest Common Divisor\" operation, using the Euclidean algorithm.. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array of whole numbers, as a result of the broadcasted arithmetic operation.  Base ‘R’ supports 53 bit integers, which thus range from approximately -9 quadrillion to +9 quadrillion.  Values outside of this range will be returned as -Inf or Inf, as an extra protection against integer overflow.   For relational operators:  A logical array as a result of the broadcasted integer relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.i(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  959   45  292\n## [2,]  842  279  635\n## [3,]  231  655   50\n## [4,]  255  882  849\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   19  950  717\n## [2,]  202  578  923\n## [3,]  933  144  944\n## [4,]  793  532  547\nbc.i(x, y, \"-\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  957   43  290\n## [2,]  838  275  631\n## [3,]  225  649   44\n## [4,]  247  874  841\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   17  948  715\n## [2,]  198  574  919\n## [3,]  927  138  938\n## [4,]  785  524  539\nbc.i(x, y, \"*\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  958   44  291\n## [2,] 1680  554 1266\n## [3,]  684 1956  141\n## [4,] 1004 3512 3380\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   18  949  716\n## [2,]  400 1152 1842\n## [3,] 2790  423 2823\n## [4,] 3156 2112 2172\nbc.i(x, y, \"gcd\") # greatest common divisor\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    1    1\n## [3,]    3    1    1\n## [4,]    1    2    1\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    2    1\n## [3,]    3    3    1\n## [4,]    1    4    1\nbc.i(x, y, \"^\")\n## , , 1\n## \n##            [,1]         [,2]         [,3]\n## [1,]        958           44          291\n## [2,]     705600        76729       400689\n## [3,]   11852352    277167808       103823\n## [4,] 3969126001 594262141456 509831700625\n## \n## , , 2\n## \n##              [,1]        [,2]        [,3]\n## [1,]           18         949         716\n## [2,]        40000      331776      848241\n## [3,]    804357000     2803221   833237621\n## [4,] 387532395441 77720518656 86935932801\n\nbc.i(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.i.html#broadcasted-integer-numeric-operations-with-extra-overflow-protection",
    "href": "man/bc.i.html#broadcasted-integer-numeric-operations-with-extra-overflow-protection",
    "title": "bc.i",
    "section": "",
    "text": "The bc.i() function performs broadcasted integer numeric operations on 2 numeric or logical arrays.   Please note that these operations will treat the input as 53bit integers, and will efficiently truncate when necessary.  Therefore, something like bc.i(1, 1.5, “==”) returns TRUE, because trunc(1.5) equals 1.  \n\n\n\nbc.i(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, gcd, %%, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=.  The \"gcd\" operator performs the Greatest Common Divisor\" operation, using the Euclidean algorithm.. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array of whole numbers, as a result of the broadcasted arithmetic operation.  Base ‘R’ supports 53 bit integers, which thus range from approximately -9 quadrillion to +9 quadrillion.  Values outside of this range will be returned as -Inf or Inf, as an extra protection against integer overflow.   For relational operators:  A logical array as a result of the broadcasted integer relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.i(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  959   45  292\n## [2,]  842  279  635\n## [3,]  231  655   50\n## [4,]  255  882  849\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   19  950  717\n## [2,]  202  578  923\n## [3,]  933  144  944\n## [4,]  793  532  547\nbc.i(x, y, \"-\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  957   43  290\n## [2,]  838  275  631\n## [3,]  225  649   44\n## [4,]  247  874  841\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   17  948  715\n## [2,]  198  574  919\n## [3,]  927  138  938\n## [4,]  785  524  539\nbc.i(x, y, \"*\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  958   44  291\n## [2,] 1680  554 1266\n## [3,]  684 1956  141\n## [4,] 1004 3512 3380\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   18  949  716\n## [2,]  400 1152 1842\n## [3,] 2790  423 2823\n## [4,] 3156 2112 2172\nbc.i(x, y, \"gcd\") # greatest common divisor\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    1    1\n## [3,]    3    1    1\n## [4,]    1    2    1\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    2    1\n## [3,]    3    3    1\n## [4,]    1    4    1\nbc.i(x, y, \"^\")\n## , , 1\n## \n##            [,1]         [,2]         [,3]\n## [1,]        958           44          291\n## [2,]     705600        76729       400689\n## [3,]   11852352    277167808       103823\n## [4,] 3969126001 594262141456 509831700625\n## \n## , , 2\n## \n##              [,1]        [,2]        [,3]\n## [1,]           18         949         716\n## [2,]        40000      331776      848241\n## [3,]    804357000     2803221   833237621\n## [4,] 387532395441 77720518656 86935932801\n\nbc.i(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.str.html",
    "href": "man/bc.str.html",
    "title": "bc.str",
    "section": "",
    "text": "The bc.str() function performs broadcasted string operations on pairs of arrays.  \n\n\n\nbc.str(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type character.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported concatenation operators: +.  Supported relational operators: ==, !=.  Supported distance operators: levenshtein. \n\n\n\n\n\n\n\nFor concatenation operation:  A character array as a result of the broadcasted concatenation operation.   For relational operation:  A logical array as a result of the broadcasted relational comparison.   For distance operation:  An integer array as a result of the broadcasted distance measurement.  \n\n\n\nThe ‘C++’ code for the Levenshtein edit string distance is based on the code found in https://rosettacode.org/wiki/Levenshtein_distance#C++\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# string concatenation:\nx &lt;- array(letters, c(10, 2, 1))\ny &lt;- array(letters, c(10,1,1))\nbc.str(x, y, \"+\")\n## , , 1\n## \n##       [,1] [,2]\n##  [1,] \"aa\" \"ka\"\n##  [2,] \"bb\" \"lb\"\n##  [3,] \"cc\" \"mc\"\n##  [4,] \"dd\" \"nd\"\n##  [5,] \"ee\" \"oe\"\n##  [6,] \"ff\" \"pf\"\n##  [7,] \"gg\" \"qg\"\n##  [8,] \"hh\" \"rh\"\n##  [9,] \"ii\" \"si\"\n## [10,] \"jj\" \"tj\"\n\n\n# string (in)equality:\nbc.str(array(letters), array(letters), \"==\")\n##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\nbc.str(array(letters), array(letters), \"!=\")\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE\n\n\n# string distance (Levenshtein):\nx &lt;- array(month.name, c(12, 1))\ny &lt;- array(month.abb, c(1, 12))\nout &lt;- bc.str(x, y, \"levenshtein\")\ndimnames(out) &lt;- list(month.name, month.abb)\nprint(out)\n##           Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n## January     4   7   5   6   5   5   5   6   7   7   7   7\n## February    7   5   6   7   6   7   7   7   7   8   8   7\n## March       4   5   2   4   3   5   5   5   5   4   5   4\n## April       5   5   4   2   5   5   4   4   5   5   5   5\n## May         2   3   1   3   0   3   3   3   3   3   3   3\n## June        2   4   4   4   4   1   2   3   4   4   4   4\n## July        3   4   4   4   3   2   1   3   4   4   4   4\n## August      6   6   6   5   6   5   5   3   6   5   6   6\n## September   9   7   8   7   9   9   9   9   6   8   9   8\n## October     7   6   6   6   7   7   7   7   6   4   6   6\n## November    8   6   7   7   8   8   8   8   7   8   5   7\n## December    8   6   7   7   8   8   8   8   7   7   8   5"
  },
  {
    "objectID": "man/bc.str.html#broadcasted-string-operations",
    "href": "man/bc.str.html#broadcasted-string-operations",
    "title": "bc.str",
    "section": "",
    "text": "The bc.str() function performs broadcasted string operations on pairs of arrays.  \n\n\n\nbc.str(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type character.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported concatenation operators: +.  Supported relational operators: ==, !=.  Supported distance operators: levenshtein. \n\n\n\n\n\n\n\nFor concatenation operation:  A character array as a result of the broadcasted concatenation operation.   For relational operation:  A logical array as a result of the broadcasted relational comparison.   For distance operation:  An integer array as a result of the broadcasted distance measurement.  \n\n\n\nThe ‘C++’ code for the Levenshtein edit string distance is based on the code found in https://rosettacode.org/wiki/Levenshtein_distance#C++\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# string concatenation:\nx &lt;- array(letters, c(10, 2, 1))\ny &lt;- array(letters, c(10,1,1))\nbc.str(x, y, \"+\")\n## , , 1\n## \n##       [,1] [,2]\n##  [1,] \"aa\" \"ka\"\n##  [2,] \"bb\" \"lb\"\n##  [3,] \"cc\" \"mc\"\n##  [4,] \"dd\" \"nd\"\n##  [5,] \"ee\" \"oe\"\n##  [6,] \"ff\" \"pf\"\n##  [7,] \"gg\" \"qg\"\n##  [8,] \"hh\" \"rh\"\n##  [9,] \"ii\" \"si\"\n## [10,] \"jj\" \"tj\"\n\n\n# string (in)equality:\nbc.str(array(letters), array(letters), \"==\")\n##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\nbc.str(array(letters), array(letters), \"!=\")\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE\n\n\n# string distance (Levenshtein):\nx &lt;- array(month.name, c(12, 1))\ny &lt;- array(month.abb, c(1, 12))\nout &lt;- bc.str(x, y, \"levenshtein\")\ndimnames(out) &lt;- list(month.name, month.abb)\nprint(out)\n##           Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n## January     4   7   5   6   5   5   5   6   7   7   7   7\n## February    7   5   6   7   6   7   7   7   7   8   8   7\n## March       4   5   2   4   3   5   5   5   5   4   5   4\n## April       5   5   4   2   5   5   4   4   5   5   5   5\n## May         2   3   1   3   0   3   3   3   3   3   3   3\n## June        2   4   4   4   4   1   2   3   4   4   4   4\n## July        3   4   4   4   3   2   1   3   4   4   4   4\n## August      6   6   6   5   6   5   5   3   6   5   6   6\n## September   9   7   8   7   9   9   9   9   6   8   9   8\n## October     7   6   6   6   7   7   7   7   6   4   6   6\n## November    8   6   7   7   8   8   8   8   7   8   5   7\n## December    8   6   7   7   8   8   8   8   7   7   8   5"
  },
  {
    "objectID": "man/bc_dim.html",
    "href": "man/bc_dim.html",
    "title": "bc_dim",
    "section": "",
    "text": "bc_dim(x, y) gives the dimensions an array would have, as the result of an broadcasted binary element-wise operation between 2 arrays x and y.\n\n\n\nbc_dim(x, y)\n\n\n\n\n\n\n\n\nx, y\n\n\nan atomic or recursive array.\n\n\n\n\n\n\n\nReturns the recycled array.\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\ndim(bc.b(x, y, \"&\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE\ndim(bc.b(x, y, \"|\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc_dim.html#predict-broadcasted-dimensions",
    "href": "man/bc_dim.html#predict-broadcasted-dimensions",
    "title": "bc_dim",
    "section": "",
    "text": "bc_dim(x, y) gives the dimensions an array would have, as the result of an broadcasted binary element-wise operation between 2 arrays x and y.\n\n\n\nbc_dim(x, y)\n\n\n\n\n\n\n\n\nx, y\n\n\nan atomic or recursive array.\n\n\n\n\n\n\n\nReturns the recycled array.\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\ndim(bc.b(x, y, \"&\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE\ndim(bc.b(x, y, \"|\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bind_array.html",
    "href": "man/bind_array.html",
    "title": "bind_array",
    "section": "",
    "text": "bind_array() binds (atomic/recursive) arrays and (atomic/recursive) matrices.  Returns an array.  Allows for broadcasting.\n\n\n\nbind_array(\n  input,\n  along,\n  rev = FALSE,\n  ndim2bc = 1L,\n  name_along = TRUE,\n  comnames_from = 1L\n)\n\n\n\n\n\n\n\n\ninput\n\n\na list of arrays; both atomic and recursive arrays are supported, and can be mixed.  If input is named, its names will be used for the names of dimension along of the output, when necessary.  If argument input has length 0, or it contains exclusively objects where one or more dimensions are 0, an error is returned.  If input has length 1, this function simply return input[[1L]].\n\n\n\n\nalong\n\n\na single integer, indicating the dimension along which to bind the dimensions.  I.e. use along = 1 for row-binding, along = 2 for column-binding, etc.  Specifying along = 0 will bind the arrays on a new dimension before the first, making along the new first dimension.  Specifying along = N + 1, with N = max(lst.ndim(input)), will create an additional dimension (N + 1) and bind the arrays along that new dimension.\n\n\n\n\nrev\n\n\nBoolean, indicating if along should be reversed, counting backwards.  If FALSE (default), along works like normally; if TRUE, along is reversed.  I.e. along = 0, rev = TRUE is equivalent to along = N+1, rev = FALSE;  and along = N+1, rev = TRUE is equivalent to along = 0, rev = FALSE;  with N = max(lst.ndim(input)).\n\n\n\n\nndim2bc\n\n\na single non-negative integer;  specify here the maximum number of dimensions that are allowed to be broadcasted when binding arrays.  If ndim2bc = 0L, no broadcasting will be allowed at all.\n\n\n\n\nname_along\n\n\nBoolean, ndicating if dimension along should be named.  The examples section illustrates the naming behaviour.\n\n\n\n\ncomnames_from\n\n\neither integer scalar or NULL.  Indicates which object in input should be used for naming the shared dimension.  If NULL, no communal names will be given.  For example:  When binding columns of matrices, the matrices will share the same rownames.  Using comnames_from = 10 will then result in bind_array() using rownames(input[[10]]) for the rownames of the output.  \n\n\n\n\n\n\n\nThe API of bind_array() is inspired by the fantastic abind::abind() function by Tony Plare & Richard Heiberger (2016).  But bind_array() differs considerably from abind::abind in the following ways:\n\n\nbind_array() differs from abind::abind in that it can handle recursive arrays properly  (the abind::abind function would unlist everything to atomic arrays, ruining the structure).\n\n\nbind_array() allows for broadcasting, while abind::abind does not support broadcasting.\n\n\nbind_array() is generally faster than abind::abind, as bind_array() relies heavily on ‘C’ and ‘C++’ code.\n\n\nunlike abind::abind, bind_array() only binds (atomic/recursive) arrays and matrices.  bind_array()does not attempt to convert things to arrays when they are not arrays, but will give an error instead.  This saves computation time and prevents unexpected results.\n\n\nbind_array() has more streamlined naming options, compared to abind::abind.  \n\n\n\n\n\nAn array.\n\n\n\nPlate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# Simple example ====\nx &lt;- array(1:20, c(5, 4))\ny &lt;- array(-1:-15, c(5, 3))\nz &lt;- array(21:40, c(5, 4))\ninput &lt;- list(x, y, z)\n# column binding:\nbind_array(input, 2L)\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n## [1,]    1    6   11   16   -1   -6  -11   21   26    31    36\n## [2,]    2    7   12   17   -2   -7  -12   22   27    32    37\n## [3,]    3    8   13   18   -3   -8  -13   23   28    33    38\n## [4,]    4    9   14   19   -4   -9  -14   24   29    34    39\n## [5,]    5   10   15   20   -5  -10  -15   25   30    35    40\n\n\n\n# Mixing types ====\n# here, atomic and recursive arrays are mixed,\n# resulting in recursive arrays\n\n# creating the arrays:\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n) |&gt; matrix(4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\nz &lt;- matrix(letters[1:12], c(4, 3))\n\n# column-binding:\ninput &lt;- list(x = x, y = y, z = z)\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3 z.1 z.2 z.3\n## a logical,3    logical,3    logical,3    1   5   9   \"a\" \"e\" \"i\"\n## b integer,10   integer,10   integer,10   2   6   10  \"b\" \"f\" \"j\"\n## c numeric,10   numeric,10   numeric,10   3   7   11  \"c\" \"g\" \"k\"\n## d character,26 character,26 character,26 4   8   12  \"d\" \"h\" \"l\"\n\n\n\n# Illustrating `along` argument ====\n# using recursive arrays for clearer visual distinction\ninput &lt;- list(x = x, y = y)\n\nbind_array(input, along = 0L) # binds on new dimension before first\n## , , A\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , B\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , C\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\nbind_array(input, along = 1L) # binds on first dimension (i.e. rows)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 3L) # bind on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\n\nbind_array(input, along = 0L, TRUE) # binds on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\nbind_array(input, along = 1L, TRUE) # binds on last dimension (i.e. columns)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 2L, TRUE)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 3L, TRUE) # bind on new dimension before first\n## , , A\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , B\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , C\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\n\n\n\n# binding, with empty arrays ====\nemptyarray &lt;- array(numeric(0L), c(0L, 3L))\ndimnames(emptyarray) &lt;- list(NULL, paste(\"empty\", 1:3))\nprint(emptyarray)\n##      empty 1 empty 2 empty 3\ninput &lt;- list(x = x, y = emptyarray)\nbind_array(input, along = 1L, comnames_from = 2L) # row-bind\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\n\n\n# Illustrating `name_along` ====\nx &lt;- array(1:20, c(5, 3), list(NULL, LETTERS[1:3]))\ny &lt;- array(-1:-20, c(5, 3))\nz &lt;- array(-1:-20, c(5, 3))\n\nbind_array(list(a = x, b = y, z), 2L)\n##      A  B  C b.1 b.2 b.3           \n## [1,] 1  6 11  -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12  -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13  -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14  -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15  -5 -10 -15 -5 -10 -15\nbind_array(list(x, y, z), 2L)\n##      A  B  C                      \n## [1,] 1  6 11 -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12 -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13 -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14 -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15 -5 -10 -15 -5 -10 -15\nbind_array(list(a = unname(x), b = y, c = z), 2L)\n##      a.1 a.2 a.3 b.1 b.2 b.3 c.1 c.2 c.3\n## [1,]   1   6  11  -1  -6 -11  -1  -6 -11\n## [2,]   2   7  12  -2  -7 -12  -2  -7 -12\n## [3,]   3   8  13  -3  -8 -13  -3  -8 -13\n## [4,]   4   9  14  -4  -9 -14  -4  -9 -14\n## [5,]   5  10  15  -5 -10 -15  -5 -10 -15\nbind_array(list(x, a = y, b = z), 2L)\n##      A  B  C a.1 a.2 a.3 b.1 b.2 b.3\n## [1,] 1  6 11  -1  -6 -11  -1  -6 -11\n## [2,] 2  7 12  -2  -7 -12  -2  -7 -12\n## [3,] 3  8 13  -3  -8 -13  -3  -8 -13\n## [4,] 4  9 14  -4  -9 -14  -4  -9 -14\n## [5,] 5 10 15  -5 -10 -15  -5 -10 -15\ninput &lt;- list(x, y, z)\nnames(input) &lt;- c(\"\", NA, \"\")\nbind_array(input, 2L)\n##      A  B  C                      \n## [1,] 1  6 11 -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12 -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13 -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14 -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15 -5 -10 -15 -5 -10 -15"
  },
  {
    "objectID": "man/bind_array.html#dimensional-binding-of-arrays-with-broadcasting",
    "href": "man/bind_array.html#dimensional-binding-of-arrays-with-broadcasting",
    "title": "bind_array",
    "section": "",
    "text": "bind_array() binds (atomic/recursive) arrays and (atomic/recursive) matrices.  Returns an array.  Allows for broadcasting.\n\n\n\nbind_array(\n  input,\n  along,\n  rev = FALSE,\n  ndim2bc = 1L,\n  name_along = TRUE,\n  comnames_from = 1L\n)\n\n\n\n\n\n\n\n\ninput\n\n\na list of arrays; both atomic and recursive arrays are supported, and can be mixed.  If input is named, its names will be used for the names of dimension along of the output, when necessary.  If argument input has length 0, or it contains exclusively objects where one or more dimensions are 0, an error is returned.  If input has length 1, this function simply return input[[1L]].\n\n\n\n\nalong\n\n\na single integer, indicating the dimension along which to bind the dimensions.  I.e. use along = 1 for row-binding, along = 2 for column-binding, etc.  Specifying along = 0 will bind the arrays on a new dimension before the first, making along the new first dimension.  Specifying along = N + 1, with N = max(lst.ndim(input)), will create an additional dimension (N + 1) and bind the arrays along that new dimension.\n\n\n\n\nrev\n\n\nBoolean, indicating if along should be reversed, counting backwards.  If FALSE (default), along works like normally; if TRUE, along is reversed.  I.e. along = 0, rev = TRUE is equivalent to along = N+1, rev = FALSE;  and along = N+1, rev = TRUE is equivalent to along = 0, rev = FALSE;  with N = max(lst.ndim(input)).\n\n\n\n\nndim2bc\n\n\na single non-negative integer;  specify here the maximum number of dimensions that are allowed to be broadcasted when binding arrays.  If ndim2bc = 0L, no broadcasting will be allowed at all.\n\n\n\n\nname_along\n\n\nBoolean, ndicating if dimension along should be named.  The examples section illustrates the naming behaviour.\n\n\n\n\ncomnames_from\n\n\neither integer scalar or NULL.  Indicates which object in input should be used for naming the shared dimension.  If NULL, no communal names will be given.  For example:  When binding columns of matrices, the matrices will share the same rownames.  Using comnames_from = 10 will then result in bind_array() using rownames(input[[10]]) for the rownames of the output.  \n\n\n\n\n\n\n\nThe API of bind_array() is inspired by the fantastic abind::abind() function by Tony Plare & Richard Heiberger (2016).  But bind_array() differs considerably from abind::abind in the following ways:\n\n\nbind_array() differs from abind::abind in that it can handle recursive arrays properly  (the abind::abind function would unlist everything to atomic arrays, ruining the structure).\n\n\nbind_array() allows for broadcasting, while abind::abind does not support broadcasting.\n\n\nbind_array() is generally faster than abind::abind, as bind_array() relies heavily on ‘C’ and ‘C++’ code.\n\n\nunlike abind::abind, bind_array() only binds (atomic/recursive) arrays and matrices.  bind_array()does not attempt to convert things to arrays when they are not arrays, but will give an error instead.  This saves computation time and prevents unexpected results.\n\n\nbind_array() has more streamlined naming options, compared to abind::abind.  \n\n\n\n\n\nAn array.\n\n\n\nPlate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# Simple example ====\nx &lt;- array(1:20, c(5, 4))\ny &lt;- array(-1:-15, c(5, 3))\nz &lt;- array(21:40, c(5, 4))\ninput &lt;- list(x, y, z)\n# column binding:\nbind_array(input, 2L)\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n## [1,]    1    6   11   16   -1   -6  -11   21   26    31    36\n## [2,]    2    7   12   17   -2   -7  -12   22   27    32    37\n## [3,]    3    8   13   18   -3   -8  -13   23   28    33    38\n## [4,]    4    9   14   19   -4   -9  -14   24   29    34    39\n## [5,]    5   10   15   20   -5  -10  -15   25   30    35    40\n\n\n\n# Mixing types ====\n# here, atomic and recursive arrays are mixed,\n# resulting in recursive arrays\n\n# creating the arrays:\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n) |&gt; matrix(4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\nz &lt;- matrix(letters[1:12], c(4, 3))\n\n# column-binding:\ninput &lt;- list(x = x, y = y, z = z)\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3 z.1 z.2 z.3\n## a logical,3    logical,3    logical,3    1   5   9   \"a\" \"e\" \"i\"\n## b integer,10   integer,10   integer,10   2   6   10  \"b\" \"f\" \"j\"\n## c numeric,10   numeric,10   numeric,10   3   7   11  \"c\" \"g\" \"k\"\n## d character,26 character,26 character,26 4   8   12  \"d\" \"h\" \"l\"\n\n\n\n# Illustrating `along` argument ====\n# using recursive arrays for clearer visual distinction\ninput &lt;- list(x = x, y = y)\n\nbind_array(input, along = 0L) # binds on new dimension before first\n## , , A\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , B\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , C\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\nbind_array(input, along = 1L) # binds on first dimension (i.e. rows)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 3L) # bind on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\n\nbind_array(input, along = 0L, TRUE) # binds on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\nbind_array(input, along = 1L, TRUE) # binds on last dimension (i.e. columns)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 2L, TRUE)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 3L, TRUE) # bind on new dimension before first\n## , , A\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , B\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , C\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\n\n\n\n# binding, with empty arrays ====\nemptyarray &lt;- array(numeric(0L), c(0L, 3L))\ndimnames(emptyarray) &lt;- list(NULL, paste(\"empty\", 1:3))\nprint(emptyarray)\n##      empty 1 empty 2 empty 3\ninput &lt;- list(x = x, y = emptyarray)\nbind_array(input, along = 1L, comnames_from = 2L) # row-bind\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\n\n\n# Illustrating `name_along` ====\nx &lt;- array(1:20, c(5, 3), list(NULL, LETTERS[1:3]))\ny &lt;- array(-1:-20, c(5, 3))\nz &lt;- array(-1:-20, c(5, 3))\n\nbind_array(list(a = x, b = y, z), 2L)\n##      A  B  C b.1 b.2 b.3           \n## [1,] 1  6 11  -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12  -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13  -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14  -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15  -5 -10 -15 -5 -10 -15\nbind_array(list(x, y, z), 2L)\n##      A  B  C                      \n## [1,] 1  6 11 -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12 -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13 -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14 -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15 -5 -10 -15 -5 -10 -15\nbind_array(list(a = unname(x), b = y, c = z), 2L)\n##      a.1 a.2 a.3 b.1 b.2 b.3 c.1 c.2 c.3\n## [1,]   1   6  11  -1  -6 -11  -1  -6 -11\n## [2,]   2   7  12  -2  -7 -12  -2  -7 -12\n## [3,]   3   8  13  -3  -8 -13  -3  -8 -13\n## [4,]   4   9  14  -4  -9 -14  -4  -9 -14\n## [5,]   5  10  15  -5 -10 -15  -5 -10 -15\nbind_array(list(x, a = y, b = z), 2L)\n##      A  B  C a.1 a.2 a.3 b.1 b.2 b.3\n## [1,] 1  6 11  -1  -6 -11  -1  -6 -11\n## [2,] 2  7 12  -2  -7 -12  -2  -7 -12\n## [3,] 3  8 13  -3  -8 -13  -3  -8 -13\n## [4,] 4  9 14  -4  -9 -14  -4  -9 -14\n## [5,] 5 10 15  -5 -10 -15  -5 -10 -15\ninput &lt;- list(x, y, z)\nnames(input) &lt;- c(\"\", NA, \"\")\nbind_array(input, 2L)\n##      A  B  C                      \n## [1,] 1  6 11 -1  -6 -11 -1  -6 -11\n## [2,] 2  7 12 -2  -7 -12 -2  -7 -12\n## [3,] 3  8 13 -3  -8 -13 -3  -8 -13\n## [4,] 4  9 14 -4  -9 -14 -4  -9 -14\n## [5,] 5 10 15 -5 -10 -15 -5 -10 -15"
  },
  {
    "objectID": "man/rep_dim.html",
    "href": "man/rep_dim.html",
    "title": "rep_dim",
    "section": "",
    "text": "The rep_dim() function replicates array dimensions until the specified dimension sizes are reached, and returns the array.   The various broadcasting functions recycle array dimensions virtually, meaning little to no additional memory is needed.  The rep_dim() function, however, physically replicates the dimensions of an array (and thus actually occupies additional memory space).  \n\n\n\nrep_dim(x, tdim)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array or matrix.\n\n\n\n\ntdim\n\n\nan integer vector, giving the target dimension to reach.\n\n\n\n\n\n\n\nReturns the replicated array.\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- matrix(1:9, 3,3)\ncolnames(x) &lt;- LETTERS[1:3]\nrownames(x) &lt;- letters[1:3]\nnames(x) &lt;- month.abb[1:9]\nprint(x)\n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## attr(,\"names\")\n## [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\n\nrep_dim(x, c(3,3,2)) # replicate to larger size\n## , , 1\n## \n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## \n## , , 2\n## \n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9"
  },
  {
    "objectID": "man/rep_dim.html#replicate-array-dimensions",
    "href": "man/rep_dim.html#replicate-array-dimensions",
    "title": "rep_dim",
    "section": "",
    "text": "The rep_dim() function replicates array dimensions until the specified dimension sizes are reached, and returns the array.   The various broadcasting functions recycle array dimensions virtually, meaning little to no additional memory is needed.  The rep_dim() function, however, physically replicates the dimensions of an array (and thus actually occupies additional memory space).  \n\n\n\nrep_dim(x, tdim)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array or matrix.\n\n\n\n\ntdim\n\n\nan integer vector, giving the target dimension to reach.\n\n\n\n\n\n\n\nReturns the replicated array.\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- matrix(1:9, 3,3)\ncolnames(x) &lt;- LETTERS[1:3]\nrownames(x) &lt;- letters[1:3]\nnames(x) &lt;- month.abb[1:9]\nprint(x)\n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## attr(,\"names\")\n## [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\n\nrep_dim(x, c(3,3,2)) # replicate to larger size\n## , , 1\n## \n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## \n## , , 2\n## \n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9"
  },
  {
    "objectID": "vignettes/a_readme.html#overview",
    "href": "vignettes/a_readme.html#overview",
    "title": "Introduction",
    "section": "🗺️Overview",
    "text": "🗺️Overview\n‘broadcast’ is a relatively small  package that, as the name suggests, performs “broadcasting” (similar to broadcasting in the ‘Numpy’ module for ‘Python’).\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions replication mechanism.\nPlease read the article “Broadcasting explained” for a more complete explanation of what “broadcasting” is.\n \nAt its core, the ‘broadcast’ package provides 3 functionalities, all 3 related to “broadcasting”:\n \nFirst, ‘broadcast’ provides functions for broadcasted element-wise binary operations between any 2 arrays. They support a large set of relational-, arithmetic-, Boolean-, and string operations.\nThese functions have clear broadcasting rules, making it easy to accurately predict the dimensions of the result.\n \nSecond, ‘broadcast’ provides the bind_array() function, which is a broadcasted and enhanced form of the fantastic abind::abind() function:\n\nbind_array() allows for broadcasting (obviously), whereas abind::abind() does not.\nbind_array() is significantly faster and uses less memory than abind::abind().\nbind_array() also differs from abind::abind() in that it can handle recursive arrays properly; abind::abind() unlists everything to atomic arrays, ruining the structure.\n\n \nThird, ‘broadcast’ provides several generic functions for broadcasting:\n\nbcapply(): a broadcasted apply-like function that works on pairs of arrays.\nbc_ifelse(): a broadcasted ifelse() function. Broadcasts between the yes and no arguments.\n\n \nAdditionally, ‘broadcast’ includes the acast() function, for casting/pivoting an array into a new dimension. Roughly analogous to data.table::dcast(), but for arrays."
  },
  {
    "objectID": "vignettes/a_readme.html#why-use-broadcast",
    "href": "vignettes/a_readme.html#why-use-broadcast",
    "title": "Introduction",
    "section": "🤷🏽Why use ‘broadcast’",
    "text": "🤷🏽Why use ‘broadcast’\nEfficiency\nBroadcasting dimensions is faster and more memory efficient than replicating dimensions.\nEfficient programs use less energy and resources, and is thus better for the environment.\nAs a favoured language for the sciences,  should not throw away an opportunity to become more efficient.\nThe Benchmarks show that ‘broadcast’ has a somewhat similar speed as equivalent operations in ‘Numpy’.\n \nConvenience\nHave you ever been bothered by any of the following while programming in :\n\nabind::abind() being too slow, saying arrays are not conformable, and/or coercing recursive arrays to character arrays?\nthat there is no built-in way to cast or pivot arrays?\nReceiving the “non-conformable arrays” error message in a simple operation when it intuitively should work?\nReceiving the “Error: cannot allocate vector of size” error message because  unnecessarily allocates too much memory?\nTrying to perform a simple operation on all possible combinations, only to find out you need nested loops and/or grid expansions to do something that should be very simple?\n\nIf you answered “YES” to any of the above, ‘broadcast’ may very well be the  - package for you.\n \nMinimal Dependencies\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nNot using external libraries brings a number of advantages:\n\nAvoid dependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”). ‘broadcast’ thus avoids this.\nAvoid wasting resources for translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of  to that of the other language, and vice-versa, which wastes precious time, memory, and power. ‘broadcast’ requires no such translations of structures, and is therefore much less wasteful.\nEnsure consistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour for some operations. For example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas  supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’). Since ‘broadcast’ does not rely on external libraries, it can ensure behaviour that is consistent with the rest of .\n\n \nTested\nThe ‘broadcast’ package is frequently checked using a large suite of unit tests via the tinytest package. These tests have a coverage of approximately 95%. As such, the chance of a function from this package breaking is relatively low.\nSince ‘broadcast’ is still relatively new package, bugs are still very much possible. I encourage users who find bugs to report them swiftly to the GitHub page, and I will fix them as soon as time permits."
  },
  {
    "objectID": "vignettes/a_readme.html#quick-example",
    "href": "vignettes/a_readme.html#quick-example",
    "title": "Introduction",
    "section": "🚀Quick Example",
    "text": "🚀Quick Example\nConsider the matrices x and y:\n\nx &lt;- array(1:20, c(4, 5))\ny &lt;- array(1:5*10, c(1, 5))\nprint(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nSuppose one wishes to compute the element-wise addition of these 2 arrays.\nThis won’t work in base :\n\nx + y\nError in x + y : non-conformable arrays\n\nWhen computing the element-wise sum of these arrays, they both need to be recycled to equal size in order to compute the element-wise computation.\nI.e. y needs its single row to be recycled 4 times, creating 2 conformable matrices.\nYou could do the following….\n\nx + y[rep(1L, 4L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70\n\n… but this becomes an issue when x and/or y become very large, as the above operation involves replicating/copying y several times - which costs memory, reduces speed, and the code is not easily scalable for arrays with different dimensions.\nThe ‘broadcast’ package performs “broadcasting”, which can do the above, but faster, without unnecessary copies, and scalable to arrays of any size (up to 16 dimensions), like so:\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   25   39   53   67\n#&gt; [2,]   12   26   40   54   68\n#&gt; [3,]   13   27   41   55   69\n#&gt; [4,]   14   28   42   56   70"
  },
  {
    "objectID": "vignettes/a_readme.html#documentation",
    "href": "vignettes/a_readme.html#documentation",
    "title": "Introduction",
    "section": "📖Documentation",
    "text": "📖Documentation\nThe documentation in the ‘broadcast’ website is divided into 3 main parts:\n\nGuides and Vignettes: contains the topic-oriented guides in the form of a few Vignettes.\nReference Manual: contains the function-oriented reference manual.\nAbout: Contains the Acknowledgements, Change logs and License file. Here you’ll also find some information regarding the relationship between ‘broadcast’ and other  packages"
  },
  {
    "objectID": "vignettes/c_functions.html#why-another-array-binding-function",
    "href": "vignettes/c_functions.html#why-another-array-binding-function",
    "title": "Functions Overview",
    "section": "Why another array binding function",
    "text": "Why another array binding function\nThere is already a famous, battle-tested function for binding arrays, namely the abind() function from the fantastic  package of the same name. So why does ‘broadcast’ provide another array binding function?\nWell, as great as abind::abind() is, there are some issues with it, and the bind_array() function from ’broadcast` attempts (and in my humble opinion succeeds) to provide a better alternative:\n\nabind() is a bit slow. bind_array() is significantly faster.\nabind() does not support broadcasting. bind_array() does support broadcasting.\nabind() does not support recursive arrays (i.e. arrays of type list). When binding recursive arrays, abind() will attempt to unlist it, even when it does not make sense, ruining the structure of the array. bind_array() fully supports recursive arrays, as well as arrays of all atomic types.\nabind() has somewhat confusing mechanisms for giving dimension names to the output. bind_array() has more streamlined naming arguments.\n\nbind_array() uses a similar API to that of abind::abind(), and provides similar features like binding arrays before the first dimension (using along = 0) or after the last dimension."
  },
  {
    "objectID": "vignettes/e_binding_explained.html",
    "href": "vignettes/e_binding_explained.html",
    "title": "Broadcasted Dimensional Binding Explained",
    "section": "",
    "text": "This page explains some details on broadcasting that are specific to the bind_array() function.\n \nThe bind_array() function binds 2 or more arrays together along a dimension, and fully supports broadcasting. While it’s relatively easy to reason about broadcasting when it involves only 2 arrays, reasoning about broadcasting when it involves more than 2 arrays becomes a bit more difficult. Therefore, bind_array() comes with the ndim2bc argument (an abbreviation of ” maximum number of dimensions to broadcast”), which allows users to specify the maximum number of dimensions that are allowed to be broadcasted while binding arrays. This way, users won’t get unpleasant surprises.\nThis should be fairly obvious, but the dimension specified in along is never broadcasted.\n \nBy default, ndim2bc is set to 1. This means that, by default, bind_array() will broadcast no more than 1 dimension for each array in the input list, when necessary.\nConsider the following arrays:\n\n\nx &lt;- array(1:20, c(4, 5))\ny &lt;- array(1:5*10, c(1, 5))\nprint(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nBinding them together with abind() won’t work:\n\nabind::abind(x, y, along = 2)\nError in abind::abind(x, y, along = 2) : \n  arg 'X2' has dims=1, 5; but need dims=4, X\n\nTo bind x and y together along columns, y needs its single row to be recycled (broadcasted) 4 times.\nThis can be done in a highly efficient way using bind_array(), like so:\n\nbind_array(list(x, y), 2L)\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    5    9   13   17   10   20   30   40    50\n#&gt; [2,]    2    6   10   14   18   10   20   30   40    50\n#&gt; [3,]    3    7   11   15   19   10   20   30   40    50\n#&gt; [4,]    4    8   12   16   20   10   20   30   40    50\n\n \nBut what if broadcasting is explicitly not desired? What if one actually wants this to produce an error, like abind()? Fret not, for that’s what the ndim2bc argument is for. Setting it to 0 will disable broadcasting altogether:\n\nbind_array(list(x, y), 2L, ndim2bc = 0)\nError in bind_array(list(x, y), 2L, ndim2bc = 0) : \n  maximum number of dimensions to be broadcasted (1) exceeds `ndim2bc` (0)\n\n \nLet’s replace x with a 3 dimensional array:\n\nx &lt;- array(1:20, c(4, 5, 3))\nprint(x)\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    5    9   13   17\n#&gt; [2,]    2    6   10   14   18\n#&gt; [3,]    3    7   11   15   19\n#&gt; [4,]    4    8   12   16   20\n\nTrying to bind x with y now will produce an error even with bind_array(), to protect the user from unintended broadcasting:\n\nbind_array(list(x, y), 2L)\nError in bind_array(list(x, y), 2L) : \n  maximum number of dimensions to be broadcasted (2) exceeds `ndim2bc` (1)\n\nIf you know you actually do want to broadcast multiple dimensions, simply increase ndim2bc:\n\nbind_array(list(x, y), 2L, ndim2bc = 3L)\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    5    9   13   17   10   20   30   40    50\n#&gt; [2,]    2    6   10   14   18   10   20   30   40    50\n#&gt; [3,]    3    7   11   15   19   10   20   30   40    50\n#&gt; [4,]    4    8   12   16   20   10   20   30   40    50\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    5    9   13   17   10   20   30   40    50\n#&gt; [2,]    2    6   10   14   18   10   20   30   40    50\n#&gt; [3,]    3    7   11   15   19   10   20   30   40    50\n#&gt; [4,]    4    8   12   16   20   10   20   30   40    50\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    5    9   13   17   10   20   30   40    50\n#&gt; [2,]    2    6   10   14   18   10   20   30   40    50\n#&gt; [3,]    3    7   11   15   19   10   20   30   40    50\n#&gt; [4,]    4    8   12   16   20   10   20   30   40    50"
  },
  {
    "objectID": "about/e_benchmarks_numpy.html#resources-and-code",
    "href": "about/e_benchmarks_numpy.html#resources-and-code",
    "title": "Benchmarks with Numpy",
    "section": "Resources and Code",
    "text": "Resources and Code\nThe ‘benchmark’ package was used for measuring speed in , as this package can also be used to check and filter for garbage collector calls.\nIn ‘Python’, the time.perf_counter() function was used to accurately measure the time an operation takes. To ensure no time was wasted on printing the result in ‘Python’, the operation a + b was wrapped inside a function without a return statement.\nThe figures in the Results section were created using the ‘tinyplot’ package, to display the median, first quartile, and third quartile, of the computation times.\nThe benchmarks were all run on the same computer (processor: 12th Gen Intel(R) Core(TM) i5-12500H @ 2.50 GHz) with 32GB of Ram and running the Windows 11 OS (64 bit).\nThe code used to run the benchmarks can be found at the bottom of this page.  version 4.4.0 was used to run the  code, and ‘Python’ version 3.12.0 with ‘Numpy’ version 2.2.1 was used to run the ‘Python’ code.\nThe  code was sourced from the ‘RGui’, from a freshly started computer. The ‘Python’ code was run via ‘Jupyter’, also from a freshly started computer. This is to ensure that neither code was slowed down due to prior RAM usage or background processes."
  },
  {
    "objectID": "about/Untitled.html",
    "href": "about/Untitled.html",
    "title": "R-package: broadcast",
    "section": "",
    "text": "import sys\n!{sys.executable} -m pip install numpy\n\nCollecting numpy\n  Downloading numpy-2.2.4-cp313-cp313-win_amd64.whl.metadata (60 kB)\nDownloading numpy-2.2.4-cp313-cp313-win_amd64.whl (12.6 MB)\n   ---------------------------------------- 0.0/12.6 MB ? eta -:--:--\n   --------- ------------------------------ 2.9/12.6 MB 14.9 MB/s eta 0:00:01\n   --------------------- ------------------ 6.8/12.6 MB 16.4 MB/s eta 0:00:01\n   ----------------------------- ---------- 9.4/12.6 MB 15.3 MB/s eta 0:00:01\n   ---------------------------------------  12.6/12.6 MB 15.5 MB/s eta 0:00:01\n   ---------------------------------------- 12.6/12.6 MB 14.4 MB/s eta 0:00:00\nInstalling collected packages: numpy\nSuccessfully installed numpy-2.2.4\n\n\n\n[notice] A new release of pip is available: 24.3.1 -&gt; 25.0.1\n[notice] To update, run: python.exe -m pip install --upgrade pip\n\n\n\n# set-up #\nimport numpy as np\nimport gc\nfrom time import perf_counter\ndef myfunc(a, b):\n  a + b\n\n\n\n# 2d array #\nprint(\"2d\")\ngc.disable()\ndimsizes = np.arange(1250, 9501, 750)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1)\n  bdims = (1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_2d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_2d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_2d_q3.txt\", q3_np)\n# end 2d array #\n\n\n\n# 3d array #\nprint(\"3d\")\ngc.disable()\ndimsizes = np.arange(65, 451, 35)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n)\n  bdims = (1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_3d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_3d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_3d_q3.txt\", q3_np)\n# end 3d array #\n\n\n\n\n# 4d array #\nprint(\"4d\")\ngc.disable()\ndimsizes = np.arange(9, 100, 10)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1)\n  bdims = (1, n, 1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_4d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_4d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_4d_q3.txt\", q3_np)\n# end 4d array #\n\n\n# 5d array #\nprint(\"5d\")\ngc.disable()\ndimsizes = np.arange(6, 40, 3)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n)\n  bdims = (1, n, 1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_5d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_5d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_5d_q3.txt\", q3_np)\n# end 5d array #\n\n\n\n\n# 6d array #\nprint(\"6d\")\ngc.disable()\ndimsizes = np.arange(3, 22, 2)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n, 1)\n  bdims = (1, n, 1, n, 1, n)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_6d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_6d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_6d_q3.txt\", q3_np)\n# end 5d array #\n\n\n\n# 7d array #\nprint(\"7d\")\ngc.disable()\ndimsizes = np.arange(2, 15, 1)\nmedian_np = np.zeros(len(dimsizes))\nq1_np = np.zeros(len(dimsizes))\nq3_np = np.zeros(len(dimsizes))\ndurations = np.zeros(100)\n\nfor i in range(0, len(dimsizes)):\n  print(i)\n  n = dimsizes[i]\n  adims = (n, 1, n, 1, n, 1, n)\n  bdims = (1, n, 1, n, 1, n, 1)\n  x = np.random.random_sample(adims)\n  y = np.random.random_sample(bdims)\n  \n  for j in range(0, len(durations)):\n    t1_start = perf_counter()\n    myfunc(x, y)\n    t1_stop = perf_counter()\n    durations[j] = (t1_stop-t1_start) * 1000\n  \n  median_np[i] = np.median(durations)\n  q1_np[i] = np.quantile(durations, 0.25)\n  q3_np[i] = np.quantile(durations, 0.75)\n\ngc.collect()\n\nnp.savetxt(\"benchmarks/bm_py_7d_median.txt\", median_np)\nnp.savetxt(\"benchmarks/bm_py_7d_q1.txt\", q1_np)\nnp.savetxt(\"benchmarks/bm_py_7d_q3.txt\", q3_np)\n# end 7d array #\n\n2d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n3d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n4d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n5d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n6d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n7d\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12"
  }
]