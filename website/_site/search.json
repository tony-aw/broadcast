[
  {
    "objectID": "vignettes/f_benchmarks.html",
    "href": "vignettes/f_benchmarks.html",
    "title": "Benchmarks with Numpy+reticulate",
    "section": "",
    "text": "Introduction\nIn this article, the speed of ‘broadcast’ is compared to the speed of ‘Numpy’ via {reticulate}.\n \n\n\nKeeping comparisons fair\nTo keep the comparisons between ‘broadcast’ and ‘Numpy’+‘reticulate’ fair, a number of measures have been taken:\n\nconversion from Numpy to ‘R’ is DISABLED; this allows for comparing the speed more fairly. When conversion would be enabled, precious time would be wasted to convert from Numpy structures to comparable ‘R’ structures.\ngarbage collection is disabled in reticulate’s Python. In ‘R’, only benchmarks with no garbage collection, or level 0 garbage collection, is used. I feel this keeps the comparisons relatively fair (but it’s not perfect).\n‘R’ has more support for missing values than ‘Numpy’, which also leads to a difference in speed. But both ‘R’ and ‘Numpy’ handle missing values equally in decimal numbers ( 64bit floats in Numpy and 64bit doubles in ‘R’ ), through the NaN construct. Therefore, only operations on decimal numbers are compared.\n\n \n\n\nMany Orthogonal Arrays\n8 pairs of decimal number arrays are created in both ‘R’ and ‘Numpy’. They all have a length of (approximately) 9*10^6 elements. Each pair will have a different number of dimensions, from 2 to 9 (hence 8 pairs of arrays). I.e. a pair of 2d arrays, a pair of 3d arrays, etc.\nThese pairs of arrays are fully orthogonal, thus the maximum amount of broadcasting will be employed.\nFor each pair of array the outer sum is computed using ‘broadcast’ and ‘Numpy’. This computation is repeated 100 times, and the median result is taken.\nThus we get the following code:\n\n# set-up ====\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp &lt;- rt$import(\"numpy\", convert = FALSE)\ngc &lt;- rt$import(\"gc\", convert = FALSE)\nget_times &lt;- function(obj, j) {\n  nms &lt;- names(res$expression)\n  j &lt;- which(nms == j)\n  idx &lt;- rowSums(obj$gc[[j]][, 2:3]) == 0\n  times &lt;- obj$time[[j]][idx]\n  return(times)\n}\ngc$disable()\n\n# loop\nmedian_bc &lt;- median_np &lt;- q1_bc &lt;- q1_np &lt;- q3_bc &lt;- q3_np &lt;- vector(\"numeric\", 8)\ncounter &lt;- 1L\ntarget_len &lt;- 9e6\n\nfor(i in 2:9) {\n  print(i)\n  n &lt;- round(target_len^(1/i)) |&gt; as.integer()\n  len &lt;- n^i\n  cat(\"i = \", i, \"\\n\")\n  cat(\"n = \", n, \"\\n\")\n  cat(\"len = \", len, \"\\n\")\n  x.dims &lt;- rep(c(n, 1L), i - 1)[1:i]\n  y.dims &lt;- rep(c(1L, n), i - 1)[1:i]\n  a.dims &lt;- rt$r_to_py(as.list(x.dims))\n  b.dims &lt;- rt$r_to_py(as.list(y.dims))\n  \n  npa &lt;- np$random$random_sample(a.dims)\n  npb &lt;- np$random$random_sample(b.dims)\n  a &lt;- array(runif(100), x.dims)\n  b &lt;- array(runif(100), y.dims)\n  \n  res &lt;- bench::mark(\n    broadcast = bc.num(a, b, \"+\"),\n    `numpy (NO conversion to R)` = npa + npb,\n    check = FALSE,\n    min_iterations = 100\n  )\n  bc_all &lt;- get_times(res, \"broadcast\")\n  np_all &lt;- get_times(res, \"numpy (NO conversion to R)\")\n  median_bc[counter] &lt;- median(bc_all)\n  median_np[counter] &lt;- median(np_all)\n  q1_bc[counter] &lt;- quantile(bc_all, 0.25)\n  q3_bc[counter] &lt;- quantile(bc_all, 0.75)\n  q1_np[counter] &lt;- quantile(np_all, 0.25)\n  q3_np[counter] &lt;- quantile(np_all, 0.75)\n  \n  counter &lt;- counter + 1L\n}\n\nUsing {tinyplot}, the median, first quartile, and third quartile of the bench-marked computation times are presented in the following graph:\n\n\n\n\n\n \n\n\nLarge non-orthogonal arrays comparisons\nHow about arrays that are not fully orthogonal, but still require a lot of broadcasting in pair-wise computations?\nHere is the benchmark:\n\n\nlibrary(broadcast)\nlibrary(tinycodet)\nimport_as(~rt, \"reticulate\")\nnp &lt;- rt$import(\"numpy\", convert = FALSE)\ngc &lt;- rt$import(\"gc\", convert = FALSE)\ngc$disable()\n\nn &lt;- 26L\nnpa &lt;- np$random$rand(n, 1L, n, 1L, n)\nnpb &lt;- np$random$rand(n, n, 1L, n, 1L)\n\na.dim &lt;- c(n, rep(c(1L, n), 2))\nb.dim &lt;- c(n, rep(c(n, 1L), 2))\na &lt;- array(rnorm(100), a.dim)\nb &lt;- array(rnorm(100), b.dim)\n\nbm_numpy_large &lt;- bench::mark(\n  broadcast = bc.num(a, b, \"+\"),\n  `numpy (no conversion to R)` = npa + npb,\n  check = FALSE,\n  min_iterations = 200,\n)\nsummary(bm_numpy_large)\nggplot2::autoplot(bm_numpy_large)\n\n\n#&gt; # A tibble: 2 × 6\n#&gt;   expression                      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 broadcast                    16.6ms   17.6ms      55.4    90.6MB     27.3\n#&gt; 2 numpy (no conversion to R)   25.4ms   30.9ms      32.4        0B      0"
  },
  {
    "objectID": "vignettes/d_functions.html",
    "href": "vignettes/d_functions.html",
    "title": "Functions Design Explained",
    "section": "",
    "text": "Introduction\nThe ‘broadcast’ package provides 4 main functionalities:\n\nouter-like functions to perform broadcasted outer-computations\nbroadcasted dimensional binding of arrays (and also matrices and data.tables)\nbroadcasted generic pair-wise functions\narray typecasting with dimensions and names preserved\n\nThis guide will explain the design choices of the functions provided by the ‘broadcast’ ‘R’-package.\n \n\n\nOuter-like functions\nThe ‘broadcast’ package provides functions that perform Broadcasted outer operations, similar to base R’s outer() function. The outer-like functions are the following:\n\nbc.b(): Broadcasted Boolean operations.\nbc.i() Broadcasted (53bit) Integer Numeric operations.\nbc.d(): Broadcasted (64bit) Decimal Numeric operations.\nbc.cplx(): Broadcasted Complex Numeric operations.\nbc.str(): Broadcasted String operations.\nbc.list(): Broadcasted operations on Recursive arrays.\n\nThere are several things to note about the above functions.\nFirst, the naming convention is “bc.” followed by some abbreviation of the operation type.\nFor example, “b” refers to “Boolean operations”, “i” to “Integer Numeric operations”, and “d” to “Decimal Numeric Operations”.\nSecond, the outer() function from base ‘R’ is only optimized for the “*” operator; all other operators are called “regularly”, somewhat (but not entirely) similar as functions would be called in an apply()-like function.\nThe outer-like functions provided by ‘broadcast’, however, come with a very large set of optimised operators, written and compiled in ‘C’ and ‘C++’.\nThird, where base ‘R’ provides a single outer() function, ‘broadcast’ provides several outer-like functions.\nThis is done for the following reasons:\n\nAs stated earlier, the outer-like functions provided by ‘broadcast’ come with a very large set of pre-compiled, optimised operations.\nFitting all of those operators into a single outer-like function would be inefficient, and would also make it easy for the user to lose track of all of the supported operators.\nSplitting the numeric-ish operations into Boolean, (53bit) Integer, and (64bit) Decimal numbers, allows for only performing typecasting when necessary; more importantly, typecasting here is performed at the ‘C’ level, without allocating an entirely new vector/array.\nThis allows for far more efficient code.\nFor example: bc.i(x, y \"+\") is significantly faster and more memory efficient than bc.d(trunc(x), trunc(y), \"+\"), as the latter results in producing unnecessary copies of both x and y.\n\nFinally, much like the outer() function from base ‘R’, the outer-like functions provided by ‘broadcast’, are pair-wise functions; i.e. they operate on 2 arrays at a time.\nThis is intentional, as it is quite difficult to reason about broadcasting when it involves more than a pair of arrays.\n \n\n\n\n\n\n\nNote\n\n\n\nbc.num() is an alias for bc.d().\n\n\n \nFor details on the operators supported in each of the outer-like functions, please refer to the relevant sections in the Reference Manual.\n \n\n\nBinding implementations\n‘broadcast’ provides 3 functions for dimensional binding:\n\nbind_mat(): binds vectors and matrices row-wise or column-wise; allows for vector (i.e. linear) recycling.\nbind_array(): binds arrays (including matrices) along any arbitrary dimension; allows dimensional broadcasting.\nbind_dt(): binds data.frames and data.tables; allows for matching unmatched columns.\n\nNote that the naming convention of the binding implementations here is “bind_” followed by the resulting class (abbreviated) - i.e. …\n\nbind_mat() returns a matrix, but can bind both matrices and vectors.\nbind_array() returns an array, but can bind both arrays and matrices.\nbind_dt() returns a data.table, but can bind not only data.tables, but also most other data.frame-like objects.\n\n\n\n\n\n\n\nNote\n\n\n\nThe bind_dt() function is only callable if the ‘data.table’ package is also installed."
  },
  {
    "objectID": "vignettes/b_installation.html",
    "href": "vignettes/b_installation.html",
    "title": "Installation",
    "section": "",
    "text": "To install ‘broadcast’ from GitHub, one may run the following code in ‘R’:\n\n\nremotes::install_github(\"https://github.com/tony-aw/broadcast\")\n\n‘broadcast’ is not a large package per-sé, but it does contain a large amount of compiled code (‘C’ and ‘C++’). Compilation of the package may be slow on some operating systems, especially Linux systems; please be patient. On my own personal laptop (Windows 11), installation takes about 2 minutes.\nIf installation is too slow, one may try to speed up the installation using multi-threading, for example like so:\n\n\nnthreads &lt;- 8L # specify number of threads\nSys.setenv(MAKEFLAGS = paste0(\"-j\", nthreads)) # may speed up installation\n\nremotes::install_github(\"https://github.com/tony-aw/broadcast\")\n\n \nTo attach the package - thus expose its functions to the namespace - please use the following:\n\n\nlibrary(broadcast)\n\n \nTo open the introduction help page of the ‘broadcast’ package, please use any of the following:\n\n\n?broadcast::broadcast\n?broadcast::broadcast_help\n?broadcast::`broadcast-package`"
  },
  {
    "objectID": "Readme.html#overview",
    "href": "Readme.html#overview",
    "title": "Introduction",
    "section": "🗺️Overview",
    "text": "🗺️Overview\nThe ‘broadcast’ ‘R’-package, as the name suggests, performs “broadcasting” (similar to broadcasting in the ‘Numpy’ module for ‘Python’).\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions repetition mechanism.\nPlease read the article “Broadcasting explained” for a more complete explanation of what “broadcasting” is.\n \nAt its core, the ‘broadcast’ package provides 3 functionalities, all 3 related to “broadcasting”:\n \nFirst, ‘broadcast’ provides functions for element-wise outer computations between any 2 arrays.\nThese are similar to base R’s outer() function, but using broadcasting, which is faster and more efficient than the mechanism employed by outer().\nThe outer-like functions provided by ‘broadcast’ are optimised for a large set of operations, including, but not limited to, the following:\n\nrelational operations (like ==, !=, &lt;, &gt;, &lt;=, &gt;=, etc.);\narithmetic operations (like +, -, *, /, ^, etc.);\nBoolean combiner operations (like &, |, xor, etc.);\nstring concatenation, string (in)equality, and string distance (Levenshtein) operations.\n\nBase ‘R’ outer() function has some sloppy rules regarding the dimensions of the output, making it hard to predict the output shape.\nThe outer-like functions provided by ‘broadcast’ have very strict broadcasting rules, making it easy to accurately predict the dimensions of the result.\n \nSecond, ‘broadcast’ provides the bind_array() function, which is an broadcasted and enhanced form of the fantastic abind::abind() function:\n\nbind_array() allows for broadcasting (obviously), whereas abind::abind() does not.\nbind_array() is significantly faster and uses less memory than abind::abind().\nbind_array() also differs from abind::abind() in that it can handle recursive arrays properly; abind::abind() unlists everything to atomic arrays, ruining the structure.\n\n \nThird, ‘broadcast’ provides several generic functions for broadcasting:\n\nbcapply(): a broadcasted apply-like function that works on pairs of arrays.\nbc_ifelse(): a broadcasted ifelse() function. Broadcasts between the yes and no arguments."
  },
  {
    "objectID": "Readme.html#why-use-broadcast",
    "href": "Readme.html#why-use-broadcast",
    "title": "Introduction",
    "section": "🤷🏽Why use ‘broadcast’",
    "text": "🤷🏽Why use ‘broadcast’\nEfficiency\nBroadcasting dimensions is faster and more memory efficient than repeating dimensions.\nThis is not simply a need for speed.\nEfficient programs use less energy and resources, and is thus better for the environment.\nAs a favoured language for the sciences, ‘R’ should not throw away an opportunity to become more efficient.\nThe Benchmarks show that ‘broadcast’ has a somewhat similar speed as equivalent operations in ‘Numpy’.\n \nConvenience\nBroadcasting can make many applications much easier to write.\nFor Example: Suppose you want to compute some metric on all possible pair-wise combinations of the elements of 2 vectors.\nYou could write slow and ugly nested for-loops…\nBut you can instead also make the vectors orthogonal, and perform the broadcasting computation on the 2 orthogonal vectors.\nThe broadcasted method runs much faster, is faster to type, and easier to reason about, than using the clumsy nested for-loops.\nFor more practical examples, see Examples of Practical Applictaions.\n \nMinimal Dependencies\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nNot using external libraries brings a number of advantages:\n\nAvoid dependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”). ‘broadcast’ thus avoids this.\nAvoid wasting resources for translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of R to that of the other language, and vice-versa, which wastes precious time and memory. ‘broadcast’ requires no such translations of structures, and thus does not waste precious time and memory.\nEnsure consistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour of some operations. For example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas ‘R’ supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’). Since ‘broadcast’ does not rely on external libraries, it can ensure consistent behaviour."
  },
  {
    "objectID": "Readme.html#documentation",
    "href": "Readme.html#documentation",
    "title": "Introduction",
    "section": "📖Documentation",
    "text": "📖Documentation\nThe documentation in the ‘broadcast’ website is divided into 3 main navigationable sections:\n\nGuides and Vignettes: Here you’ll find the topic-oriented guides in the form of a few Vignettes.\nReference Manual: Here you’ll find the function-oriented reference manual.\nAbout: Here you’ll find mainly the Changelog and License file."
  },
  {
    "objectID": "man/properties.html",
    "href": "man/properties.html",
    "title": "properties",
    "section": "",
    "text": "ndim() returns the number of dimensions of an object.  lst.ndim() returns the number of dimensions of every list-element.  lst.typeof() returns the (internal) type of every list-element.  len() is an alias for length.  lst.len() is an alias for lengths.   These functions were all designed to be efficient.  \n\n\n\nndim(x)\n\nlst.ndim(x)\n\nlst.typeof(x)\n\n\n\n\n\n\n\n\nx\n\n\nan object. For functions starting with lst., x must be a list (i.e. recursive vector or recursive array). \n\n\n\n\n\n\n\nAn integer scalar\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- list(\n  array(1:10, 10),\n  array(1:10, c(2, 5)),\n  array(c(letters, NA), c(3,3,3))\n)\nlst.ndim(x)\n## [1] 1 2 3\nlst.typeof(x)\n## [1] \"integer\"   \"integer\"   \"character\""
  },
  {
    "objectID": "man/properties.html#small-property-functions",
    "href": "man/properties.html#small-property-functions",
    "title": "properties",
    "section": "",
    "text": "ndim() returns the number of dimensions of an object.  lst.ndim() returns the number of dimensions of every list-element.  lst.typeof() returns the (internal) type of every list-element.  len() is an alias for length.  lst.len() is an alias for lengths.   These functions were all designed to be efficient.  \n\n\n\nndim(x)\n\nlst.ndim(x)\n\nlst.typeof(x)\n\n\n\n\n\n\n\n\nx\n\n\nan object. For functions starting with lst., x must be a list (i.e. recursive vector or recursive array). \n\n\n\n\n\n\n\nAn integer scalar\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- list(\n  array(1:10, 10),\n  array(1:10, c(2, 5)),\n  array(c(letters, NA), c(3,3,3))\n)\nlst.ndim(x)\n## [1] 1 2 3\nlst.typeof(x)\n## [1] \"integer\"   \"integer\"   \"character\""
  },
  {
    "objectID": "man/bc_ifelse.html",
    "href": "man/bc_ifelse.html",
    "title": "bc_ifelse",
    "section": "",
    "text": "The bc_ifelse() function performs a broadcasted form of ifelse. \n\n\n\nbc_ifelse(cond, yes, no)\n\n\n\n\n\n\n\n\ncond\n\n\nlogical vector or array with the length equal to prod(bc_dim(yes, no)).\n\n\n\n\nyes, no\n\n\nconformable arrays of the same type.  All atomic types (see atomic) are supported.  Recursive arrays of type list are also supported.  \n\n\n\n\n\n\n\nThe ouput, here referred to as out, will be an array of the same type as yes and no.  After broadcasting yes against no, given any element index i, the following will hold for the output:\n\n\nwhen cond[i] == TRUE, out[i] is yes[i];\n\n\nwhen cond[i] == FALSE, out[i] is no[i];\n\n\nwhen cond[i] is NA, out[i] is NA when yes and no are atomic, and out[i] is list(NULL) when yes and no are recursive.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\ncond &lt;- bc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))\n) |&gt; as_bool()\n\nbc_ifelse(cond, yes = x, no = y)\n## , , 1\n## \n##       [,1]         [,2]        \n##  [1,] character,26 character,26\n##  [2,] integer,10   integer,10  \n##  [3,] character,26 character,26\n##  [4,] integer,10   integer,10  \n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] integer,10   integer,10  \n##  [9,] character,26 character,26\n## [10,] character,12 character,12\n## \n## , , 2\n## \n##       [,1]         [,2]        \n##  [1,] character,26 character,26\n##  [2,] integer,10   integer,10  \n##  [3,] character,26 character,26\n##  [4,] integer,10   integer,10  \n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] integer,10   integer,10  \n##  [9,] character,26 character,26\n## [10,] character,12 character,12"
  },
  {
    "objectID": "man/bc_ifelse.html#broadcasted-ifelse",
    "href": "man/bc_ifelse.html#broadcasted-ifelse",
    "title": "bc_ifelse",
    "section": "",
    "text": "The bc_ifelse() function performs a broadcasted form of ifelse. \n\n\n\nbc_ifelse(cond, yes, no)\n\n\n\n\n\n\n\n\ncond\n\n\nlogical vector or array with the length equal to prod(bc_dim(yes, no)).\n\n\n\n\nyes, no\n\n\nconformable arrays of the same type.  All atomic types (see atomic) are supported.  Recursive arrays of type list are also supported.  \n\n\n\n\n\n\n\nThe ouput, here referred to as out, will be an array of the same type as yes and no.  After broadcasting yes against no, given any element index i, the following will hold for the output:\n\n\nwhen cond[i] == TRUE, out[i] is yes[i];\n\n\nwhen cond[i] == FALSE, out[i] is no[i];\n\n\nwhen cond[i] is NA, out[i] is NA when yes and no are atomic, and out[i] is list(NULL) when yes and no are recursive.  \n\n\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\ncond &lt;- bc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y) && typeof(x) == typeof(y))\n) |&gt; as_bool()\n\nbc_ifelse(cond, yes = x, no = y)\n## , , 1\n## \n##       [,1]         [,2]        \n##  [1,] character,26 character,26\n##  [2,] integer,10   integer,10  \n##  [3,] character,26 character,26\n##  [4,] integer,10   integer,10  \n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] integer,10   integer,10  \n##  [9,] character,26 character,26\n## [10,] character,12 character,12\n## \n## , , 2\n## \n##       [,1]         [,2]        \n##  [1,] character,26 character,26\n##  [2,] integer,10   integer,10  \n##  [3,] character,26 character,26\n##  [4,] integer,10   integer,10  \n##  [5,] character,12 character,12\n##  [6,] character,12 character,12\n##  [7,] integer,10   integer,10  \n##  [8,] integer,10   integer,10  \n##  [9,] character,26 character,26\n## [10,] character,12 character,12"
  },
  {
    "objectID": "man/bcapply.html",
    "href": "man/bcapply.html",
    "title": "bcapply",
    "section": "",
    "text": "The bcapply() function applies a function to 2 arrays with broadcasting. \n\n\n\nbcapply(x, y, f, v = \"list\")\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic or recursive arrays.\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a recursive or atomic array.\n\n\n\n\nv\n\n\na single string, giving the scalar type for a single iteration.  If NULL or “list” (default), the result will be a recursive array.  If it is certain that, for every iteration, f() always results in a single atomic scalar, the user can specify the type in v to pre-allocate the result.  Pre-allocating the results leads to slightly faster and more memory efficient code.  NOTE: Incorrectly specifying v leads to undefined behaviour. \n\n\n\n\n\n\n\nAn atomic or recursive array with dimensions bc_dim(x, y). \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nf &lt;- function(x, y) list(x, y)\nbcapply(x, y, f)\n## , , 1\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n## \n## , , 2\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2"
  },
  {
    "objectID": "man/bcapply.html#apply-a-function-to-2-broadcasted-arrays",
    "href": "man/bcapply.html#apply-a-function-to-2-broadcasted-arrays",
    "title": "bcapply",
    "section": "",
    "text": "The bcapply() function applies a function to 2 arrays with broadcasting. \n\n\n\nbcapply(x, y, f, v = \"list\")\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic or recursive arrays.\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a recursive or atomic array.\n\n\n\n\nv\n\n\na single string, giving the scalar type for a single iteration.  If NULL or “list” (default), the result will be a recursive array.  If it is certain that, for every iteration, f() always results in a single atomic scalar, the user can specify the type in v to pre-allocate the result.  Pre-allocating the results leads to slightly faster and more memory efficient code.  NOTE: Incorrectly specifying v leads to undefined behaviour. \n\n\n\n\n\n\n\nAn atomic or recursive array with dimensions bc_dim(x, y). \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nf &lt;- function(x, y) list(x, y)\nbcapply(x, y, f)\n## , , 1\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2\n## \n## , , 2\n## \n##       [,1]   [,2]  \n##  [1,] list,2 list,2\n##  [2,] list,2 list,2\n##  [3,] list,2 list,2\n##  [4,] list,2 list,2\n##  [5,] list,2 list,2\n##  [6,] list,2 list,2\n##  [7,] list,2 list,2\n##  [8,] list,2 list,2\n##  [9,] list,2 list,2\n## [10,] list,2 list,2"
  },
  {
    "objectID": "man/bc.list.html",
    "href": "man/bc.list.html",
    "title": "bc.list",
    "section": "",
    "text": "The bc.list() function performs broadcasted operations on 2 Recursive arrays. \n\n\n\nbc.list(x, y, f)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable Recursive arrays (i.e. arrays of type list).\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a list. \n\n\n\n\n\n\n\nA recursive array. \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nbc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y), typeof(x) == typeof(y))\n)\n## , , 1\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2\n## \n## , , 2\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2"
  },
  {
    "objectID": "man/bc.list.html#broadcasted-operations-for-recursive-arrays",
    "href": "man/bc.list.html#broadcasted-operations-for-recursive-arrays",
    "title": "bc.list",
    "section": "",
    "text": "The bc.list() function performs broadcasted operations on 2 Recursive arrays. \n\n\n\nbc.list(x, y, f)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable Recursive arrays (i.e. arrays of type list).\n\n\n\n\nf\n\n\na function that takes in exactly 2 arguments, and returns a result that can be stored in a single element of a list. \n\n\n\n\n\n\n\nA recursive array. \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(c(10, 2,2))\nx.len &lt;- prod(x.dim)\n\ngen &lt;- function(n) sample(list(letters, month.abb, 1:10), n, TRUE)\n\nx &lt;- array(gen(10), x.dim)\ny &lt;- array(gen(10), c(10,1,1))\n\nbc.list(\n  x, y,\n  \\(x, y)c(length(x) == length(y), typeof(x) == typeof(y))\n)\n## , , 1\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2\n## \n## , , 2\n## \n##       [,1]      [,2]     \n##  [1,] logical,2 logical,2\n##  [2,] logical,2 logical,2\n##  [3,] logical,2 logical,2\n##  [4,] logical,2 logical,2\n##  [5,] logical,2 logical,2\n##  [6,] logical,2 logical,2\n##  [7,] logical,2 logical,2\n##  [8,] logical,2 logical,2\n##  [9,] logical,2 logical,2\n## [10,] logical,2 logical,2"
  },
  {
    "objectID": "man/bc.d.html",
    "href": "man/bc.d.html",
    "title": "bc.d",
    "section": "",
    "text": "The bc.d() function performs broadcasted decimal numeric operations on 2 numeric or logical arrays.  bc.num() is an alias for bc.d().  \n\n\n\nbc.d(x, y, op, prec = sqrt(.Machine\\$double.eps))\n\nbc.num(x, y, op, prec = sqrt(.Machine\\$double.eps))\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=, d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=. \n\n\n\n\nprec\n\n\na single number between 0 and 0.1, giving the machine precision to use.  Only relevant for the following operators:  d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=  See the d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;= operators from the ‘tinycodet’ package for details. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array as a result of the broadcasted decimal arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted decimal relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.d(x, y, \"+\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 769.1  50.1 996.1\n## [2,] 684.1 509.1 780.1\n## [3,] 164.1  99.1 755.1\n## [4,] 409.1 182.1 752.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 956.1  55.1 582.1\n## [2,] 830.1 645.1  23.1\n## [3,] 810.1 621.1 833.1\n## [4,] 304.1 311.1 131.1\nbc.d(x, y, \"-\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 767.1  48.1 994.1\n## [2,] 680.1 505.1 776.1\n## [3,] 158.1  93.1 749.1\n## [4,] 401.1 174.1 744.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 954.1  53.1 580.1\n## [2,] 826.1 641.1  19.1\n## [3,] 804.1 615.1 827.1\n## [4,] 296.1 303.1 123.1\nbc.d(x, y, \"*\")\n## , , 1\n## \n##        [,1]   [,2]   [,3]\n## [1,]  768.1   49.1  995.1\n## [2,] 1364.2 1014.2 1556.2\n## [3,]  483.3  288.3 2256.3\n## [4,] 1620.4  712.4 2992.4\n## \n## , , 2\n## \n##        [,1]   [,2]   [,3]\n## [1,]  955.1   54.1  581.1\n## [2,] 1656.2 1286.2   42.2\n## [3,] 2421.3 1854.3 2490.3\n## [4,] 1200.4 1228.4  508.4\nbc.d(x, y, \"/\")\n## , , 1\n## \n##         [,1]      [,2]    [,3]\n## [1,] 768.100  49.10000 995.100\n## [2,] 341.050 253.55000 389.050\n## [3,]  53.700  32.03333 250.700\n## [4,] 101.275  44.52500 187.025\n## \n## , , 2\n## \n##          [,1]     [,2]    [,3]\n## [1,] 955.1000  54.1000 581.100\n## [2,] 414.0500 321.5500  10.550\n## [3,] 269.0333 206.0333 276.700\n## [4,]  75.0250  76.7750  31.775\nbc.d(x, y, \"^\")\n## , , 1\n## \n##              [,1]         [,2]         [,3]\n## [1,] 7.681000e+02         49.1 9.951000e+02\n## [2,] 4.652604e+05     257150.4 6.054396e+05\n## [3,] 4.181062e+06     887503.7 4.254287e+08\n## [4,] 2.693078e+10 1006133658.6 3.132122e+11\n## \n## , , 2\n## \n##              [,1]         [,2]         [,3]\n## [1,]        955.1         54.1       581.10\n## [2,]     685749.6     413577.6       445.21\n## [3,]  525753341.9  236143627.7 571993694.90\n## [4,] 8110805401.2 8894453434.4 260964962.45\n\nbc.d(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.d.html#broadcasted-decimal-numeric-operations",
    "href": "man/bc.d.html#broadcasted-decimal-numeric-operations",
    "title": "bc.d",
    "section": "",
    "text": "The bc.d() function performs broadcasted decimal numeric operations on 2 numeric or logical arrays.  bc.num() is an alias for bc.d().  \n\n\n\nbc.d(x, y, op, prec = sqrt(.Machine\\$double.eps))\n\nbc.num(x, y, op, prec = sqrt(.Machine\\$double.eps))\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=, d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=. \n\n\n\n\nprec\n\n\na single number between 0 and 0.1, giving the machine precision to use.  Only relevant for the following operators:  d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;=  See the d==, d!=, d&lt;, d&gt;, d&lt;=, d&gt;= operators from the ‘tinycodet’ package for details. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array as a result of the broadcasted decimal arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted decimal relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.d(x, y, \"+\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 769.1  50.1 996.1\n## [2,] 684.1 509.1 780.1\n## [3,] 164.1  99.1 755.1\n## [4,] 409.1 182.1 752.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 956.1  55.1 582.1\n## [2,] 830.1 645.1  23.1\n## [3,] 810.1 621.1 833.1\n## [4,] 304.1 311.1 131.1\nbc.d(x, y, \"-\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] 767.1  48.1 994.1\n## [2,] 680.1 505.1 776.1\n## [3,] 158.1  93.1 749.1\n## [4,] 401.1 174.1 744.1\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] 954.1  53.1 580.1\n## [2,] 826.1 641.1  19.1\n## [3,] 804.1 615.1 827.1\n## [4,] 296.1 303.1 123.1\nbc.d(x, y, \"*\")\n## , , 1\n## \n##        [,1]   [,2]   [,3]\n## [1,]  768.1   49.1  995.1\n## [2,] 1364.2 1014.2 1556.2\n## [3,]  483.3  288.3 2256.3\n## [4,] 1620.4  712.4 2992.4\n## \n## , , 2\n## \n##        [,1]   [,2]   [,3]\n## [1,]  955.1   54.1  581.1\n## [2,] 1656.2 1286.2   42.2\n## [3,] 2421.3 1854.3 2490.3\n## [4,] 1200.4 1228.4  508.4\nbc.d(x, y, \"/\")\n## , , 1\n## \n##         [,1]      [,2]    [,3]\n## [1,] 768.100  49.10000 995.100\n## [2,] 341.050 253.55000 389.050\n## [3,]  53.700  32.03333 250.700\n## [4,] 101.275  44.52500 187.025\n## \n## , , 2\n## \n##          [,1]     [,2]    [,3]\n## [1,] 955.1000  54.1000 581.100\n## [2,] 414.0500 321.5500  10.550\n## [3,] 269.0333 206.0333 276.700\n## [4,]  75.0250  76.7750  31.775\nbc.d(x, y, \"^\")\n## , , 1\n## \n##              [,1]         [,2]         [,3]\n## [1,] 7.681000e+02         49.1 9.951000e+02\n## [2,] 4.652604e+05     257150.4 6.054396e+05\n## [3,] 4.181062e+06     887503.7 4.254287e+08\n## [4,] 2.693078e+10 1006133658.6 3.132122e+11\n## \n## , , 2\n## \n##              [,1]         [,2]         [,3]\n## [1,]        955.1         54.1       581.10\n## [2,]     685749.6     413577.6       445.21\n## [3,]  525753341.9  236143627.7 571993694.90\n## [4,] 8110805401.2 8894453434.4 260964962.45\n\nbc.d(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.d(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.d(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.b.html",
    "href": "man/bc.b.html",
    "title": "bc.b",
    "section": "",
    "text": "The bc.b() function performs broadcasted Boolean operations on 2 logical (or 32bit integer) arrays.   Please note that these operations will treat the input as Boolean.  Therefore, something like bc.b(1, 2, “==”) returns TRUE, because both 1 and 2 are TRUE when cast as Boolean.  \n\n\n\nbc.b(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical (or 32bit integer) arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported Boolean operators: &, |, xor, nand, ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nA logical array as a result of the broadcasted Boolean operation.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.b(x, y, \"&\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA  TRUE    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE    NA FALSE\n## [4,]  TRUE FALSE FALSE\n## \n## , , 2\n## \n##      [,1]  [,2]  [,3]\n## [1,] TRUE FALSE FALSE\n## [2,] TRUE  TRUE  TRUE\n## [3,]   NA FALSE FALSE\n## [4,]   NA  TRUE    NA\nbc.b(x, y, \"|\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.b(x, y, \"xor\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA FALSE    NA\n## [2,] FALSE  TRUE FALSE\n## [3,]  TRUE    NA  TRUE\n## [4,] FALSE  TRUE  TRUE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE  TRUE  TRUE\n## [2,] FALSE FALSE FALSE\n## [3,]    NA  TRUE  TRUE\n## [4,]    NA FALSE    NA\nbc.b(x, y, \"nand\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.b(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA  TRUE    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE    NA FALSE\n## [4,]  TRUE FALSE FALSE\n## \n## , , 2\n## \n##      [,1]  [,2]  [,3]\n## [1,] TRUE FALSE FALSE\n## [2,] TRUE  TRUE  TRUE\n## [3,]   NA FALSE FALSE\n## [4,]   NA  TRUE    NA\nbc.b(x, y, \"!=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA FALSE    NA\n## [2,] FALSE  TRUE FALSE\n## [3,]  TRUE    NA  TRUE\n## [4,] FALSE  TRUE  TRUE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE  TRUE  TRUE\n## [2,] FALSE FALSE FALSE\n## [3,]    NA  TRUE  TRUE\n## [4,]    NA FALSE    NA"
  },
  {
    "objectID": "man/bc.b.html#broadcasted-boolean-operations",
    "href": "man/bc.b.html#broadcasted-boolean-operations",
    "title": "bc.b",
    "section": "",
    "text": "The bc.b() function performs broadcasted Boolean operations on 2 logical (or 32bit integer) arrays.   Please note that these operations will treat the input as Boolean.  Therefore, something like bc.b(1, 2, “==”) returns TRUE, because both 1 and 2 are TRUE when cast as Boolean.  \n\n\n\nbc.b(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical (or 32bit integer) arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported Boolean operators: &, |, xor, nand, ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nA logical array as a result of the broadcasted Boolean operation.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.b(x, y, \"&\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA  TRUE    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE    NA FALSE\n## [4,]  TRUE FALSE FALSE\n## \n## , , 2\n## \n##      [,1]  [,2]  [,3]\n## [1,] TRUE FALSE FALSE\n## [2,] TRUE  TRUE  TRUE\n## [3,]   NA FALSE FALSE\n## [4,]   NA  TRUE    NA\nbc.b(x, y, \"|\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.b(x, y, \"xor\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA FALSE    NA\n## [2,] FALSE  TRUE FALSE\n## [3,]  TRUE    NA  TRUE\n## [4,] FALSE  TRUE  TRUE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE  TRUE  TRUE\n## [2,] FALSE FALSE FALSE\n## [3,]    NA  TRUE  TRUE\n## [4,]    NA FALSE    NA\nbc.b(x, y, \"nand\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.b(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA  TRUE    NA\n## [2,]  TRUE FALSE  TRUE\n## [3,] FALSE    NA FALSE\n## [4,]  TRUE FALSE FALSE\n## \n## , , 2\n## \n##      [,1]  [,2]  [,3]\n## [1,] TRUE FALSE FALSE\n## [2,] TRUE  TRUE  TRUE\n## [3,]   NA FALSE FALSE\n## [4,]   NA  TRUE    NA\nbc.b(x, y, \"!=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,]    NA FALSE    NA\n## [2,] FALSE  TRUE FALSE\n## [3,]  TRUE    NA  TRUE\n## [4,] FALSE  TRUE  TRUE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE  TRUE  TRUE\n## [2,] FALSE FALSE FALSE\n## [3,]    NA  TRUE  TRUE\n## [4,]    NA FALSE    NA"
  },
  {
    "objectID": "man/aaa01_broadcast_bind.html",
    "href": "man/aaa01_broadcast_bind.html",
    "title": "R-package: broadcast",
    "section": "",
    "text": "This help page gives additional details on the binding implementations in the ‘broadcast’ package.  \n\n\n\nIf argument input has length 0, or it contains exclusively objects where one or more dimensions are 0, an error is returned.   If input has length 1, these functions simply return input[[1L]].  \n\n\n\nThe API of bind_array() is inspired by the fantastic abind::abind function by Tony Plare & Richard Heiberger (2016).  But bind_array() differs considerably from abind::abind in the following ways:\n\n\nbind_array() differs from abind::abind in that it can handle recursive arrays properly  (the abind::abind function would unlist everything to atomic arrays, ruining the structure).\n\n\nbind_array() allows for broadcasting, while abind::abind does not support broadcasting.\n\n\nbind_array() is generally faster than abind::abind, as bind_array() relies heavily on ‘C’ and ‘C++’ code.\n\n\nunlike abind::abind, bind_array() only binds (atomic/recursive) arrays and matrices.  bind_array()does not attempt to convert things to arrays when they are not arrays, but will give an error instead.  This saves computation time and prevents unexpected results.\n\n\nbind_array() has more streamlined naming options, compared to abind::abind.  \n\n\nbind_mat() is a modified version of rbind/cbind.  bind_mat() differs from rbind/cbind in the following ways:\n\n\nit has more streamlined naming options/\n\n\nbind_mat() gives an error when fractional recycling is attempted (like binding 1:3 with 1:10).\n\n\nbind The primary differences is that   \n\n\n\n\n\n…"
  },
  {
    "objectID": "man/aaa01_broadcast_bind.html#details-on-the-binding-implementations-in-broadcast",
    "href": "man/aaa01_broadcast_bind.html#details-on-the-binding-implementations-in-broadcast",
    "title": "R-package: broadcast",
    "section": "",
    "text": "This help page gives additional details on the binding implementations in the ‘broadcast’ package.  \n\n\n\nIf argument input has length 0, or it contains exclusively objects where one or more dimensions are 0, an error is returned.   If input has length 1, these functions simply return input[[1L]].  \n\n\n\nThe API of bind_array() is inspired by the fantastic abind::abind function by Tony Plare & Richard Heiberger (2016).  But bind_array() differs considerably from abind::abind in the following ways:\n\n\nbind_array() differs from abind::abind in that it can handle recursive arrays properly  (the abind::abind function would unlist everything to atomic arrays, ruining the structure).\n\n\nbind_array() allows for broadcasting, while abind::abind does not support broadcasting.\n\n\nbind_array() is generally faster than abind::abind, as bind_array() relies heavily on ‘C’ and ‘C++’ code.\n\n\nunlike abind::abind, bind_array() only binds (atomic/recursive) arrays and matrices.  bind_array()does not attempt to convert things to arrays when they are not arrays, but will give an error instead.  This saves computation time and prevents unexpected results.\n\n\nbind_array() has more streamlined naming options, compared to abind::abind.  \n\n\nbind_mat() is a modified version of rbind/cbind.  bind_mat() differs from rbind/cbind in the following ways:\n\n\nit has more streamlined naming options/\n\n\nbind_mat() gives an error when fractional recycling is attempted (like binding 1:3 with 1:10).\n\n\nbind The primary differences is that   \n\n\n\n\n\n…"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "🗺️Overview",
    "text": "🗺️Overview\nThe ‘broadcast’ ‘R’-package, as the name suggests, performs “broadcasting” (similar to broadcasting in the ‘Numpy’ module for ‘Python’).\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions repetition mechanism.\nPlease read the article “Broadcasting explained” for a more complete explanation of what “broadcasting” is.\n \nAt its core, the ‘broadcast’ package provides 3 functionalities, all 3 related to “broadcasting”:\n \nFirst, ‘broadcast’ provides functions for element-wise outer computations between any 2 arrays.\nThese are similar to base R’s outer() function, but using broadcasting, which is faster and more efficient than the mechanism employed by outer().\nThe outer-like functions provided by ‘broadcast’ are optimised for a large set of operations, including, but not limited to, the following:\n\nrelational operations (like ==, !=, &lt;, &gt;, &lt;=, &gt;=, etc.);\narithmetic operations (like +, -, *, /, ^, etc.);\nBoolean combiner operations (like &, |, xor, etc.);\nstring concatenation, string (in)equality, and string distance (Levenshtein) operations.\n\nBase ‘R’ outer() function has some sloppy rules regarding the dimensions of the output, making it hard to predict the output shape.\nThe outer-like functions provided by ‘broadcast’ have very strict broadcasting rules, making it easy to accurately predict the dimensions of the result.\n \nSecond, ‘broadcast’ provides the bind_array() function, which is an broadcasted and enhanced form of the fantastic abind::abind() function:\n\nbind_array() allows for broadcasting (obviously), whereas abind::abind() does not.\nbind_array() is significantly faster and uses less memory than abind::abind().\nbind_array() also differs from abind::abind() in that it can handle recursive arrays properly; abind::abind() unlists everything to atomic arrays, ruining the structure.\n\n \nThird, ‘broadcast’ provides several generic functions for broadcasting:\n\nbcapply(): a broadcasted apply-like function that works on pairs of arrays.\nbc_ifelse(): a broadcasted ifelse() function. Broadcasts between the yes and no arguments."
  },
  {
    "objectID": "index.html#why-use-broadcast",
    "href": "index.html#why-use-broadcast",
    "title": "Introduction",
    "section": "🤷🏽Why use ‘broadcast’",
    "text": "🤷🏽Why use ‘broadcast’\nEfficiency\nBroadcasting dimensions is faster and more memory efficient than repeating dimensions.\nThis is not simply a need for speed.\nEfficient programs use less energy and resources, and is thus better for the environment.\nAs a favoured language for the sciences, ‘R’ should not throw away an opportunity to become more efficient.\nThe Benchmarks show that ‘broadcast’ has a somewhat similar speed as equivalent operations in ‘Numpy’.\n \nConvenience\nBroadcasting can make many applications much easier to write.\nFor Example: Suppose you want to compute some metric on all possible pair-wise combinations of the elements of 2 vectors.\nYou could write slow and ugly nested for-loops…\nBut you can instead also make the vectors orthogonal, and perform the broadcasting computation on the 2 orthogonal vectors.\nThe broadcasted method runs much faster, is faster to type, and easier to reason about, than using the clumsy nested for-loops.\nFor more practical examples, see Examples of Practical Applictaions.\n \nMinimal Dependencies\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nNot using external libraries brings a number of advantages:\n\nAvoid dependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”). ‘broadcast’ thus avoids this.\nAvoid wasting resources for translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of R to that of the other language, and vice-versa, which wastes precious time and memory. ‘broadcast’ requires no such translations of structures, and thus does not waste precious time and memory.\nEnsure consistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour of some operations. For example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas ‘R’ supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’). Since ‘broadcast’ does not rely on external libraries, it can ensure consistent behaviour."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "Introduction",
    "section": "📖Documentation",
    "text": "📖Documentation\nThe documentation in the ‘broadcast’ website is divided into 3 main navigationable sections:\n\nGuides and Vignettes: Here you’ll find the topic-oriented guides in the form of a few Vignettes.\nReference Manual: Here you’ll find the function-oriented reference manual.\nAbout: Here you’ll find mainly the Changelog and License file."
  },
  {
    "objectID": "about/LICENSE.html",
    "href": "about/LICENSE.html",
    "title": "License",
    "section": "",
    "text": "1.1. “Contributor” means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software.\n1.2. “Contributor Version” means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor’s Contribution.\n1.3. “Contribution” means Covered Software of a particular Contributor.\n1.4. “Covered Software” means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof.\n1.5. “Incompatible With Secondary Licenses” means\n(a) that the initial Contributor has attached the notice described\n    in Exhibit B to the Covered Software; or\n\n(b) that the Covered Software was made available under the terms of\n    version 1.1 or earlier of the License, but not also under the\n    terms of a Secondary License.\n1.6. “Executable Form” means any form of the work other than Source Code Form.\n1.7. “Larger Work” means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software.\n1.8. “License” means this document.\n1.9. “Licensable” means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License.\n1.10. “Modifications” means any of the following:\n(a) any file in Source Code Form that results from an addition to,\n    deletion from, or modification of the contents of Covered\n    Software; or\n\n(b) any new file in Source Code Form that contains any Covered\n    Software.\n1.11. “Patent Claims” of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version.\n1.12. “Secondary License” means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses.\n1.13. “Source Code Form” means the form of the work preferred for making modifications.\n1.14. “You” (or “Your”) means an individual or a legal entity exercising rights under this License. For legal entities, “You” includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, “control” means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.\n\n\n\n2.1. Grants\nEach Contributor hereby grants You a world-wide, royalty-free, non-exclusive license:\n\nunder intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and\nunder Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.\n\n2.2. Effective Date\nThe licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.\n2.3. Limitations on Grant Scope\nThe licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor:\n\nfor any code that a Contributor has removed from Covered Software; or\nfor infringements caused by: (i) Your and any other third party’s modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or\nunder Patent Claims infringed by Covered Software in the absence of its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).\n2.4. Subsequent Licenses\nNo Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).\n2.5. Representation\nEach Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.\n2.6. Fair Use\nThis License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.\n2.7. Conditions\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.\n\n\n\n3.1. Distribution of Source Form\nAll distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients’ rights in the Source Code Form.\n3.2. Distribution of Executable Form\nIf You distribute Covered Software in Executable Form then:\n\nsuch Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and\nYou may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients’ rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\nYou may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).\n3.4. Notices\nYou may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.\n3.5. Application of Additional Terms\nYou may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.\n\n\n\nIf it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.\n\n\n\n5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice.\n5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate.\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.\n\n\n                                                                 *\n\nDisclaimer of Warranty *\n\n————————- *\n                                                                 *\nCovered Software is provided under this License on an “as is” *\nbasis, without warranty of any kind, either expressed, implied, or *\nstatutory, including, without limitation, warranties that the *\nCovered Software is free of defects, merchantable, fit for a *\nparticular purpose or non-infringing. The entire risk as to the *\nquality and performance of the Covered Software is with You. *\nShould any Covered Software prove defective in any respect, You *\n(not any Contributor) assume the cost of any necessary servicing, *\nrepair, or correction. This disclaimer of warranty constitutes an *\nessential part of this License. No use of any Covered Software is *\nauthorized under this License except under this disclaimer. *\n                                                                 *\n\n\n\n\n                                                                 *\n\nLimitation of Liability *\n\n————————– *\n                                                                 *\nUnder no circumstances and under no legal theory, whether tort *\n(including negligence), contract, or otherwise, shall any *\nContributor, or anyone who distributes Covered Software as *\npermitted above, be liable to You for any direct, indirect, *\nspecial, incidental, or consequential damages of any character *\nincluding, without limitation, damages for lost profits, loss of *\ngoodwill, work stoppage, computer failure or malfunction, or any *\nand all other commercial damages or losses, even if such party *\nshall have been informed of the possibility of such damages. This *\nlimitation of liability shall not apply to liability for death or *\npersonal injury resulting from such party’s negligence to the *\nextent applicable law prohibits such limitation. Some *\njurisdictions do not allow the exclusion or limitation of *\nincidental or consequential damages, so this exclusion and *\nlimitation may not apply to You. *\n                                                                 *\n\n\n\n\n\nAny litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party’s ability to bring cross-claims or counter-claims.\n\n\n\nThis License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.\n\n\n\n10.1. New Versions\nMozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.\n10.2. Effect of New Versions\nYou may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.\n10.3. Modified Versions\nIf you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).\n10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses\nIf You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.\n\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\nIf it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.\nYou may add additional accurate notices of copyright ownership.\n\n\n\nThis Source Code Form is “Incompatible With Secondary Licenses”, as defined by the Mozilla Public License, v. 2.0."
  },
  {
    "objectID": "about/LICENSE.html#definitions",
    "href": "about/LICENSE.html#definitions",
    "title": "License",
    "section": "",
    "text": "1.1. “Contributor” means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software.\n1.2. “Contributor Version” means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor’s Contribution.\n1.3. “Contribution” means Covered Software of a particular Contributor.\n1.4. “Covered Software” means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof.\n1.5. “Incompatible With Secondary Licenses” means\n(a) that the initial Contributor has attached the notice described\n    in Exhibit B to the Covered Software; or\n\n(b) that the Covered Software was made available under the terms of\n    version 1.1 or earlier of the License, but not also under the\n    terms of a Secondary License.\n1.6. “Executable Form” means any form of the work other than Source Code Form.\n1.7. “Larger Work” means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software.\n1.8. “License” means this document.\n1.9. “Licensable” means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License.\n1.10. “Modifications” means any of the following:\n(a) any file in Source Code Form that results from an addition to,\n    deletion from, or modification of the contents of Covered\n    Software; or\n\n(b) any new file in Source Code Form that contains any Covered\n    Software.\n1.11. “Patent Claims” of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version.\n1.12. “Secondary License” means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses.\n1.13. “Source Code Form” means the form of the work preferred for making modifications.\n1.14. “You” (or “Your”) means an individual or a legal entity exercising rights under this License. For legal entities, “You” includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, “control” means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity."
  },
  {
    "objectID": "about/LICENSE.html#license-grants-and-conditions",
    "href": "about/LICENSE.html#license-grants-and-conditions",
    "title": "License",
    "section": "",
    "text": "2.1. Grants\nEach Contributor hereby grants You a world-wide, royalty-free, non-exclusive license:\n\nunder intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and\nunder Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.\n\n2.2. Effective Date\nThe licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.\n2.3. Limitations on Grant Scope\nThe licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor:\n\nfor any code that a Contributor has removed from Covered Software; or\nfor infringements caused by: (i) Your and any other third party’s modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or\nunder Patent Claims infringed by Covered Software in the absence of its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).\n2.4. Subsequent Licenses\nNo Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).\n2.5. Representation\nEach Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.\n2.6. Fair Use\nThis License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.\n2.7. Conditions\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1."
  },
  {
    "objectID": "about/LICENSE.html#responsibilities",
    "href": "about/LICENSE.html#responsibilities",
    "title": "License",
    "section": "",
    "text": "3.1. Distribution of Source Form\nAll distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients’ rights in the Source Code Form.\n3.2. Distribution of Executable Form\nIf You distribute Covered Software in Executable Form then:\n\nsuch Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and\nYou may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients’ rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\nYou may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).\n3.4. Notices\nYou may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.\n3.5. Application of Additional Terms\nYou may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction."
  },
  {
    "objectID": "about/LICENSE.html#inability-to-comply-due-to-statute-or-regulation",
    "href": "about/LICENSE.html#inability-to-comply-due-to-statute-or-regulation",
    "title": "License",
    "section": "",
    "text": "If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it."
  },
  {
    "objectID": "about/LICENSE.html#termination",
    "href": "about/LICENSE.html#termination",
    "title": "License",
    "section": "",
    "text": "5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice.\n5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate.\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.\n\n\n                                                                 *\n\nDisclaimer of Warranty *\n\n————————- *\n                                                                 *\nCovered Software is provided under this License on an “as is” *\nbasis, without warranty of any kind, either expressed, implied, or *\nstatutory, including, without limitation, warranties that the *\nCovered Software is free of defects, merchantable, fit for a *\nparticular purpose or non-infringing. The entire risk as to the *\nquality and performance of the Covered Software is with You. *\nShould any Covered Software prove defective in any respect, You *\n(not any Contributor) assume the cost of any necessary servicing, *\nrepair, or correction. This disclaimer of warranty constitutes an *\nessential part of this License. No use of any Covered Software is *\nauthorized under this License except under this disclaimer. *\n                                                                 *\n\n\n\n\n                                                                 *\n\nLimitation of Liability *\n\n————————– *\n                                                                 *\nUnder no circumstances and under no legal theory, whether tort *\n(including negligence), contract, or otherwise, shall any *\nContributor, or anyone who distributes Covered Software as *\npermitted above, be liable to You for any direct, indirect, *\nspecial, incidental, or consequential damages of any character *\nincluding, without limitation, damages for lost profits, loss of *\ngoodwill, work stoppage, computer failure or malfunction, or any *\nand all other commercial damages or losses, even if such party *\nshall have been informed of the possibility of such damages. This *\nlimitation of liability shall not apply to liability for death or *\npersonal injury resulting from such party’s negligence to the *\nextent applicable law prohibits such limitation. Some *\njurisdictions do not allow the exclusion or limitation of *\nincidental or consequential damages, so this exclusion and *\nlimitation may not apply to You. *\n                                                                 *"
  },
  {
    "objectID": "about/LICENSE.html#litigation",
    "href": "about/LICENSE.html#litigation",
    "title": "License",
    "section": "",
    "text": "Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party’s ability to bring cross-claims or counter-claims."
  },
  {
    "objectID": "about/LICENSE.html#miscellaneous",
    "href": "about/LICENSE.html#miscellaneous",
    "title": "License",
    "section": "",
    "text": "This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor."
  },
  {
    "objectID": "about/LICENSE.html#versions-of-the-license",
    "href": "about/LICENSE.html#versions-of-the-license",
    "title": "License",
    "section": "",
    "text": "10.1. New Versions\nMozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.\n10.2. Effect of New Versions\nYou may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.\n10.3. Modified Versions\nIf you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).\n10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses\nIf You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached."
  },
  {
    "objectID": "about/LICENSE.html#exhibit-a---source-code-form-license-notice",
    "href": "about/LICENSE.html#exhibit-a---source-code-form-license-notice",
    "title": "License",
    "section": "",
    "text": "This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\nIf it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.\nYou may add additional accurate notices of copyright ownership."
  },
  {
    "objectID": "about/LICENSE.html#exhibit-b---incompatible-with-secondary-licenses-notice",
    "href": "about/LICENSE.html#exhibit-b---incompatible-with-secondary-licenses-notice",
    "title": "License",
    "section": "",
    "text": "This Source Code Form is “Incompatible With Secondary Licenses”, as defined by the Mozilla Public License, v. 2.0."
  },
  {
    "objectID": "about/NEWS.html",
    "href": "about/NEWS.html",
    "title": "Changelog",
    "section": "",
    "text": "…still testing…"
  },
  {
    "objectID": "man/aaa00_broadcast_help.html",
    "href": "man/aaa00_broadcast_help.html",
    "title": "R-package: broadcast",
    "section": "",
    "text": "broadcast:  Simple Broadcasted Binding and Binary Operations for Atomic and Recursive Arrays with Minimal Dependencies.   Implements simple broadcasted operations for atomic and recursive arrays.\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nThe broadcasted implementations include, but are not limited to, the following:\n\n\nA more efficient and broadcasted version of abind(), for binding arrays along an arbitrary dimension;\n\n\nRelational operations (like ==, !=, &lt;, &gt;, &lt;=, &gt;=; can also take into account Machine precision);\n\n\nArithmetic operations (like +, -, *, /, \"gcd\", ^, pmin(), pmax());\n\n\nBoolean combiner operations (like &, |, xor(), \"nand\");\n\n\nString distance, (in)equality, and concatenation operations;\n\n\nA Broadcasted implementation of ifelse();\n\n\nA Broadcasted apply-like function; The broadcasted implementations strive to minimize computation time and memory usage (which is not just good for computer efficiency, but also for the environment).\n\n\n\n\n\nAn introduction and overview of the package can be found on the website.  \n\n\n\nOuter-like functions  ‘broadcast’ provides a set of functions for binary, element-wise, outer operations with broadcasting.  These functions use an API similar to the outer and sweep functions.   The following functions for type-specific binary operations are available:\n\n\nbc.b: Boolean operations;\n\n\nbc.i: integer (53bit) arithmetic and relational operations;\n\n\nbc.d: decimal (64bit) arithmetic and relational operations;\n\n\nbc.cplx: complex arithmetic and (in)equality operations;\n\n\nbc.str: string (in)equality, concatenation, and distance operations;\n\n\nbc.list: apply any ‘R’ function to 2 recursive arrays with broadcasting.  \n\n\nBinding Implementations  ‘broadcast’ provides 3 binding implementations:  bind_mat, bind_array, and bind_dt.  \nGeneral functions  ‘broadcast’ also comes with 2 general broadcasted functions:\n\n\nbc_ifelse: Broadcasted version of ifelse.\n\n\nbcapply: Broadcasted apply-like function.  \n\n\nOther functions  ‘broadcast’ also provides type-casting functions, which preserve names and dimensions - convenient for arrays.  \n\n\n\nAuthor, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)\n\n\n\nThe badges shown in the documentation of this R-package were made using the services of: https://shields.io/"
  },
  {
    "objectID": "man/aaa00_broadcast_help.html#broadcast-simple-broadcasted-operations-for-atomic-and-recursive-arrays-with-minimal-dependencies",
    "href": "man/aaa00_broadcast_help.html#broadcast-simple-broadcasted-operations-for-atomic-and-recursive-arrays-with-minimal-dependencies",
    "title": "R-package: broadcast",
    "section": "",
    "text": "broadcast:  Simple Broadcasted Binding and Binary Operations for Atomic and Recursive Arrays with Minimal Dependencies.   Implements simple broadcasted operations for atomic and recursive arrays.\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nThe broadcasted implementations include, but are not limited to, the following:\n\n\nA more efficient and broadcasted version of abind(), for binding arrays along an arbitrary dimension;\n\n\nRelational operations (like ==, !=, &lt;, &gt;, &lt;=, &gt;=; can also take into account Machine precision);\n\n\nArithmetic operations (like +, -, *, /, \"gcd\", ^, pmin(), pmax());\n\n\nBoolean combiner operations (like &, |, xor(), \"nand\");\n\n\nString distance, (in)equality, and concatenation operations;\n\n\nA Broadcasted implementation of ifelse();\n\n\nA Broadcasted apply-like function; The broadcasted implementations strive to minimize computation time and memory usage (which is not just good for computer efficiency, but also for the environment).\n\n\n\n\n\nAn introduction and overview of the package can be found on the website.  \n\n\n\nOuter-like functions  ‘broadcast’ provides a set of functions for binary, element-wise, outer operations with broadcasting.  These functions use an API similar to the outer and sweep functions.   The following functions for type-specific binary operations are available:\n\n\nbc.b: Boolean operations;\n\n\nbc.i: integer (53bit) arithmetic and relational operations;\n\n\nbc.d: decimal (64bit) arithmetic and relational operations;\n\n\nbc.cplx: complex arithmetic and (in)equality operations;\n\n\nbc.str: string (in)equality, concatenation, and distance operations;\n\n\nbc.list: apply any ‘R’ function to 2 recursive arrays with broadcasting.  \n\n\nBinding Implementations  ‘broadcast’ provides 3 binding implementations:  bind_mat, bind_array, and bind_dt.  \nGeneral functions  ‘broadcast’ also comes with 2 general broadcasted functions:\n\n\nbc_ifelse: Broadcasted version of ifelse.\n\n\nbcapply: Broadcasted apply-like function.  \n\n\nOther functions  ‘broadcast’ also provides type-casting functions, which preserve names and dimensions - convenient for arrays.  \n\n\n\nAuthor, Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)\n\n\n\nThe badges shown in the documentation of this R-package were made using the services of: https://shields.io/"
  },
  {
    "objectID": "man/array_replicate.html",
    "href": "man/array_replicate.html",
    "title": "array_replicate",
    "section": "",
    "text": "The array_replicate() function replicates array dimensions until the specified dimension sizes are reached, and returns the array.   The various broadcasting functions recycle array dimensions virtually, meaning little to no additional memory is needed.  The array_replicate() function, however, physically replicates the dimensions of an array (and thus actually occupies additional memory space).  \n\n\n\narray_replicate(x, tdim)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array or matrix.\n\n\n\n\ntdim\n\n\nan integer vector, giving the target dimension to reach.\n\n\n\n\n\n\n\nReturns the replicated array.\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- matrix(1:9, 3,3)\ncolnames(x) &lt;- LETTERS[1:3]\nrownames(x) &lt;- letters[1:3]\nnames(x) &lt;- month.abb[1:9]\nprint(x)\n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## attr(,\"names\")\n## [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\n\narray_replicate(x, c(3,3,2)) # replicate to larger size\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9"
  },
  {
    "objectID": "man/array_replicate.html#replicate-array-dimensions",
    "href": "man/array_replicate.html#replicate-array-dimensions",
    "title": "array_replicate",
    "section": "",
    "text": "The array_replicate() function replicates array dimensions until the specified dimension sizes are reached, and returns the array.   The various broadcasting functions recycle array dimensions virtually, meaning little to no additional memory is needed.  The array_replicate() function, however, physically replicates the dimensions of an array (and thus actually occupies additional memory space).  \n\n\n\narray_replicate(x, tdim)\n\n\n\n\n\n\n\n\nx\n\n\nan atomic or recursive array or matrix.\n\n\n\n\ntdim\n\n\nan integer vector, giving the target dimension to reach.\n\n\n\n\n\n\n\nReturns the replicated array.\n\n\n\n\nlibrary(\"broadcast\")\n\n\nx &lt;- matrix(1:9, 3,3)\ncolnames(x) &lt;- LETTERS[1:3]\nrownames(x) &lt;- letters[1:3]\nnames(x) &lt;- month.abb[1:9]\nprint(x)\n##   A B C\n## a 1 4 7\n## b 2 5 8\n## c 3 6 9\n## attr(,\"names\")\n## [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\n\narray_replicate(x, c(3,3,2)) # replicate to larger size\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9"
  },
  {
    "objectID": "man/bc.cplx.html",
    "href": "man/bc.cplx.html",
    "title": "bc.cplx",
    "section": "",
    "text": "The bc.cplx() function performs broadcasted complex numeric operations pairs of arrays.   Note that bc.cplx() uses more strict NA checks than base ‘R’:  If for an element of either x or y, either the real or imaginary part is NA or NaN, than the result of the operation for that element is necessarily NA. \n\n\n\nbc.cplx(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type complex.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /.  Supported relational operators: ==, !=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A complex array as a result of the broadcasted arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\ngen &lt;- function() sample(c(rnorm(10), NA, NA, NaN, NaN, Inf, Inf, -Inf, -Inf))\nx &lt;- array(gen() + gen() * -1i, x.dim)\ny &lt;- array(gen() + gen() * -1i, c(4,1,1))\n\nbc.cplx(x, y, \"==\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1]  [,2] [,3]\n## [1,]   NA    NA   NA\n## [2,]   NA    NA   NA\n## [3,]   NA FALSE   NA\n## [4,]   NA    NA   NA\nbc.cplx(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA TRUE   NA\n## [4,]   NA   NA   NA\n\nbc.cplx(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1]          [,2] [,3]\n## [1,]   NA            NA   NA\n## [2,]   NA            NA   NA\n## [3,]   NA NaN-1.762267i   NA\n## [4,]   NA            NA   NA\n\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"==\")\n##  [1] FALSE FALSE FALSE    NA FALSE    NA    NA    NA    NA    NA    NA FALSE\n## [13]    NA FALSE    NA    NA    NA    NA\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"!=\")\n##  [1] TRUE   NA   NA   NA   NA   NA TRUE   NA   NA   NA   NA   NA   NA   NA   NA\n## [16]   NA   NA   NA\n\nx &lt;- gen() + gen() * -1i\ny &lt;- gen() + gen() * -1i\nout &lt;- bc.cplx(array(x), array(y), \"*\")\ncbind(x, y, x*y, out)\n##                            x                        y                       \n##  [1,]  2.35442396-0.1535535i -0.977647722+0.79113154i -2.1803162+2.01278025i\n##  [2,]         NaN+      NaNi          NaN+       Infi        NaN+       NaNi\n##  [3,]  1.09662644+1.5401780i                       NA                     NA\n##  [4,]                     NA -0.066099880+0.43033170i                     NA\n##  [5,]  0.95258802-0.4465158i          NaN+       NaNi        NaN+       NaNi\n##  [6,] -0.79195890+0.2510570i         -Inf-0.12106482i        Inf-       Infi\n##  [7,]  0.31292980+0.2456423i                       NA        Inf-       Infi\n##  [8,]         NaN+      Infi -1.027394105-0.07477888i        Inf-       Infi\n##  [9,]         NaN-0.3895997i -1.673713644+1.31928002i        NaN+       NaNi\n## [10,]         NaN-      Infi                       NA        NaN+       NaNi\n## [11,] -0.02508067+0.5629814i  0.001107989+1.51100858i -0.8506976-0.03727333i\n## [12,]                     NA                       NA        NaN+       NaNi\n## [13,]        -Inf-0.4540157i          NaN+       NaNi        NaN+       NaNi\n## [14,]                     NA          NaN-0.90836439i        NaN+       NaNi\n## [15,]         Inf-0.7736406i          NaN-       Infi        NaN-       Infi\n## [16,]                     NA          NaN+       Infi        NaN+       NaNi\n## [17,]         NaN+      NaNi  1.185935864-0.86487620i        NaN+       NaNi\n## [18,]         NaN+      Infi         -Inf-0.46804586i        NaN-       Infi\n##                          out\n##  [1,] -2.1803162+2.01278025i\n##  [2,]                     NA\n##  [3,]                     NA\n##  [4,]                     NA\n##  [5,]                     NA\n##  [6,]        Inf-       Infi\n##  [7,]                     NA\n##  [8,]                     NA\n##  [9,]                     NA\n## [10,]                     NA\n## [11,] -0.8506976-0.03727333i\n## [12,]                     NA\n## [13,]                     NA\n## [14,]                     NA\n## [15,]                     NA\n## [16,]                     NA\n## [17,]                     NA\n## [18,]                     NA"
  },
  {
    "objectID": "man/bc.cplx.html#broadcasted-complex-numeric-operations",
    "href": "man/bc.cplx.html#broadcasted-complex-numeric-operations",
    "title": "bc.cplx",
    "section": "",
    "text": "The bc.cplx() function performs broadcasted complex numeric operations pairs of arrays.   Note that bc.cplx() uses more strict NA checks than base ‘R’:  If for an element of either x or y, either the real or imaginary part is NA or NaN, than the result of the operation for that element is necessarily NA. \n\n\n\nbc.cplx(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of type complex.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, /.  Supported relational operators: ==, !=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A complex array as a result of the broadcasted arithmetic operation.   For relational operators:  A logical array as a result of the broadcasted relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\ngen &lt;- function() sample(c(rnorm(10), NA, NA, NaN, NaN, Inf, Inf, -Inf, -Inf))\nx &lt;- array(gen() + gen() * -1i, x.dim)\ny &lt;- array(gen() + gen() * -1i, c(4,1,1))\n\nbc.cplx(x, y, \"==\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1]  [,2] [,3]\n## [1,]   NA    NA   NA\n## [2,]   NA    NA   NA\n## [3,]   NA FALSE   NA\n## [4,]   NA    NA   NA\nbc.cplx(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA TRUE   NA\n## [4,]   NA   NA   NA\n\nbc.cplx(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]   NA   NA   NA\n## [2,]   NA   NA   NA\n## [3,]   NA   NA   NA\n## [4,]   NA   NA   NA\n## \n## , , 2\n## \n##      [,1]          [,2] [,3]\n## [1,]   NA            NA   NA\n## [2,]   NA            NA   NA\n## [3,]   NA NaN-1.762267i   NA\n## [4,]   NA            NA   NA\n\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"==\")\n##  [1] FALSE FALSE FALSE    NA FALSE    NA    NA    NA    NA    NA    NA FALSE\n## [13]    NA FALSE    NA    NA    NA    NA\nbc.cplx(array(gen() + gen() * -1i), array(gen() + gen() * -1i), \"!=\")\n##  [1] TRUE   NA   NA   NA   NA   NA TRUE   NA   NA   NA   NA   NA   NA   NA   NA\n## [16]   NA   NA   NA\n\nx &lt;- gen() + gen() * -1i\ny &lt;- gen() + gen() * -1i\nout &lt;- bc.cplx(array(x), array(y), \"*\")\ncbind(x, y, x*y, out)\n##                            x                        y                       \n##  [1,]  2.35442396-0.1535535i -0.977647722+0.79113154i -2.1803162+2.01278025i\n##  [2,]         NaN+      NaNi          NaN+       Infi        NaN+       NaNi\n##  [3,]  1.09662644+1.5401780i                       NA                     NA\n##  [4,]                     NA -0.066099880+0.43033170i                     NA\n##  [5,]  0.95258802-0.4465158i          NaN+       NaNi        NaN+       NaNi\n##  [6,] -0.79195890+0.2510570i         -Inf-0.12106482i        Inf-       Infi\n##  [7,]  0.31292980+0.2456423i                       NA        Inf-       Infi\n##  [8,]         NaN+      Infi -1.027394105-0.07477888i        Inf-       Infi\n##  [9,]         NaN-0.3895997i -1.673713644+1.31928002i        NaN+       NaNi\n## [10,]         NaN-      Infi                       NA        NaN+       NaNi\n## [11,] -0.02508067+0.5629814i  0.001107989+1.51100858i -0.8506976-0.03727333i\n## [12,]                     NA                       NA        NaN+       NaNi\n## [13,]        -Inf-0.4540157i          NaN+       NaNi        NaN+       NaNi\n## [14,]                     NA          NaN-0.90836439i        NaN+       NaNi\n## [15,]         Inf-0.7736406i          NaN-       Infi        NaN-       Infi\n## [16,]                     NA          NaN+       Infi        NaN+       NaNi\n## [17,]         NaN+      NaNi  1.185935864-0.86487620i        NaN+       NaNi\n## [18,]         NaN+      Infi         -Inf-0.46804586i        NaN-       Infi\n##                          out\n##  [1,] -2.1803162+2.01278025i\n##  [2,]                     NA\n##  [3,]                     NA\n##  [4,]                     NA\n##  [5,]                     NA\n##  [6,]        Inf-       Infi\n##  [7,]                     NA\n##  [8,]                     NA\n##  [9,]                     NA\n## [10,]                     NA\n## [11,] -0.8506976-0.03727333i\n## [12,]                     NA\n## [13,]                     NA\n## [14,]                     NA\n## [15,]                     NA\n## [16,]                     NA\n## [17,]                     NA\n## [18,]                     NA"
  },
  {
    "objectID": "man/bc.i.html",
    "href": "man/bc.i.html",
    "title": "bc.i",
    "section": "",
    "text": "The bc.i() function performs broadcasted integer numeric operations on 2 numeric or logical arrays.   Please note that these operations will treat the input as 53bit integers, and will efficiently truncate when necessary.  Therefore, something like bc.i(1, 1.5, “==”) returns TRUE, because trunc(1.5) equals 1.  \n\n\n\nbc.i(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, gcd, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array of whole numbers, as a result of the broadcasted arithmetic operation.  Base ‘R’ supports 53 bit integers, which thus range from approximately -9 quadrillion to +9 quadrillion.  Values outside of this range will be returned as -Inf or Inf, as an extra protection against integer overflow.   For relational operators:  A logical array as a result of the broadcasted integer relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.i(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  881  427  806\n## [2,]  598   29  539\n## [3,]    8  449  665\n## [4,]  844  499  404\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  986  685  134\n## [2,]  934  364  401\n## [3,]  187  626  809\n## [4,]  686  137  432\nbc.i(x, y, \"-\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  879  425  804\n## [2,]  594   25  535\n## [3,]    2  443  659\n## [4,]  836  491  396\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  984  683  132\n## [2,]  930  360  397\n## [3,]  181  620  803\n## [4,]  678  129  424\nbc.i(x, y, \"*\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  880  426  805\n## [2,] 1192   54 1074\n## [3,]   15 1338 1986\n## [4,] 3360 1980 1600\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  985  684  133\n## [2,] 1864  724  798\n## [3,]  552 1869 2418\n## [4,] 2728  532 1712\nbc.i(x, y, \"gcd\") # greatest common divisor\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    1    1\n## [3,]    1    1    1\n## [4,]    4    1    4\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    2    1\n## [3,]    1    1    1\n## [4,]    2    1    4\nbc.i(x, y, \"^\")\n## , , 1\n## \n##              [,1]        [,2]        [,3]\n## [1,]          880         426         805\n## [2,]       355216         729      288369\n## [3,]          125    88716536   290117528\n## [4,] 497871360000 60037250625 25600000000\n## \n## , , 2\n## \n##              [,1]      [,2]        [,3]\n## [1,]          985       684         133\n## [2,]       868624    131044      159201\n## [3,]      6229504 241804367   523606616\n## [4,] 216340335376 312900721 33556377856\n\nbc.i(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.i.html#broadcasted-integer-numeric-operations-with-extra-overflow-protection",
    "href": "man/bc.i.html#broadcasted-integer-numeric-operations-with-extra-overflow-protection",
    "title": "bc.i",
    "section": "",
    "text": "The bc.i() function performs broadcasted integer numeric operations on 2 numeric or logical arrays.   Please note that these operations will treat the input as 53bit integers, and will efficiently truncate when necessary.  Therefore, something like bc.i(1, 1.5, “==”) returns TRUE, because trunc(1.5) equals 1.  \n\n\n\nbc.i(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable logical or numeric arrays.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported arithmetic operators: +, -, *, gcd, ^, pmin, pmax.  Supported relational operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=. \n\n\n\n\n\n\n\nFor arithmetic operators:  A numeric array of whole numbers, as a result of the broadcasted arithmetic operation.  Base ‘R’ supports 53 bit integers, which thus range from approximately -9 quadrillion to +9 quadrillion.  Values outside of this range will be returned as -Inf or Inf, as an extra protection against integer overflow.   For relational operators:  A logical array as a result of the broadcasted integer relational comparison.  \n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(NA, 1.1:1000.1), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\nbc.i(x, y, \"+\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  881  427  806\n## [2,]  598   29  539\n## [3,]    8  449  665\n## [4,]  844  499  404\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  986  685  134\n## [2,]  934  364  401\n## [3,]  187  626  809\n## [4,]  686  137  432\nbc.i(x, y, \"-\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  879  425  804\n## [2,]  594   25  535\n## [3,]    2  443  659\n## [4,]  836  491  396\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  984  683  132\n## [2,]  930  360  397\n## [3,]  181  620  803\n## [4,]  678  129  424\nbc.i(x, y, \"*\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]  880  426  805\n## [2,] 1192   54 1074\n## [3,]   15 1338 1986\n## [4,] 3360 1980 1600\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]  985  684  133\n## [2,] 1864  724  798\n## [3,]  552 1869 2418\n## [4,] 2728  532 1712\nbc.i(x, y, \"gcd\") # greatest common divisor\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    1    1\n## [3,]    1    1    1\n## [4,]    4    1    4\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]    1    1    1\n## [2,]    2    2    1\n## [3,]    1    1    1\n## [4,]    2    1    4\nbc.i(x, y, \"^\")\n## , , 1\n## \n##              [,1]        [,2]        [,3]\n## [1,]          880         426         805\n## [2,]       355216         729      288369\n## [3,]          125    88716536   290117528\n## [4,] 497871360000 60037250625 25600000000\n## \n## , , 2\n## \n##              [,1]      [,2]        [,3]\n## [1,]          985       684         133\n## [2,]       868624    131044      159201\n## [3,]      6229504 241804367   523606616\n## [4,] 216340335376 312900721 33556377856\n\nbc.i(x, y, \"==\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"!=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\nbc.i(x, y, \"&lt;=\")\n## , , 1\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\n## \n## , , 2\n## \n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n## [2,] FALSE FALSE FALSE\n## [3,] FALSE FALSE FALSE\n## [4,] FALSE FALSE FALSE\nbc.i(x, y, \"&gt;=\")\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,] TRUE TRUE TRUE\n## [2,] TRUE TRUE TRUE\n## [3,] TRUE TRUE TRUE\n## [4,] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc.str.html",
    "href": "man/bc.str.html",
    "title": "bc.str",
    "section": "",
    "text": "The bc.str() function performs broadcasted string operations on pairs of arrays.  \n\n\n\nbc.str(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of typee character.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported concatenation operators: +.  Supported relational operators: ==, !=.  Supported distance operators: levenshtein. \n\n\n\n\n\n\n\nFor concatenation operation:  A character array as a result of the broadcasted concatenation operation.   For relational operation:  A logical array as a result of the broadcasted relational comparison.   For distance operation:  An integer array as a result of the broadcasted distance measurement.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# string concatenation:\nx &lt;- array(letters, c(10, 2, 1))\ny &lt;- array(letters, c(10,1,1))\nbc.str(x, y, \"+\")\n## , , 1\n## \n##       [,1] [,2]\n##  [1,] \"aa\" \"ka\"\n##  [2,] \"bb\" \"lb\"\n##  [3,] \"cc\" \"mc\"\n##  [4,] \"dd\" \"nd\"\n##  [5,] \"ee\" \"oe\"\n##  [6,] \"ff\" \"pf\"\n##  [7,] \"gg\" \"qg\"\n##  [8,] \"hh\" \"rh\"\n##  [9,] \"ii\" \"si\"\n## [10,] \"jj\" \"tj\"\n\n\n# string (in)equality:\nbc.str(array(letters), array(letters), \"==\")\n##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\nbc.str(array(letters), array(letters), \"!=\")\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE\n\n\n# string distance (Levenshtein):\nx &lt;- array(month.name, c(12, 1))\ny &lt;- array(month.abb, c(1, 12))\nout &lt;- bc.str(x, y, \"levenshtein\")\ndimnames(out) &lt;- list(month.name, month.abb)\nprint(out)\n##           Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n## January     4   7   5   6   5   5   5   6   7   7   7   7\n## February    7   5   6   7   6   7   7   7   7   8   8   7\n## March       4   5   2   4   3   5   5   5   5   4   5   4\n## April       5   5   4   2   5   5   4   4   5   5   5   5\n## May         2   3   1   3   0   3   3   3   3   3   3   3\n## June        2   4   4   4   4   1   2   3   4   4   4   4\n## July        3   4   4   4   3   2   1   3   4   4   4   4\n## August      6   6   6   5   6   5   5   3   6   5   6   6\n## September   9   7   8   7   9   9   9   9   6   8   9   8\n## October     7   6   6   6   7   7   7   7   6   4   6   6\n## November    8   6   7   7   8   8   8   8   7   8   5   7\n## December    8   6   7   7   8   8   8   8   7   7   8   5"
  },
  {
    "objectID": "man/bc.str.html#broadcasted-string-operations",
    "href": "man/bc.str.html#broadcasted-string-operations",
    "title": "bc.str",
    "section": "",
    "text": "The bc.str() function performs broadcasted string operations on pairs of arrays.  \n\n\n\nbc.str(x, y, op)\n\n\n\n\n\n\n\n\nx, y\n\n\nconformable atomic arrays of typee character.\n\n\n\n\nop\n\n\na single string, giving the operator.  Supported concatenation operators: +.  Supported relational operators: ==, !=.  Supported distance operators: levenshtein. \n\n\n\n\n\n\n\nFor concatenation operation:  A character array as a result of the broadcasted concatenation operation.   For relational operation:  A logical array as a result of the broadcasted relational comparison.   For distance operation:  An integer array as a result of the broadcasted distance measurement.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# string concatenation:\nx &lt;- array(letters, c(10, 2, 1))\ny &lt;- array(letters, c(10,1,1))\nbc.str(x, y, \"+\")\n## , , 1\n## \n##       [,1] [,2]\n##  [1,] \"aa\" \"ka\"\n##  [2,] \"bb\" \"lb\"\n##  [3,] \"cc\" \"mc\"\n##  [4,] \"dd\" \"nd\"\n##  [5,] \"ee\" \"oe\"\n##  [6,] \"ff\" \"pf\"\n##  [7,] \"gg\" \"qg\"\n##  [8,] \"hh\" \"rh\"\n##  [9,] \"ii\" \"si\"\n## [10,] \"jj\" \"tj\"\n\n\n# string (in)equality:\nbc.str(array(letters), array(letters), \"==\")\n##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\nbc.str(array(letters), array(letters), \"!=\")\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [25] FALSE FALSE\n\n\n# string distance (Levenshtein):\nx &lt;- array(month.name, c(12, 1))\ny &lt;- array(month.abb, c(1, 12))\nout &lt;- bc.str(x, y, \"levenshtein\")\ndimnames(out) &lt;- list(month.name, month.abb)\nprint(out)\n##           Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n## January     4   7   5   6   5   5   5   6   7   7   7   7\n## February    7   5   6   7   6   7   7   7   7   8   8   7\n## March       4   5   2   4   3   5   5   5   5   4   5   4\n## April       5   5   4   2   5   5   4   4   5   5   5   5\n## May         2   3   1   3   0   3   3   3   3   3   3   3\n## June        2   4   4   4   4   1   2   3   4   4   4   4\n## July        3   4   4   4   3   2   1   3   4   4   4   4\n## August      6   6   6   5   6   5   5   3   6   5   6   6\n## September   9   7   8   7   9   9   9   9   6   8   9   8\n## October     7   6   6   6   7   7   7   7   6   4   6   6\n## November    8   6   7   7   8   8   8   8   7   8   5   7\n## December    8   6   7   7   8   8   8   8   7   7   8   5"
  },
  {
    "objectID": "man/bc_dim.html",
    "href": "man/bc_dim.html",
    "title": "bc_dim",
    "section": "",
    "text": "bc_dim(x, y) gives the dimensions an array would have, as the result of an broadcasted binary element-wise operation between 2 arrays x and y.\n\n\n\nbc_dim(x, y)\n\n\n\n\n\n\n\n\nx, y\n\n\nan atomic or recursive array.\n\n\n\n\n\n\n\nReturns the recycled array.\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\ndim(bc.b(x, y, \"&\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE\ndim(bc.b(x, y, \"|\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bc_dim.html#predict-broadcasted-dimensions",
    "href": "man/bc_dim.html#predict-broadcasted-dimensions",
    "title": "bc_dim",
    "section": "",
    "text": "bc_dim(x, y) gives the dimensions an array would have, as the result of an broadcasted binary element-wise operation between 2 arrays x and y.\n\n\n\nbc_dim(x, y)\n\n\n\n\n\n\n\n\nx, y\n\n\nan atomic or recursive array.\n\n\n\n\n\n\n\nReturns the recycled array.\n\n\n\n\nlibrary(\"broadcast\")\n\nx.dim &lt;- c(4:2)\nx.len &lt;- prod(x.dim)\nx.data &lt;- sample(c(TRUE, FALSE, NA), x.len, TRUE)\nx &lt;- array(x.data, x.dim)\ny &lt;- array(1:50, c(4,1,1))\n\ndim(bc.b(x, y, \"&\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE\ndim(bc.b(x, y, \"|\")) == bc_dim(x, y)\n## [1] TRUE TRUE TRUE"
  },
  {
    "objectID": "man/bind.html",
    "href": "man/bind.html",
    "title": "bind",
    "section": "",
    "text": "The bind_implementations provide dimensional binding functionalities.   The following implementations are available:\n\n\nbind_mat() binds dimensionless (atomic/recursive) vectors and (atomic/recursive) matrices row- or column-wise.  Allows for recycling.\n\n\nbind_array() binds (atomic/recursive) arrays and (atomic/recursive) matrices.  Allows for broadcasting.\n\n\nbind_dt() binds data.tables and other data.frame-like objects.  This function is only available if the ‘data.table’ package is installed.  Returns a data.table.  Faster than do.call(cbind, …) or do.call(rbind, …) for regular data.frame objects. \n\n\nNote that the naming convention of the binding implementations here is \"bind_\" followed by the resulting class (abbreviated).  I.e. bind_mat returns a matrix, but can bind both matrices and vectors.  And bind_array returns an array, but can bind both arrays and matrices.  And bind_dt returns a data.table, but can bind not only data.tables, but also most other data.frame-like objects.  \n\n\n\nbind_mat(input, along, name_deparse = TRUE, comnames_from = 1L)\n\nbind_array(\n  input,\n  along,\n  rev = FALSE,\n  ndim2bc = 1L,\n  name_along = TRUE,\n  comnames_from = 1L\n)\n\nbind_dt(input, along, ...)\n\n\n\n\n\n\n\n\ninput\n\n\na list of only the appropriate objects.  If input is named, its names will be used for the names of dimension along of the output, as far as possible.\n\n\n\n\nalong\n\n\na single integer, indicating the dimension along which to bind the dimensions.  I.e. use along = 1 for row-binding, along = 2 for column-binding, etc.  For arrays, additional flexibility is available:\n\n\nSpecifying along = 0 will bind the arrays on a new dimension before the first, making along the new first dimension.\n\n\nSpecifying along = N + 1, with N = max(lst.ndim(input)), will create an additional dimension (N + 1) and bind the arrays along that new dimension.\n\n\n\n\n\n\nname_deparse\n\n\nBoolean, for bind_mat().  Indicates if dimension along should be named.  Uses the naming method from rbind/cbind itself.\n\n\n\n\ncomnames_from\n\n\neither integer scalar or NULL, for bind_mat() and bind_array().  Indicates which object in input should be used for naming the shared dimension.  If NULL, no communal names will be given.  For example:  When binding columns of matrices, the matrices will share the same rownames.  Using comnames_from = 10 will then result in bind_array() using rownames(input[[10]]) for the rownames of the output.\n\n\n\n\nrev\n\n\nBoolean, for bind_array() only.  Indicates if along should be reversed, counting backwards.  If FALSE (default), along works like normally; if TRUE, along is reversed.  I.e. along = 0, rev = TRUE is equivalent to along = N+1, rev = FALSE;  and along = N+1, rev = TRUE is equivalent to along = 0, rev = FALSE;  with N = max(lst.ndim(input)).\n\n\n\n\nndim2bc\n\n\nnon-negative integer, for bind_array only.  Specify here the maximum number of dimensions that are allowed to be broadcasted when binding arrays.  If ndim2bc = 0L, no broadcasting will be allowed at all.\n\n\n\n\nname_along\n\n\nBoolean, for bind_array().  Indicates if dimension along should be named.\n\n\n\n\n…\n\n\narguments to be passed to rbindlist.  \n\n\n\n\n\n\n\nFor in-depth information about the binding implentations in the ‘broadcast’ package, please refer to broadcast_bind.  \n\n\n\nThe bound object.\n\n\n\nPlate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# bind_array ====\n\n# here, atomic and recursive arrays are mixed,\n# resulting in recursive arrays\n\n# creating the arrays\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx &lt;- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\n# binding the arrays\ninput &lt;- list(x = x, y = y)\nbind_array(input, along = 0L) # binds on new dimension before first\n## , , 1\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , 2\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , 3\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\nbind_array(input, along = 1L) # binds on first dimension (i.e. rows)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 3L) # bind on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\n\nbind_array(input, along = 0L, TRUE) # binds on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\nbind_array(input, along = 1L, TRUE) # binds on last dimension (i.e. columns)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 2L, TRUE)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 3L, TRUE) # bind on new dimension before first\n## , , 1\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , 2\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , 3\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\n\n\n# binding, with empty arrays\nemptyarray &lt;- array(numeric(0L), c(0L, 3L))\ndimnames(emptyarray) &lt;- list(NULL, paste(\"empty\", 1:3))\nprint(emptyarray)\n##      empty 1 empty 2 empty 3\ninput &lt;- list(x = x, y = emptyarray)\nbind_array(input, along = 1L, comnames_from = 2L) # row-bind\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\n\n\n################################################################################\n\n# bind_mat ====\n\n# here, atomic and recursive matrices are mixed,\n# resulting in a recursive matrix\n\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx &lt;- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\nbind_mat(list(x = x, y = y), 2L)\n##   A            B            C                  \n## a logical,3    logical,3    logical,3    1 5 9 \n## b integer,10   integer,10   integer,10   2 6 10\n## c numeric,10   numeric,10   numeric,10   3 7 11\n## d character,26 character,26 character,26 4 8 12\n\n\n\n################################################################################\n\n# bind_dt ====\nif(require(data.table)) {\n  x &lt;- data.frame(a = 1:12, b = month.abb) # data.frame\n  y &lt;- data.table::data.table(a = 1:12, b = month.abb) # data.table\n  \n  bind_dt(list(x = x, y = y), 2L) # column bind\n  \n  bind_dt(list(x = x, y = y), 1L) # row bind\n  \n}\n##         a      b\n##     &lt;int&gt; &lt;char&gt;\n##  1:     1    Jan\n##  2:     2    Feb\n##  3:     3    Mar\n##  4:     4    Apr\n##  5:     5    May\n##  6:     6    Jun\n##  7:     7    Jul\n##  8:     8    Aug\n##  9:     9    Sep\n## 10:    10    Oct\n## 11:    11    Nov\n## 12:    12    Dec\n## 13:     1    Jan\n## 14:     2    Feb\n## 15:     3    Mar\n## 16:     4    Apr\n## 17:     5    May\n## 18:     6    Jun\n## 19:     7    Jul\n## 20:     8    Aug\n## 21:     9    Sep\n## 22:    10    Oct\n## 23:    11    Nov\n## 24:    12    Dec\n##         a      b"
  },
  {
    "objectID": "man/bind.html#dimensional-binding-of-objects",
    "href": "man/bind.html#dimensional-binding-of-objects",
    "title": "bind",
    "section": "",
    "text": "The bind_implementations provide dimensional binding functionalities.   The following implementations are available:\n\n\nbind_mat() binds dimensionless (atomic/recursive) vectors and (atomic/recursive) matrices row- or column-wise.  Allows for recycling.\n\n\nbind_array() binds (atomic/recursive) arrays and (atomic/recursive) matrices.  Allows for broadcasting.\n\n\nbind_dt() binds data.tables and other data.frame-like objects.  This function is only available if the ‘data.table’ package is installed.  Returns a data.table.  Faster than do.call(cbind, …) or do.call(rbind, …) for regular data.frame objects. \n\n\nNote that the naming convention of the binding implementations here is \"bind_\" followed by the resulting class (abbreviated).  I.e. bind_mat returns a matrix, but can bind both matrices and vectors.  And bind_array returns an array, but can bind both arrays and matrices.  And bind_dt returns a data.table, but can bind not only data.tables, but also most other data.frame-like objects.  \n\n\n\nbind_mat(input, along, name_deparse = TRUE, comnames_from = 1L)\n\nbind_array(\n  input,\n  along,\n  rev = FALSE,\n  ndim2bc = 1L,\n  name_along = TRUE,\n  comnames_from = 1L\n)\n\nbind_dt(input, along, ...)\n\n\n\n\n\n\n\n\ninput\n\n\na list of only the appropriate objects.  If input is named, its names will be used for the names of dimension along of the output, as far as possible.\n\n\n\n\nalong\n\n\na single integer, indicating the dimension along which to bind the dimensions.  I.e. use along = 1 for row-binding, along = 2 for column-binding, etc.  For arrays, additional flexibility is available:\n\n\nSpecifying along = 0 will bind the arrays on a new dimension before the first, making along the new first dimension.\n\n\nSpecifying along = N + 1, with N = max(lst.ndim(input)), will create an additional dimension (N + 1) and bind the arrays along that new dimension.\n\n\n\n\n\n\nname_deparse\n\n\nBoolean, for bind_mat().  Indicates if dimension along should be named.  Uses the naming method from rbind/cbind itself.\n\n\n\n\ncomnames_from\n\n\neither integer scalar or NULL, for bind_mat() and bind_array().  Indicates which object in input should be used for naming the shared dimension.  If NULL, no communal names will be given.  For example:  When binding columns of matrices, the matrices will share the same rownames.  Using comnames_from = 10 will then result in bind_array() using rownames(input[[10]]) for the rownames of the output.\n\n\n\n\nrev\n\n\nBoolean, for bind_array() only.  Indicates if along should be reversed, counting backwards.  If FALSE (default), along works like normally; if TRUE, along is reversed.  I.e. along = 0, rev = TRUE is equivalent to along = N+1, rev = FALSE;  and along = N+1, rev = TRUE is equivalent to along = 0, rev = FALSE;  with N = max(lst.ndim(input)).\n\n\n\n\nndim2bc\n\n\nnon-negative integer, for bind_array only.  Specify here the maximum number of dimensions that are allowed to be broadcasted when binding arrays.  If ndim2bc = 0L, no broadcasting will be allowed at all.\n\n\n\n\nname_along\n\n\nBoolean, for bind_array().  Indicates if dimension along should be named.\n\n\n\n\n…\n\n\narguments to be passed to rbindlist.  \n\n\n\n\n\n\n\nFor in-depth information about the binding implentations in the ‘broadcast’ package, please refer to broadcast_bind.  \n\n\n\nThe bound object.\n\n\n\nPlate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.\n\n\n\n\nlibrary(\"broadcast\")\n\n\n# bind_array ====\n\n# here, atomic and recursive arrays are mixed,\n# resulting in recursive arrays\n\n# creating the arrays\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx &lt;- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\n# binding the arrays\ninput &lt;- list(x = x, y = y)\nbind_array(input, along = 0L) # binds on new dimension before first\n## , , 1\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , 2\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , 3\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\nbind_array(input, along = 1L) # binds on first dimension (i.e. rows)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 2L)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 3L) # bind on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\n\nbind_array(input, along = 0L, TRUE) # binds on new dimension after last\n## , , x\n## \n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n## \n## , , y\n## \n##   A B C \n## a 1 5 9 \n## b 2 6 10\n## c 3 7 11\n## d 4 8 12\nbind_array(input, along = 1L, TRUE) # binds on last dimension (i.e. columns)\n##   A            B            C            y.1 y.2 y.3\n## a logical,3    logical,3    logical,3    1   5   9  \n## b integer,10   integer,10   integer,10   2   6   10 \n## c numeric,10   numeric,10   numeric,10   3   7   11 \n## d character,26 character,26 character,26 4   8   12\nbind_array(input, along = 2L, TRUE)\n##     A            B            C           \n## a   logical,3    logical,3    logical,3   \n## b   integer,10   integer,10   integer,10  \n## c   numeric,10   numeric,10   numeric,10  \n## d   character,26 character,26 character,26\n## y.1 1            5            9           \n## y.2 2            6            10          \n## y.3 3            7            11          \n## y.4 4            8            12\nbind_array(input, along = 3L, TRUE) # bind on new dimension before first\n## , , 1\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 1         2          3          4           \n## \n## , , 2\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 5         6          7          8           \n## \n## , , 3\n## \n##   a         b          c          d           \n## x logical,3 integer,10 numeric,10 character,26\n## y 9         10         11         12\n\n\n# binding, with empty arrays\nemptyarray &lt;- array(numeric(0L), c(0L, 3L))\ndimnames(emptyarray) &lt;- list(NULL, paste(\"empty\", 1:3))\nprint(emptyarray)\n##      empty 1 empty 2 empty 3\ninput &lt;- list(x = x, y = emptyarray)\nbind_array(input, along = 1L, comnames_from = 2L) # row-bind\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\n\n\n################################################################################\n\n# bind_mat ====\n\n# here, atomic and recursive matrices are mixed,\n# resulting in a recursive matrix\n\nx &lt;- c(\n  lapply(1:3, \\(x)sample(c(TRUE, FALSE, NA))),\n  lapply(1:3, \\(x)sample(1:10)),\n  lapply(1:3, \\(x)rnorm(10)),\n  lapply(1:3, \\(x)sample(letters))\n)\nx &lt;- matrix(x, 4, 3, byrow = TRUE)\ndimnames(x) &lt;- list(letters[1:4], LETTERS[1:3])\nprint(x)\n##   A            B            C           \n## a logical,3    logical,3    logical,3   \n## b integer,10   integer,10   integer,10  \n## c numeric,10   numeric,10   numeric,10  \n## d character,26 character,26 character,26\n\ny &lt;- matrix(1:12, 4, 3)\nprint(y)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\nbind_mat(list(x = x, y = y), 2L)\n##   A            B            C                  \n## a logical,3    logical,3    logical,3    1 5 9 \n## b integer,10   integer,10   integer,10   2 6 10\n## c numeric,10   numeric,10   numeric,10   3 7 11\n## d character,26 character,26 character,26 4 8 12\n\n\n\n################################################################################\n\n# bind_dt ====\nif(require(data.table)) {\n  x &lt;- data.frame(a = 1:12, b = month.abb) # data.frame\n  y &lt;- data.table::data.table(a = 1:12, b = month.abb) # data.table\n  \n  bind_dt(list(x = x, y = y), 2L) # column bind\n  \n  bind_dt(list(x = x, y = y), 1L) # row bind\n  \n}\n##         a      b\n##     &lt;int&gt; &lt;char&gt;\n##  1:     1    Jan\n##  2:     2    Feb\n##  3:     3    Mar\n##  4:     4    Apr\n##  5:     5    May\n##  6:     6    Jun\n##  7:     7    Jul\n##  8:     8    Aug\n##  9:     9    Sep\n## 10:    10    Oct\n## 11:    11    Nov\n## 12:    12    Dec\n## 13:     1    Jan\n## 14:     2    Feb\n## 15:     3    Mar\n## 16:     4    Apr\n## 17:     5    May\n## 18:     6    Jun\n## 19:     7    Jul\n## 20:     8    Aug\n## 21:     9    Sep\n## 22:    10    Oct\n## 23:    11    Nov\n## 24:    12    Dec\n##         a      b"
  },
  {
    "objectID": "man/typecast.html",
    "href": "man/typecast.html",
    "title": "typecast",
    "section": "",
    "text": "Type casting usually strips away attributes of objects.  The functions provided here preserve dimensions, dimnames, and names, which may be more convenient for arrays and array-like objects.   The functions are as follows: \n\n\nas_bool(): converts object to atomic type logical (TRUE, FALSE, NA).\n\n\nas_int(): converts object to atomic type integer.\n\n\nas_dbl(): converts object to atomic type double (AKA numeric).\n\n\nas_chr(): converts object to atomic type character.\n\n\nas_cplx(): converts object to atomic type complex.\n\n\nas_raw(): converts object to atomic type raw.\n\n\nas_list(): converts object to recursive type list. \n\n\nas_num() is an alias for as_dbl().  as_str() is an alias for as_chr().   See also typeof.  \n\n\n\nas_bool(x, ...)\n\nas_int(x, ...)\n\nas_dbl(x, ...)\n\nas_num(x, ...)\n\nas_chr(x, ...)\n\nas_str(x, ...)\n\nas_cplx(x, ...)\n\nas_raw(x, ...)\n\nas_list(x, ...)\n\n\n\n\n\n\n\n\nx\n\n\nan R object.\n\n\n\n\n…\n\n\nfurther arguments passed to or from other methods.\n\n\n\n\n\n\n\nThe converted object.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- matrix(sample(-1:28), ncol = 5)\ncolnames(x) &lt;- month.name[1:5]\nrownames(x) &lt;- month.abb[1:6]\nnames(x) &lt;- c(letters[1:20], LETTERS[1:10])\nprint(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\nas_bool(x)\n##     January February March April  May\n## Jan    TRUE     TRUE  TRUE  TRUE TRUE\n## Feb    TRUE     TRUE  TRUE  TRUE TRUE\n## Mar    TRUE     TRUE  TRUE  TRUE TRUE\n## Apr    TRUE     TRUE FALSE  TRUE TRUE\n## May    TRUE     TRUE  TRUE  TRUE TRUE\n## Jun    TRUE     TRUE  TRUE  TRUE TRUE\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_int(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_dbl(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_chr(x)\n##     January February March April May \n## Jan \"21\"    \"8\"      \"16\"  \"4\"   \"25\"\n## Feb \"11\"    \"28\"     \"7\"   \"10\"  \"12\"\n## Mar \"9\"     \"2\"      \"1\"   \"13\"  \"19\"\n## Apr \"15\"    \"6\"      \"0\"   \"5\"   \"14\"\n## May \"27\"    \"-1\"     \"3\"   \"26\"  \"20\"\n## Jun \"17\"    \"23\"     \"24\"  \"22\"  \"18\"\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_cplx(x)\n##     January February March April   May\n## Jan   21+0i     8+0i 16+0i  4+0i 25+0i\n## Feb   11+0i    28+0i  7+0i 10+0i 12+0i\n## Mar    9+0i     2+0i  1+0i 13+0i 19+0i\n## Apr   15+0i     6+0i  0+0i  5+0i 14+0i\n## May   27+0i    -1+0i  3+0i 26+0i 20+0i\n## Jun   17+0i    23+0i 24+0i 22+0i 18+0i\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_raw(x)\n##     January February March April May\n## Jan      15       08    10    04  19\n## Feb      0b       1c    07    0a  0c\n## Mar      09       02    01    0d  13\n## Apr      0f       06    00    05  0e\n## May      1b       00    03    1a  14\n## Jun      11       17    18    16  12\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\n\n################################################################################\n\n# factor example ====\nx &lt;- factor(month.abb, levels = month.abb)\nnames(x) &lt;- month.name\nprint(x)\n##   January  February     March     April       May      June      July    August \n##       Jan       Feb       Mar       Apr       May       Jun       Jul       Aug \n## September   October  November  December \n##       Sep       Oct       Nov       Dec \n## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nas_bool(as_int(x) &gt; 6)\n##   January  February     March     April       May      June      July    August \n##     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE \n## September   October  November  December \n##      TRUE      TRUE      TRUE      TRUE\nas_int(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_dbl(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_chr(x)\n##   January  February     March     April       May      June      July    August \n##     \"Jan\"     \"Feb\"     \"Mar\"     \"Apr\"     \"May\"     \"Jun\"     \"Jul\"     \"Aug\" \n## September   October  November  December \n##     \"Sep\"     \"Oct\"     \"Nov\"     \"Dec\"\nas_cplx(x)\n##   January  February     March     April       May      June      July    August \n##  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i\n## September   October  November  December \n##  9+0i 10+0i 11+0i 12+0i\nas_raw(x)\n##   January  February     March     April       May      June      July    August \n##        01        02        03        04        05        06        07        08 \n## September   October  November  December \n##        09        0a        0b        0c"
  },
  {
    "objectID": "man/typecast.html#atomic-and-list-type-casting-with-names-and-dimensions-preserved",
    "href": "man/typecast.html#atomic-and-list-type-casting-with-names-and-dimensions-preserved",
    "title": "typecast",
    "section": "",
    "text": "Type casting usually strips away attributes of objects.  The functions provided here preserve dimensions, dimnames, and names, which may be more convenient for arrays and array-like objects.   The functions are as follows: \n\n\nas_bool(): converts object to atomic type logical (TRUE, FALSE, NA).\n\n\nas_int(): converts object to atomic type integer.\n\n\nas_dbl(): converts object to atomic type double (AKA numeric).\n\n\nas_chr(): converts object to atomic type character.\n\n\nas_cplx(): converts object to atomic type complex.\n\n\nas_raw(): converts object to atomic type raw.\n\n\nas_list(): converts object to recursive type list. \n\n\nas_num() is an alias for as_dbl().  as_str() is an alias for as_chr().   See also typeof.  \n\n\n\nas_bool(x, ...)\n\nas_int(x, ...)\n\nas_dbl(x, ...)\n\nas_num(x, ...)\n\nas_chr(x, ...)\n\nas_str(x, ...)\n\nas_cplx(x, ...)\n\nas_raw(x, ...)\n\nas_list(x, ...)\n\n\n\n\n\n\n\n\nx\n\n\nan R object.\n\n\n\n\n…\n\n\nfurther arguments passed to or from other methods.\n\n\n\n\n\n\n\nThe converted object.  \n\n\n\n\nlibrary(\"broadcast\")\n\n\n# matrix example ====\nx &lt;- matrix(sample(-1:28), ncol = 5)\ncolnames(x) &lt;- month.name[1:5]\nrownames(x) &lt;- month.abb[1:6]\nnames(x) &lt;- c(letters[1:20], LETTERS[1:10])\nprint(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\nas_bool(x)\n##     January February March April  May\n## Jan    TRUE     TRUE  TRUE  TRUE TRUE\n## Feb    TRUE     TRUE  TRUE  TRUE TRUE\n## Mar    TRUE     TRUE  TRUE  TRUE TRUE\n## Apr    TRUE     TRUE FALSE  TRUE TRUE\n## May    TRUE     TRUE  TRUE  TRUE TRUE\n## Jun    TRUE     TRUE  TRUE  TRUE TRUE\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_int(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_dbl(x)\n##     January February March April May\n## Jan      21        8    16     4  25\n## Feb      11       28     7    10  12\n## Mar       9        2     1    13  19\n## Apr      15        6     0     5  14\n## May      27       -1     3    26  20\n## Jun      17       23    24    22  18\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_chr(x)\n##     January February March April May \n## Jan \"21\"    \"8\"      \"16\"  \"4\"   \"25\"\n## Feb \"11\"    \"28\"     \"7\"   \"10\"  \"12\"\n## Mar \"9\"     \"2\"      \"1\"   \"13\"  \"19\"\n## Apr \"15\"    \"6\"      \"0\"   \"5\"   \"14\"\n## May \"27\"    \"-1\"     \"3\"   \"26\"  \"20\"\n## Jun \"17\"    \"23\"     \"24\"  \"22\"  \"18\"\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_cplx(x)\n##     January February March April   May\n## Jan   21+0i     8+0i 16+0i  4+0i 25+0i\n## Feb   11+0i    28+0i  7+0i 10+0i 12+0i\n## Mar    9+0i     2+0i  1+0i 13+0i 19+0i\n## Apr   15+0i     6+0i  0+0i  5+0i 14+0i\n## May   27+0i    -1+0i  3+0i 26+0i 20+0i\n## Jun   17+0i    23+0i 24+0i 22+0i 18+0i\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\nas_raw(x)\n##     January February March April May\n## Jan      15       08    10    04  19\n## Feb      0b       1c    07    0a  0c\n## Mar      09       02    01    0d  13\n## Apr      0f       06    00    05  0e\n## May      1b       00    03    1a  14\n## Jun      11       17    18    16  12\n## attr(,\"names\")\n##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\"\n\n\n################################################################################\n\n# factor example ====\nx &lt;- factor(month.abb, levels = month.abb)\nnames(x) &lt;- month.name\nprint(x)\n##   January  February     March     April       May      June      July    August \n##       Jan       Feb       Mar       Apr       May       Jun       Jul       Aug \n## September   October  November  December \n##       Sep       Oct       Nov       Dec \n## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nas_bool(as_int(x) &gt; 6)\n##   January  February     March     April       May      June      July    August \n##     FALSE     FALSE     FALSE     FALSE     FALSE     FALSE      TRUE      TRUE \n## September   October  November  December \n##      TRUE      TRUE      TRUE      TRUE\nas_int(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_dbl(x)\n##   January  February     March     April       May      June      July    August \n##         1         2         3         4         5         6         7         8 \n## September   October  November  December \n##         9        10        11        12\nas_chr(x)\n##   January  February     March     April       May      June      July    August \n##     \"Jan\"     \"Feb\"     \"Mar\"     \"Apr\"     \"May\"     \"Jun\"     \"Jul\"     \"Aug\" \n## September   October  November  December \n##     \"Sep\"     \"Oct\"     \"Nov\"     \"Dec\"\nas_cplx(x)\n##   January  February     March     April       May      June      July    August \n##  1+0i  2+0i  3+0i  4+0i  5+0i  6+0i  7+0i  8+0i\n## September   October  November  December \n##  9+0i 10+0i 11+0i 12+0i\nas_raw(x)\n##   January  February     March     April       May      June      July    August \n##        01        02        03        04        05        06        07        08 \n## September   October  November  December \n##        09        0a        0b        0c"
  },
  {
    "objectID": "vignettes/a_readme.html#overview",
    "href": "vignettes/a_readme.html#overview",
    "title": "Introduction",
    "section": "🗺️Overview",
    "text": "🗺️Overview\nThe ‘broadcast’ ‘R’-package, as the name suggests, performs “broadcasting” (similar to broadcasting in the ‘Numpy’ module for ‘Python’).\nIn the context of operations involving 2 (or more) arrays, “broadcasting” refers to recycling array dimensions without allocating additional memory, which is considerably faster and more memory-efficient than R’s regular dimensions repetition mechanism.\nPlease read the article “Broadcasting explained” for a more complete explanation of what “broadcasting” is.\n \nAt its core, the ‘broadcast’ package provides 3 functionalities, all 3 related to “broadcasting”:\n \nFirst, ‘broadcast’ provides functions for element-wise outer computations between any 2 arrays.\nThese are similar to base R’s outer() function, but using broadcasting, which is faster and more efficient than the mechanism employed by outer().\nThe outer-like functions provided by ‘broadcast’ are optimised for a large set of operations, including, but not limited to, the following:\n\nrelational operations (like ==, !=, &lt;, &gt;, &lt;=, &gt;=, etc.);\narithmetic operations (like +, -, *, /, ^, etc.);\nBoolean combiner operations (like &, |, xor, etc.);\nstring concatenation, string (in)equality, and string distance (Levenshtein) operations.\n\nBase ‘R’ outer() function has some sloppy rules regarding the dimensions of the output, making it hard to predict the output shape.\nThe outer-like functions provided by ‘broadcast’ have very strict broadcasting rules, making it easy to accurately predict the dimensions of the result.\n \nSecond, ‘broadcast’ provides the bind_array() function, which is an broadcasted and enhanced form of the fantastic abind::abind() function:\n\nbind_array() allows for broadcasting (obviously), whereas abind::abind() does not.\nbind_array() is significantly faster and uses less memory than abind::abind().\nbind_array() also differs from abind::abind() in that it can handle recursive arrays properly; abind::abind() unlists everything to atomic arrays, ruining the structure.\n\n \nThird, ‘broadcast’ provides several generic functions for broadcasting:\n\nbcapply(): a broadcasted apply-like function that works on pairs of arrays.\nbc_ifelse(): a broadcasted ifelse() function. Broadcasts between the yes and no arguments."
  },
  {
    "objectID": "vignettes/a_readme.html#why-use-broadcast",
    "href": "vignettes/a_readme.html#why-use-broadcast",
    "title": "Introduction",
    "section": "🤷🏽Why use ‘broadcast’",
    "text": "🤷🏽Why use ‘broadcast’\nEfficiency\nBroadcasting dimensions is faster and more memory efficient than repeating dimensions.\nThis is not simply a need for speed.\nEfficient programs use less energy and resources, and is thus better for the environment.\nAs a favoured language for the sciences, ‘R’ should not throw away an opportunity to become more efficient.\nThe Benchmarks show that ‘broadcast’ has a somewhat similar speed as equivalent operations in ‘Numpy’.\n \nConvenience\nBroadcasting can make many applications much easier to write.\nFor Example: Suppose you want to compute some metric on all possible pair-wise combinations of the elements of 2 vectors.\nYou could write slow and ugly nested for-loops…\nBut you can instead also make the vectors orthogonal, and perform the broadcasting computation on the 2 orthogonal vectors.\nThe broadcasted method runs much faster, is faster to type, and easier to reason about, than using the clumsy nested for-loops.\nFor more practical examples, see Examples of Practical Applictaions.\n \nMinimal Dependencies\nBesides linking to ‘Rcpp’, ‘broadcast’ does not depend on, vendor, link to, include, or otherwise use any external libraries; ‘broadcast’ was essentially made from scratch and can be installed out-of-the-box.\nNot using external libraries brings a number of advantages:\n\nAvoid dependency hell: Every dependency that is added to a software package increases the likelihood of something breaking (AKA “dependency hell”). ‘broadcast’ thus avoids this.\nAvoid wasting resources for translations: Using libraries from other languages, such as ‘xtensor’ (‘C++’) or ‘Numpy’ (‘Python’) means that - at some point - one needs to convert between the structure of R to that of the other language, and vice-versa, which wastes precious time and memory. ‘broadcast’ requires no such translations of structures, and thus does not waste precious time and memory.\nEnsure consistent behaviour: Using libraries from other languages also means one cannot always guarantee consistent behaviour of some operations. For example: both ‘Numpy’ and ‘xtensor’ have only limited support for missing values, whereas ‘R’ supports missing values for both atomic and recursive array/vector types (except type of ‘Raw’). Since ‘broadcast’ does not rely on external libraries, it can ensure consistent behaviour."
  },
  {
    "objectID": "vignettes/a_readme.html#documentation",
    "href": "vignettes/a_readme.html#documentation",
    "title": "Introduction",
    "section": "📖Documentation",
    "text": "📖Documentation\nThe documentation in the ‘broadcast’ website is divided into 3 main navigationable sections:\n\nGuides and Vignettes: Here you’ll find the topic-oriented guides in the form of a few Vignettes.\nReference Manual: Here you’ll find the function-oriented reference manual.\nAbout: Here you’ll find mainly the Changelog and License file."
  },
  {
    "objectID": "vignettes/c_broadcasting_explained.html#example-case",
    "href": "vignettes/c_broadcasting_explained.html#example-case",
    "title": "Broadcasting Explained",
    "section": "2.1 Example case",
    "text": "2.1 Example case\nLet’s start with a simple example.\nConsider the column vector x and the row vector y:\n\nx &lt;- array(1:5, c(5, 1))\ny &lt;- array(1:5*10, c(1, 5))\nprint(x)\n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    2\n#&gt; [3,]    3\n#&gt; [4,]    4\n#&gt; [5,]    5\nprint(y)\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   10   20   30   40   50\n\nSuppose one wishes to compute the outer sum of these 2 vectors.\nThis won’t work in base ‘R’:\n\nx + y\nError in x + y : non-conformable arrays\n\nWhen computing the outer sum of these vectors, both vectors need to be recycled to equal size in order to compute the outer computation.\nI.e. x needs its single column to be recycled (in this case) 5 times, and y needs its single row to be recycled 5 times, creating 2 conformable matrices.\n‘R’ provides linear vector recycling, but not recycling of array dimensions. Instead, in base ‘R’ we need to replicate (and thus copy) the array dimensions. This can be done manually, or using outer() |&gt; drop():\n\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55\n\nouter(x, y, \"+\") |&gt; drop()\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55"
  },
  {
    "objectID": "vignettes/c_broadcasting_explained.html#what-is-the-problem",
    "href": "vignettes/c_broadcasting_explained.html#what-is-the-problem",
    "title": "Broadcasting Explained",
    "section": "2.2 What is the problem?",
    "text": "2.2 What is the problem?\nWhen x and y are small arrays, like in the above example, there is hardly a problem; but when x and y become larger, the 3 matrices (x is replicated to a matrix, y is replicated to a matrix, and the result is also matrix) also become larger.\nIf the 3 matrices become too large, you may require more memory than is available in your current system, resulting in a message like the following:\n\n&gt; Error: cannot allocate vector of size\n\nThe problem isn’t limited to available memory. As the object sizes increase, the speed decreases. And let’s not forget that computational inefficiency in general is also bad for the environment."
  },
  {
    "objectID": "vignettes/c_broadcasting_explained.html#introducing-broadcasting",
    "href": "vignettes/c_broadcasting_explained.html#introducing-broadcasting",
    "title": "Broadcasting Explained",
    "section": "2.3 Introducing Broadcasting",
    "text": "2.3 Introducing Broadcasting\nIn an operation like outer(x, y, \"+\"), x and y are replicated to become the same size. The thing is, physical replication - and thus copying - of the dimensions of x and y should not be necessary; they only need to be recycled virtually.\nVirtual recycling does not actually physically replicate x and y. Instead, nested loops in ‘C’ and ‘C++’ are used to simulate a recycled array.\nThis is similar to how ‘R’ recycles regular (i.e. dimensionless) vectors.\nVirtual recycling requires no additional memory (apart from allocating the final end result); it is much faster and much more memory efficient than using the outer() function or something similar.\nAnd that is what broadcasting does: broadcasting provides fast virtual recycling of array dimensions in the context of operations involving 2 (or more) arrays without allocating additional memory.\nIn the earlier example, we used:\n\nx[, rep(1L, 5L)] + y[rep(1L, 5L),]\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55\n\nouter(x, y, \"+\") |&gt; drop()\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55\n\nTo compute the outer sum using broadcasting through the ‘broadcast’ package, we can do the following:\n\nlibrary(broadcast)\n\nbc.num(x, y, \"+\")\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]   11   21   31   41   51\n#&gt; [2,]   12   22   32   42   52\n#&gt; [3,]   13   23   33   43   53\n#&gt; [4,]   14   24   34   44   54\n#&gt; [5,]   15   25   35   45   55\n\nThe result is the same (as it should). But as the size of the resulting array increases, the broadcasted functions become more and more efficient in terms of both speed and memory, in comparison with base ‘R’ approaches.\nBenchmarks can be found on the website."
  },
  {
    "objectID": "vignettes/c_broadcasting_explained.html#conformability",
    "href": "vignettes/c_broadcasting_explained.html#conformability",
    "title": "Broadcasting Explained",
    "section": "4.1 Conformability",
    "text": "4.1 Conformability\nBroadcasted operations only work when 2 arrays are conformable for broadcasting.\nConsider again 2 arrays x and y, and their dimensions given by dim(x) and dim(y), respectively.\n‘broadcast’ goes through dim(x) and dim(y), from left (i.e. first dimension / rows) to right (i.e. the last dimension), and checks for each axis i if at least one of the following conditions is TRUE:\n\ndim(x)[i] and dim(y)[i] are equal;\neither dim(x)[i] or dim(y)[i] is 1;\neither dim(x)[i] or dim(y)[i] is non-existing.\n\nif at least one of the above conditions is true for each and every one of the dimensions of x and y, the 2 arrays are compatible for broadcasted operations. If not, they are not compatible, and attempting to perform a broadcasted operations results in an error.\nTo illustrate, let’s check 2 arrays to see if they are compatible:\n\nx &lt;- array(rnorm(10), c(10, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 5, 1))\n\n\n\n\n\n\ndim(x)\ndim(y)\ncompatible\nreason\n\n\n\n\n10\n10\nTRUE\nequal\n\n\n1\n5\nTRUE\neither is 1\n\n\n9\n1\nTRUE\neither is 1\n\n\n6\nNA\nTRUE\neither is missing\n\n\n\n\n\n\n\nAs shown in the data.frame above, all dimensions of x and y are compatible.\nTherefore, broadcasted binary operations involving x and y can be performed.\n \nNow let’s look at another 2 arrays, and see if they are compatible:\n\nx &lt;- array(rnorm(10), c(10, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 5, 2))\n\n\n\n\n\n\ndim(x)\ndim(y)\ncompatible\nreason\n\n\n\n\n10\n10\nTRUE\nequal\n\n\n1\n5\nTRUE\neither is 1\n\n\n9\n2\nFALSE\nnot equal & neither is 1/missing\n\n\n6\nNA\nTRUE\neither is missing\n\n\n\n\n\n\n\nOne of the dimensions, namely the third dimension, is not compatible. Therefore, these 2 arrays are not conformable for broadcasted operations."
  },
  {
    "objectID": "vignettes/c_broadcasting_explained.html#which-dimensions-are-broadcasted",
    "href": "vignettes/c_broadcasting_explained.html#which-dimensions-are-broadcasted",
    "title": "Broadcasting Explained",
    "section": "4.2 Which dimensions are broadcasted",
    "text": "4.2 Which dimensions are broadcasted\nIn the context of an operation involving exactly 2 arrays, this sub-section explains which dimensions of which array is broadcasted, and which dimension of which array is left as-is.\nThere are 3 scenarios relevant for this explanation.\n \nScenario 1:\nFor some dimension i, dim(x)[i] and dim(y)[i] are equal.\nIn this scenario, no broadcasting needs to occur on that dimension for either array.\n \nScenario 2:\nFor some dimension i, suppose dim(x)[i] == 1 and dim(y)[i] &gt; 1.\nThen dimension dim(x)[i] is broadcasted to size dim(y)[i].\nSimilarly, if dim(x)[i] &gt; 1 and dim(y)[i] == 1, dimension dim(y)[i] is broadcasted to size dim(x)[i].\n \nScenario 3:\nFinally, suppose for some dimension i, dim(x)[i] &gt; 1, and dim(y)[i] is non-existing.\nI.e., x has more dimensions than y.\nIn this case, the missing dimension in y is replaced with a dimensions of size 1, and scenario 2 is used.\nSimilarly, if dim(y)[i] &gt; 1 and dim(x)[i] is non-existing, the missing dimension in x is replaced with a dimension of size 1 and we get back to scenario 2.\nIt does not matter how much difference there is between the number of dimensions of x and the number of dimensions of y: any number of missing dimensions will be replaced with 1, as long as the total number of dimensions for each array does not exceed 16.\n \nIllustration\nTo illustrate, let’s check 2 conformable arrays, and see which dimension of which array is broadcasted by how much\n\nx &lt;- array(rnorm(10), c(10, 1, 1, 9, 6))\ny &lt;- array(rnorm(10), c(10, 1, 5, 1))\n\n\n\n\n\n\ni\ndim(x)\ndim(y)\nbroadcasted\nreason\nnote\n\n\n\n\n1\n10\n10\nneither\ndims equal\n\n\n\n2\n1\n1\nneither\ndims equal\n\n\n\n3\n1\n5\nx\ndim(x)[i] == 1\ndim(x)[i] recycled to size 5\n\n\n4\n9\n1\ny\ndim(y)[i] == 1\ndim(y)[i] recycled to size 9\n\n\n5\n6\nNA\ny\ndim(y)[i] is missing\ndim(y) extended by 1 & recycled to size 6"
  },
  {
    "objectID": "vignettes/e_practical_applications.html",
    "href": "vignettes/e_practical_applications.html",
    "title": "Practical Applications",
    "section": "",
    "text": "Introduction\nBroadcasting comes up frequent enough in real world problems. This articles gives a few examples of these.\n \n\n\nVector quantization\nThis first example is taken from Numpy’s own documentation.\nThe basic operation in Vector Quantization (VQ) finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown below, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, codes[0] is the closest class indicating that the athlete is likely a basketball player.\n\n\nobservation &lt;- array(c(111.0, 188.0), dim = c(1, 2))\ncodes &lt;- array(\n  c(102.0, 203.0,\n    132.0, 193.0,\n    45.0, 155.0,\n    57.0, 173.0),\n  dim = c(4, 2)\n)\n\ndiff &lt;- bc.num(codes, observation, \"-\")\ndist &lt;- apply(diff^2, 2L, sum) |&gt; sqrt()\nwhich.min(dist); dist[which.min(dist)]\n#&gt; [1] 1\n#&gt; [1] 125.3395\n\n \n\n\nPerform computation on all possible pairs\nSuppose you have 2 vectors of strings, and you want to find concatenate every possible pair strings.\nIn base R, this would require a either a loop (which is slow), or repeating the vectors several times (which requires more memory).\nThe ’broadcasted way to do this, is to make the vectors orthogonal, and concatenate the strings of the orthogonal vectors, using the following code:\n\nx &lt;- array(letters[1:10], c(10, 1))\ny &lt;- array(letters[1:10], c(1, 10))\n\nout &lt;- bc.str(x, y, \"+\")\ndimnames(out) &lt;- list(x, y)\nprint(out)\n#&gt;   a    b    c    d    e    f    g    h    i    j   \n#&gt; a \"aa\" \"ab\" \"ac\" \"ad\" \"ae\" \"af\" \"ag\" \"ah\" \"ai\" \"aj\"\n#&gt; b \"ba\" \"bb\" \"bc\" \"bd\" \"be\" \"bf\" \"bg\" \"bh\" \"bi\" \"bj\"\n#&gt; c \"ca\" \"cb\" \"cc\" \"cd\" \"ce\" \"cf\" \"cg\" \"ch\" \"ci\" \"cj\"\n#&gt; d \"da\" \"db\" \"dc\" \"dd\" \"de\" \"df\" \"dg\" \"dh\" \"di\" \"dj\"\n#&gt; e \"ea\" \"eb\" \"ec\" \"ed\" \"ee\" \"ef\" \"eg\" \"eh\" \"ei\" \"ej\"\n#&gt; f \"fa\" \"fb\" \"fc\" \"fd\" \"fe\" \"ff\" \"fg\" \"fh\" \"fi\" \"fj\"\n#&gt; g \"ga\" \"gb\" \"gc\" \"gd\" \"ge\" \"gf\" \"gg\" \"gh\" \"gi\" \"gj\"\n#&gt; h \"ha\" \"hb\" \"hc\" \"hd\" \"he\" \"hf\" \"hg\" \"hh\" \"hi\" \"hj\"\n#&gt; i \"ia\" \"ib\" \"ic\" \"id\" \"ie\" \"if\" \"ig\" \"ih\" \"ii\" \"ij\"\n#&gt; j \"ja\" \"jb\" \"jc\" \"jd\" \"je\" \"jf\" \"jg\" \"jh\" \"ji\" \"jj\""
  }
]