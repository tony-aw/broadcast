tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp)
)
foo <- bench::mark(
base = tempfun(x, grp),
acast = acast(x, 1L, grp),
check = FALSE,
min_iterations = 100
)
n <- 2500
m <- 500
x <- matrix(1:m, n, n)
grp <- as.factor(sample(1:(m-1L), n, TRUE))
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp)
)
tinytest::expect_equivalent(
tempfun(x, grp),
acast(x, 1L, grp, TRUE)
)
foo <- bench::mark(
base = tempfun(x, grp),
acast = acast(x, 1L, grp, TRUE),
check = FALSE,
min_iterations = 100
)
summary(foo)
ggplot2::autoplot(foo)
pryr::show_c_source(.Primitive("%%"))
4.94065645841247E-324
4.94065645841247E-324 * 10
4.94065645841247E-324 * 10^324
4.94065645841247E-324 * 10^32
4.94065645841247E-324 * 10^320
4.94065645841247E-324 * 10^50
4.94065645841247E-324 * 10^60
4.94065645841247E-324 * 10^100
4.94065645841247E-324 * 10^200
4.94065645841247E-324 * 10^250
4.94065645841247E-324 * 10^300
4.94065645841247E-324 * 10^324
4.94065645841247E-324 * 10^323
4.94065645841247E-324 * 10^320
4.94065645841247E-324 * 10^310
4.94065645841247E-324 * 10^300
4.94065645841247E-324 * 10^310
4.94065645841247E-324 * 10^305
4.94065645841247E-324 * 10^306
4.94065645841247E-324 * 10^309
4.94065645841247E-324 * 10^308
4.94065645841247E-324 * 10^308 + 4*10^16
4.94065645841247E-324 * 10^308 + 4*10^15
4.94065645841247E-324 * 10^308
4.94065645841247E-324 * 10^309
4.94065645841247E-324 * 10^308 +10
4.94065645841247E-324 * 10^308 +1
2^53
1/(2^53)
1/(2^53) < 4.9e-324
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
library(broadcast)
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
# make convenient functions ====
best_dim_sizes <- function(target_len, ndim, start1) {
n <- floor(target_len^(1/ndim)) # floor to allow easy correction later
if(start1) {
out <- rep(c(1L, n), ndim)[1:ndim]
}
else {
out <- rep(c(n, 1L), ndim)[1:ndim]
}
# adjust last non-1 size to ensure target len is correct:
if(ndim > 2) {
myprod <- n^(ndim - 1)
ind2change <- max(which(out > 1L))
out[ind2change] <- floor(target_len/myprod)
}
return(as.integer(out))
}
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
# loop
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", 7)
counter <- 1L
target_len <- 9e6
for(i in 2:8) {
print(i)
x.dims <- best_dim_sizes(target_len, i, FALSE)
y.dims <- best_dim_sizes(target_len, i, TRUE)
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 100
)
bc_all <- get_times(res, "broadcast")
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = 2:8
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = 2:8
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = 2:8
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "number of dimensions",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website/vignettes")
# set-up ====
library(broadcast)
library(reticulate)
np <- import("numpy", convert = FALSE)
gc <- import("gc", convert = FALSE)
gc$disable()
get_times <- function(obj, j) {
nms <- names(res$expression)
j <- which(nms == j)
idx <- rowSums(obj$gc[[j]][, 2:3]) == 0
times <- obj$time[[j]][idx]
return(times)
}
# loop 2d ====
gc()
# loop 3d ====
gc()
dimsizes <- seq(20L, 200L,  by = 10L)
dimsizes <- seq(50L, 200L,  by = 10L)
# loop 3d ====
gc()
dimsizes <- seq(50L, 200L,  by = 10L)
niter <- length(dimsizes)
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", niter)
counter <- 1L
for(i in seq_along(dimsizes)) {
print(i)
n <- dimsizes[i]
x.dims <- rep(c(n, 1L), 2)[1:3]
y.dims <- rep(c(1L, n), 2)[1:3]
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200
)
bc_all <- get_times(res, "broadcast")
if(length(bc_all) < 100) {
stop("too few benchmarks for 'R'")
}
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = dimsizes
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = dimsizes
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = dimsizes
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "size of each dimension",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
# loop 3d ====
gc()
dimsizes <- seq(50L, 200L,  by = 10L)
niter <- length(dimsizes)
median_bc <- median_np <- q1_bc <- q1_np <- q3_bc <- q3_np <- vector("numeric", niter)
counter <- 1L
for(i in seq_along(dimsizes)) {
print(i)
n <- dimsizes[i]
x.dims <- rep(c(n, 1L), 2)[1:3]
y.dims <- rep(c(1L, n), 2)[1:3]
a.dims <- r_to_py(as.list(x.dims))
b.dims <- r_to_py(as.list(y.dims))
npa <- np$random$random_sample(a.dims)
npb <- np$random$random_sample(b.dims)
a <- array(runif(100), x.dims)
b <- array(runif(100), y.dims)
res <- bench::mark(
broadcast = bc.num(a, b, "+"),
`numpy (NO conversion to R)` = npa + npb,
check = FALSE,
min_iterations = 200
)
bc_all <- get_times(res, "broadcast")
if(length(bc_all) < 100) {
stop("too few benchmarks for 'R'")
}
np_all <- get_times(res, "numpy (NO conversion to R)")
median_bc[counter] <- median(bc_all)
median_np[counter] <- median(np_all)
q1_bc[counter] <- quantile(bc_all, 0.25)
q3_bc[counter] <- quantile(bc_all, 0.75)
q1_np[counter] <- quantile(np_all, 0.25)
q3_np[counter] <- quantile(np_all, 0.75)
counter <- counter + 1L
}
library(tinyplot) |> suppressWarnings()
df1 <- data.frame(
broadcast = median_bc, numpy = median_np, i = dimsizes
)
df1 <- tidyr::pivot_longer(df1, 1:2, values_to = "median")
df2 <- data.frame(
q1_bc, q1_np, i = dimsizes
)
df2 <- tidyr::pivot_longer(df2, 1:2, values_to = "q1")
df3 <- data.frame(
q3_bc, q3_np, i = dimsizes
)
df3 <- tidyr::pivot_longer(df3, 1:2, values_to = "q3")
df <- cbind(df1, df2[, 3], df3[, 3])
module <- df$name
tinytheme("minimal")
tinyplot(
df$i, df$median*1000, by = module, type = "l",
main = "benchmarks",
xlab = "size of each dimension",
ylab = "median time (ms)"
)
tinyplot_add(
min = df$q1*1000, ymax = df$q3*1000, by = module,
type = type_ribbon(alpha = 0.25)
)
setwd("D:/D Desktop/Publications/R package broadcast/broadcast/website/vignettes")
save(
dimsizes, median_bc, median_np, q1_bc, q3_bc, q1_np, q3_np,
file = "bm_numpy_loop_3d.RData"
)
outer(1:10, 1:10)
x <- array(1:5, c(5, 1))
x[, rep(1L, 5L)]
x[, rep(1L, 1e6L)]
y <- x[, rep(1L, 1e6L)]
x <- array(1:5, c(5, 1))
y <- array(1:5*10, c(1, 5))
?outer
x <- array(1:5, c(5, 1, 5))
y <- array(1:5*10, c(5, 1, 5))
library(broadcast)
outer(x, y) |> drop()
library(tinytest)
expect_equal(outer(x, y) |> drop(), bc.d(x, y, "*"))
bc.d(x, y, "*")
x
y
y
x <- array(1:5, c(5, 1, 5))
y <- array(1:5*10, c(1, 5, 1))
expect_equal(outer(x, y) |> drop(), bc.d(x, y, "*"))
expect_equal(outer(x, y, "*") |> drop(), bc.d(x, y, "*"))
